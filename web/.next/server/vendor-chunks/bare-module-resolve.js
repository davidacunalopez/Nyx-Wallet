/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bare-module-resolve";
exports.ids = ["vendor-chunks/bare-module-resolve"];
exports.modules = {

/***/ "(ssr)/./node_modules/bare-module-resolve/index.js":
/*!***************************************************!*\
  !*** ./node_modules/bare-module-resolve/index.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const { satisfies } = __webpack_require__(/*! bare-semver */ \"(ssr)/./node_modules/bare-semver/index.js\")\nconst errors = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/bare-module-resolve/lib/errors.js\")\n\nmodule.exports = exports = function resolve(\n  specifier,\n  parentURL,\n  opts,\n  readPackage\n) {\n  if (typeof opts === 'function') {\n    readPackage = opts\n    opts = {}\n  } else if (typeof readPackage !== 'function') {\n    readPackage = defaultReadPackage\n  }\n\n  return {\n    *[Symbol.iterator]() {\n      const generator = exports.module(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    },\n\n    async *[Symbol.asyncIterator]() {\n      const generator = exports.module(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(await readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    }\n  }\n}\n\nfunction defaultReadPackage() {\n  return null\n}\n\n// No resolution candidate was yielded\nconst UNRESOLVED = 0x0\n// At least 1 resolution candidate was yielded\nconst YIELDED = 0x1\n// At least 1 resolution candidate was yielded and resolved\nconst RESOLVED = YIELDED | 0x2\n\nexports.constants = {\n  UNRESOLVED,\n  YIELDED,\n  RESOLVED\n}\n\nexports.module = function* (specifier, parentURL, opts = {}) {\n  const { resolutions = null, imports = null } = opts\n\n  if (exports.startsWithWindowsDriveLetter(specifier)) {\n    specifier = '/' + specifier\n  }\n\n  let status\n\n  if (resolutions) {\n    status = yield* exports.preresolved(specifier, resolutions, parentURL, opts)\n\n    if (status) return status\n  }\n\n  status = yield* exports.url(specifier, parentURL, opts)\n\n  if (status) return status\n\n  status = yield* exports.packageImports(specifier, parentURL, opts)\n\n  if (status) return status\n\n  if (\n    specifier === '.' ||\n    specifier === '..' ||\n    specifier[0] === '/' ||\n    specifier[0] === '\\\\' ||\n    specifier.startsWith('./') ||\n    specifier.startsWith('.\\\\') ||\n    specifier.startsWith('../') ||\n    specifier.startsWith('..\\\\')\n  ) {\n    if (imports) {\n      status = yield* exports.packageImportsExports(\n        specifier,\n        imports,\n        parentURL,\n        true,\n        opts\n      )\n\n      if (status) return status\n    }\n\n    status = yield* exports.deferred(specifier, opts)\n\n    if (status) return status\n\n    status = yield* exports.file(specifier, parentURL, false, opts)\n\n    if (status === RESOLVED) return status\n\n    return yield* exports.directory(specifier, parentURL, opts)\n  }\n\n  return yield* exports.package(specifier, parentURL, opts)\n}\n\nexports.url = function* (url, parentURL, opts = {}) {\n  const { imports = null, deferredProtocol = 'deferred:' } = opts\n\n  let resolution\n  try {\n    resolution = new URL(url)\n  } catch {\n    return UNRESOLVED\n  }\n\n  if (imports) {\n    const status = yield* exports.packageImportsExports(\n      resolution.href,\n      imports,\n      parentURL,\n      true,\n      opts\n    )\n\n    if (status) return status\n  }\n\n  if (resolution.protocol === deferredProtocol) {\n    const specifier = resolution.pathname\n\n    return yield* exports.module(specifier, parentURL, opts)\n  }\n\n  if (resolution.protocol === 'node:') {\n    const specifier = resolution.pathname\n\n    if (\n      specifier === '.' ||\n      specifier === '..' ||\n      specifier[0] === '/' ||\n      specifier.startsWith('./') ||\n      specifier.startsWith('../')\n    ) {\n      throw errors.INVALID_MODULE_SPECIFIER(\n        `Module specifier '${url}' is not a valid package name`\n      )\n    }\n\n    return yield* exports.package(specifier, parentURL, opts)\n  }\n\n  const resolved = yield { resolution }\n\n  return resolved ? RESOLVED : YIELDED\n}\n\nexports.preresolved = function* (specifier, resolutions, parentURL, opts = {}) {\n  const imports = resolutions[parentURL.href]\n\n  if (typeof imports === 'object' && imports !== null) {\n    return yield* exports.packageImportsExports(\n      specifier,\n      imports,\n      parentURL,\n      true,\n      opts\n    )\n  }\n\n  return UNRESOLVED\n}\n\nexports.deferred = function* (specifier, opts = {}) {\n  const { deferredProtocol = 'deferred:', defer = [] } = opts\n\n  if (defer.includes(specifier)) {\n    const resolved = yield { resolution: new URL(deferredProtocol + specifier) }\n\n    return resolved ? RESOLVED : YIELDED\n  }\n\n  return UNRESOLVED\n}\n\nexports[\"package\"] = function* (packageSpecifier, parentURL, opts = {}) {\n  const { builtins = [] } = opts\n\n  if (packageSpecifier === '') {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  let packageName\n\n  if (packageSpecifier[0] !== '@') {\n    packageName = packageSpecifier.split('/', 1).join()\n  } else {\n    if (!packageSpecifier.includes('/')) {\n      throw errors.INVALID_MODULE_SPECIFIER(\n        `Module specifier '${packageSpecifier}' is not a valid package name`\n      )\n    }\n\n    packageName = packageSpecifier.split('/', 2).join('/')\n  }\n\n  if (\n    packageName[0] === '.' ||\n    packageName.includes('\\\\') ||\n    packageName.includes('%')\n  ) {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  let status\n\n  status = yield* exports.builtinTarget(packageSpecifier, null, builtins, opts)\n\n  if (status) return status\n\n  status = yield* exports.deferred(packageSpecifier, opts)\n\n  if (status) return status\n\n  let packageSubpath = '.' + packageSpecifier.substring(packageName.length)\n\n  status = yield* exports.packageSelf(\n    packageName,\n    packageSubpath,\n    parentURL,\n    opts\n  )\n\n  if (status) return status\n\n  parentURL = new URL(parentURL.href)\n\n  do {\n    const packageURL = new URL('node_modules/' + packageName + '/', parentURL)\n\n    parentURL.pathname = parentURL.pathname.substring(\n      0,\n      parentURL.pathname.lastIndexOf('/')\n    )\n\n    const info = yield { package: new URL('package.json', packageURL) }\n\n    if (info) {\n      if (info.engines) exports.validateEngines(packageURL, info.engines, opts)\n\n      if (info.exports) {\n        return yield* exports.packageExports(\n          packageURL,\n          packageSubpath,\n          info.exports,\n          opts\n        )\n      }\n\n      if (packageSubpath === '.') {\n        if (typeof info.main === 'string' && info.main !== '') {\n          packageSubpath = info.main\n        } else {\n          return yield* exports.file('index', packageURL, true, opts)\n        }\n      }\n\n      status = yield* exports.file(packageSubpath, packageURL, false, opts)\n\n      if (status === RESOLVED) return status\n\n      return yield* exports.directory(packageSubpath, packageURL, opts)\n    }\n  } while (parentURL.pathname !== '' && parentURL.pathname !== '/')\n\n  return UNRESOLVED\n}\n\nexports.packageSelf = function* (\n  packageName,\n  packageSubpath,\n  parentURL,\n  opts = {}\n) {\n  for (const packageURL of exports.lookupPackageScope(parentURL, opts)) {\n    const info = yield { package: packageURL }\n\n    if (info) {\n      if (info.name !== packageName) return false\n\n      if (info.exports) {\n        return yield* exports.packageExports(\n          packageURL,\n          packageSubpath,\n          info.exports,\n          opts\n        )\n      }\n\n      if (packageSubpath === '.') {\n        if (typeof info.main === 'string' && info.main !== '') {\n          packageSubpath = info.main\n        } else {\n          return yield* exports.file('index', packageURL, true, opts)\n        }\n      }\n\n      const status = yield* exports.file(\n        packageSubpath,\n        packageURL,\n        false,\n        opts\n      )\n\n      if (status === RESOLVED) return status\n\n      return yield* exports.directory(packageSubpath, packageURL, opts)\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.packageExports = function* (\n  packageURL,\n  subpath,\n  packageExports,\n  opts = {}\n) {\n  if (subpath === '.') {\n    let mainExport\n\n    if (typeof packageExports === 'string' || Array.isArray(packageExports)) {\n      mainExport = packageExports\n    } else if (typeof packageExports === 'object' && packageExports !== null) {\n      const keys = Object.keys(packageExports)\n\n      if (keys.some((key) => key.startsWith('.'))) {\n        if ('.' in packageExports) mainExport = packageExports['.']\n      } else {\n        mainExport = packageExports\n      }\n    }\n\n    if (mainExport) {\n      const status = yield* exports.packageTarget(\n        packageURL,\n        mainExport,\n        null,\n        false,\n        opts\n      )\n\n      if (status) return status\n    }\n  } else if (typeof packageExports === 'object' && packageExports !== null) {\n    const keys = Object.keys(packageExports)\n\n    if (keys.every((key) => key.startsWith('.'))) {\n      const status = yield* exports.packageImportsExports(\n        subpath,\n        packageExports,\n        packageURL,\n        false,\n        opts\n      )\n\n      if (status) return status\n    }\n  }\n\n  packageURL = new URL('package.json', packageURL)\n\n  throw errors.PACKAGE_PATH_NOT_EXPORTED(\n    `Package subpath '${subpath}' is not defined by \"exports\" in '${packageURL}'`\n  )\n}\n\nexports.packageImports = function* (specifier, parentURL, opts = {}) {\n  const { imports = null } = opts\n\n  if (specifier === '#' || specifier.startsWith('#/')) {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${specifier}' is not a valid internal imports specifier`\n    )\n  }\n\n  for (const packageURL of exports.lookupPackageScope(parentURL, opts)) {\n    const info = yield { package: packageURL }\n\n    if (info) {\n      if (info.imports) {\n        const status = yield* exports.packageImportsExports(\n          specifier,\n          info.imports,\n          packageURL,\n          true,\n          opts\n        )\n\n        if (status) return status\n      }\n\n      if (specifier.startsWith('#')) {\n        throw errors.PACKAGE_IMPORT_NOT_DEFINED(\n          `Package import specifier '${specifier}' is not defined by \"imports\" in '${packageURL}'`\n        )\n      }\n\n      break\n    }\n  }\n\n  if (imports) {\n    const status = yield* exports.packageImportsExports(\n      specifier,\n      imports,\n      parentURL,\n      true,\n      opts\n    )\n\n    if (status) return status\n  }\n\n  return UNRESOLVED\n}\n\nexports.packageImportsExports = function* (\n  matchKey,\n  matchObject,\n  packageURL,\n  isImports,\n  opts = {}\n) {\n  if (matchKey in matchObject && !matchKey.includes('*')) {\n    const target = matchObject[matchKey]\n\n    return yield* exports.packageTarget(\n      packageURL,\n      target,\n      null,\n      isImports,\n      opts\n    )\n  }\n\n  const expansionKeys = Object.keys(matchObject)\n    .filter((key) => key.includes('*'))\n    .sort(exports.patternKeyCompare)\n\n  for (const expansionKey of expansionKeys) {\n    const patternIndex = expansionKey.indexOf('*')\n    const patternBase = expansionKey.substring(0, patternIndex)\n\n    if (matchKey.startsWith(patternBase) && matchKey !== patternBase) {\n      const patternTrailer = expansionKey.substring(patternIndex + 1)\n\n      if (\n        patternTrailer === '' ||\n        (matchKey.endsWith(patternTrailer) &&\n          matchKey.length >= expansionKey.length)\n      ) {\n        const target = matchObject[expansionKey]\n\n        const patternMatch = matchKey.substring(\n          patternBase.length,\n          matchKey.length - patternTrailer.length\n        )\n\n        return yield* exports.packageTarget(\n          packageURL,\n          target,\n          patternMatch,\n          isImports,\n          opts\n        )\n      }\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.validateEngines = function validateEngines(\n  packageURL,\n  packageEngines,\n  opts = {}\n) {\n  const { engines = {} } = opts\n\n  for (const [engine, range] of Object.entries(packageEngines)) {\n    if (engine in engines) {\n      const version = engines[engine]\n\n      if (!satisfies(version, range)) {\n        packageURL = new URL('package.json', packageURL)\n\n        throw errors.UNSUPPORTED_ENGINE(\n          `Package not compatible with engine '${engine}' ${version}, requires range '${range}' defined by \"engines\" in '${packageURL}'`\n        )\n      }\n    }\n  }\n}\n\nexports.patternKeyCompare = function patternKeyCompare(keyA, keyB) {\n  const patternIndexA = keyA.indexOf('*')\n  const patternIndexB = keyB.indexOf('*')\n  const baseLengthA = patternIndexA === -1 ? keyA.length : patternIndexA + 1\n  const baseLengthB = patternIndexB === -1 ? keyB.length : patternIndexB + 1\n  if (baseLengthA > baseLengthB) return -1\n  if (baseLengthB > baseLengthA) return 1\n  if (patternIndexA === -1) return 1\n  if (patternIndexB === -1) return -1\n  if (keyA.length > keyB.length) return -1\n  if (keyB.length > keyA.length) return 1\n  return 0\n}\n\nexports.packageTarget = function* (\n  packageURL,\n  target,\n  patternMatch,\n  isImports,\n  opts = {}\n) {\n  const { conditions = [], matchedConditions = [] } = opts\n\n  if (typeof target === 'string') {\n    if (!target.startsWith('./') && !isImports) {\n      packageURL = new URL('package.json', packageURL)\n\n      throw errors.INVALID_PACKAGE_TARGET(\n        `Invalid target '${target}' defined by \"exports\" in '${packageURL}'`\n      )\n    }\n\n    if (patternMatch !== null) {\n      target = target.replaceAll('*', patternMatch)\n    }\n\n    const status = yield* exports.url(target, packageURL, opts)\n\n    if (status) return status\n\n    if (\n      target === '.' ||\n      target === '..' ||\n      target[0] === '/' ||\n      target.startsWith('./') ||\n      target.startsWith('../')\n    ) {\n      const resolved = yield { resolution: new URL(target, packageURL) }\n\n      return resolved ? RESOLVED : YIELDED\n    }\n\n    return yield* exports.package(target, packageURL, opts)\n  }\n\n  if (Array.isArray(target)) {\n    for (const targetValue of target) {\n      const status = yield* exports.packageTarget(\n        packageURL,\n        targetValue,\n        patternMatch,\n        isImports,\n        opts\n      )\n\n      if (status) return status\n    }\n  } else if (typeof target === 'object' && target !== null) {\n    let status = UNRESOLVED\n\n    for (const [condition, targetValue, subset] of exports.conditionMatches(\n      target,\n      conditions,\n      opts\n    )) {\n      matchedConditions.push(condition)\n\n      status |= yield* exports.packageTarget(\n        packageURL,\n        targetValue,\n        patternMatch,\n        isImports,\n        { ...opts, conditions: subset }\n      )\n\n      matchedConditions.pop()\n    }\n\n    if (status) return status\n  }\n\n  return UNRESOLVED\n}\n\nexports.builtinTarget = function* (\n  packageSpecifier,\n  packageVersion,\n  target,\n  opts = {}\n) {\n  const {\n    builtinProtocol = 'builtin:',\n    conditions = [],\n    matchedConditions = []\n  } = opts\n\n  if (typeof target === 'string') {\n    const targetParts = target.split('@')\n\n    let targetName\n    let targetVersion\n\n    if (target[0] !== '@') {\n      targetName = targetParts[0]\n      targetVersion = targetParts[1] || null\n    } else {\n      targetName = targetParts.slice(0, 2).join('@')\n      targetVersion = targetParts[2] || null\n    }\n\n    if (packageSpecifier === targetName) {\n      if (packageVersion === null && targetVersion === null) {\n        const resolved = yield {\n          resolution: new URL(builtinProtocol + packageSpecifier)\n        }\n\n        return resolved ? RESOLVED : YIELDED\n      }\n\n      let version = null\n\n      if (packageVersion === null) {\n        version = targetVersion\n      } else if (targetVersion === null || packageVersion === targetVersion) {\n        version = packageVersion\n      }\n\n      if (version !== null) {\n        const resolved = yield {\n          resolution: new URL(\n            builtinProtocol + packageSpecifier + '@' + version\n          )\n        }\n\n        return resolved ? RESOLVED : YIELDED\n      }\n    }\n  } else if (Array.isArray(target)) {\n    for (const targetValue of target) {\n      const status = yield* exports.builtinTarget(\n        packageSpecifier,\n        packageVersion,\n        targetValue,\n        opts\n      )\n\n      if (status) return status\n    }\n  } else if (typeof target === 'object' && target !== null) {\n    let status = UNRESOLVED\n\n    for (const [condition, targetValue, subset] of exports.conditionMatches(\n      target,\n      conditions,\n      opts\n    )) {\n      matchedConditions.push(condition)\n\n      status |= yield* exports.builtinTarget(\n        packageSpecifier,\n        packageVersion,\n        targetValue,\n        { ...opts, conditions: subset }\n      )\n\n      matchedConditions.pop()\n    }\n\n    if (status) return status\n  }\n\n  return UNRESOLVED\n}\n\nexports.conditionMatches = function* conditionMatches(\n  target,\n  conditions,\n  opts = {}\n) {\n  if (conditions.every((condition) => typeof condition === 'string')) {\n    const keys = Object.keys(target)\n\n    for (const condition of keys) {\n      if (condition === 'default' || conditions.includes(condition)) {\n        yield [condition, target[condition], conditions]\n\n        return true\n      }\n    }\n\n    return false\n  }\n\n  let yielded = false\n\n  for (const subset of conditions) {\n    if (yield* conditionMatches(target, subset, opts)) {\n      yielded = true\n    }\n  }\n\n  return yielded\n}\n\nexports.lookupPackageScope = function* lookupPackageScope(url, opts = {}) {\n  const { resolutions = null } = opts\n\n  if (resolutions) {\n    for (const { resolution } of exports.preresolved(\n      '#package',\n      resolutions,\n      url,\n      opts\n    )) {\n      if (resolution) return yield resolution\n    }\n\n    // Internal preresolution path, do not depend on this! It will be removed without\n    // warning.\n    for (const { resolution } of exports.preresolved(\n      'bare:package',\n      resolutions,\n      url,\n      opts\n    )) {\n      if (resolution) return yield resolution\n    }\n  }\n\n  const scopeURL = new URL(url.href)\n\n  do {\n    if (scopeURL.pathname.endsWith('/node_modules')) break\n\n    yield new URL('package.json', scopeURL)\n\n    scopeURL.pathname = scopeURL.pathname.substring(\n      0,\n      scopeURL.pathname.lastIndexOf('/')\n    )\n\n    if (\n      scopeURL.pathname.length === 3 &&\n      exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))\n    ) {\n      break\n    }\n  } while (scopeURL.pathname !== '' && scopeURL.pathname !== '/')\n}\n\nexports.file = function* (filename, parentURL, isIndex, opts = {}) {\n  if (\n    filename === '.' ||\n    filename === '..' ||\n    filename[filename.length - 1] === '/' ||\n    filename[filename.length - 1] === '\\\\'\n  ) {\n    return UNRESOLVED\n  }\n\n  if (parentURL.protocol === 'file:' && /%2f|%5c/i.test(filename)) {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${filename}' is invalid`\n    )\n  }\n\n  const { extensions = [] } = opts\n\n  let status = UNRESOLVED\n\n  if (!isIndex) {\n    if (yield { resolution: new URL(filename, parentURL) }) {\n      return RESOLVED\n    }\n\n    status = YIELDED\n  }\n\n  for (const ext of extensions) {\n    if (yield { resolution: new URL(filename + ext, parentURL) }) {\n      return RESOLVED\n    }\n\n    status = YIELDED\n  }\n\n  return status\n}\n\nexports.directory = function* (dirname, parentURL, opts = {}) {\n  let directoryURL\n\n  if (\n    dirname[dirname.length - 1] === '/' ||\n    dirname[dirname.length - 1] === '\\\\'\n  ) {\n    directoryURL = new URL(dirname, parentURL)\n  } else {\n    directoryURL = new URL(dirname + '/', parentURL)\n  }\n\n  const info = yield { package: new URL('package.json', directoryURL) }\n\n  if (info) {\n    if (info.exports) {\n      return yield* exports.packageExports(\n        directoryURL,\n        '.',\n        info.exports,\n        opts\n      )\n    }\n\n    if (typeof info.main === 'string' && info.main !== '') {\n      const status = yield* exports.file(info.main, directoryURL, false, opts)\n\n      if (status === RESOLVED) return status\n\n      return yield* exports.directory(info.main, directoryURL, opts)\n    }\n  }\n\n  return yield* exports.file('index', directoryURL, true, opts)\n}\n\n// https://infra.spec.whatwg.org/#ascii-upper-alpha\nfunction isASCIIUpperAlpha(c) {\n  return c >= 0x41 && c <= 0x5a\n}\n\n// https://infra.spec.whatwg.org/#ascii-lower-alpha\nfunction isASCIILowerAlpha(c) {\n  return c >= 0x61 && c <= 0x7a\n}\n\n// https://infra.spec.whatwg.org/#ascii-alpha\nfunction isASCIIAlpha(c) {\n  return isASCIIUpperAlpha(c) || isASCIILowerAlpha(c)\n}\n\n// https://url.spec.whatwg.org/#windows-drive-letter\nexports.isWindowsDriveLetter = function isWindowsDriveLetter(input) {\n  return (\n    input.length >= 2 &&\n    isASCIIAlpha(input.charCodeAt(0)) &&\n    (input.charCodeAt(1) === 0x3a || input.charCodeAt(1) === 0x7c)\n  )\n}\n\n// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter\nexports.startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(\n  input\n) {\n  return (\n    input.length >= 2 &&\n    exports.isWindowsDriveLetter(input) &&\n    (input.length === 2 ||\n      input.charCodeAt(2) === 0x2f ||\n      input.charCodeAt(2) === 0x5c ||\n      input.charCodeAt(2) === 0x3f ||\n      input.charCodeAt(2) === 0x23)\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1tb2R1bGUtcmVzb2x2ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyw0RUFBYzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDZDQUE2QztBQUMzRCxVQUFVLHFDQUFxQzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyx1Q0FBdUM7QUFDbEQsVUFBVSxpREFBaUQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVU1VBUklPXFxEb2N1bWVudHNcXEdpdGh1YlxcR2FsYXh5S0otd2FsbGV0LS0tSGFja1xcd2ViXFxub2RlX21vZHVsZXNcXGJhcmUtbW9kdWxlLXJlc29sdmVcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgc2F0aXNmaWVzIH0gPSByZXF1aXJlKCdiYXJlLXNlbXZlcicpXG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2xpYi9lcnJvcnMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiByZXNvbHZlKFxuICBzcGVjaWZpZXIsXG4gIHBhcmVudFVSTCxcbiAgb3B0cyxcbiAgcmVhZFBhY2thZ2Vcbikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWFkUGFja2FnZSA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVhZFBhY2thZ2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZWFkUGFja2FnZSA9IGRlZmF1bHRSZWFkUGFja2FnZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICBjb25zdCBnZW5lcmF0b3IgPSBleHBvcnRzLm1vZHVsZShzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcblxuICAgICAgbGV0IG5leHQgPSBnZW5lcmF0b3IubmV4dCgpXG5cbiAgICAgIHdoaWxlIChuZXh0LmRvbmUgIT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXh0LnZhbHVlXG5cbiAgICAgICAgaWYgKHZhbHVlLnBhY2thZ2UpIHtcbiAgICAgICAgICBuZXh0ID0gZ2VuZXJhdG9yLm5leHQocmVhZFBhY2thZ2UodmFsdWUucGFja2FnZSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IGdlbmVyYXRvci5uZXh0KHlpZWxkIHZhbHVlLnJlc29sdXRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQudmFsdWVcbiAgICB9LFxuXG4gICAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICBjb25zdCBnZW5lcmF0b3IgPSBleHBvcnRzLm1vZHVsZShzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcblxuICAgICAgbGV0IG5leHQgPSBnZW5lcmF0b3IubmV4dCgpXG5cbiAgICAgIHdoaWxlIChuZXh0LmRvbmUgIT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXh0LnZhbHVlXG5cbiAgICAgICAgaWYgKHZhbHVlLnBhY2thZ2UpIHtcbiAgICAgICAgICBuZXh0ID0gZ2VuZXJhdG9yLm5leHQoYXdhaXQgcmVhZFBhY2thZ2UodmFsdWUucGFja2FnZSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IGdlbmVyYXRvci5uZXh0KHlpZWxkIHZhbHVlLnJlc29sdXRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJlYWRQYWNrYWdlKCkge1xuICByZXR1cm4gbnVsbFxufVxuXG4vLyBObyByZXNvbHV0aW9uIGNhbmRpZGF0ZSB3YXMgeWllbGRlZFxuY29uc3QgVU5SRVNPTFZFRCA9IDB4MFxuLy8gQXQgbGVhc3QgMSByZXNvbHV0aW9uIGNhbmRpZGF0ZSB3YXMgeWllbGRlZFxuY29uc3QgWUlFTERFRCA9IDB4MVxuLy8gQXQgbGVhc3QgMSByZXNvbHV0aW9uIGNhbmRpZGF0ZSB3YXMgeWllbGRlZCBhbmQgcmVzb2x2ZWRcbmNvbnN0IFJFU09MVkVEID0gWUlFTERFRCB8IDB4MlxuXG5leHBvcnRzLmNvbnN0YW50cyA9IHtcbiAgVU5SRVNPTFZFRCxcbiAgWUlFTERFRCxcbiAgUkVTT0xWRURcbn1cblxuZXhwb3J0cy5tb2R1bGUgPSBmdW5jdGlvbiogKHNwZWNpZmllciwgcGFyZW50VVJMLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyByZXNvbHV0aW9ucyA9IG51bGwsIGltcG9ydHMgPSBudWxsIH0gPSBvcHRzXG5cbiAgaWYgKGV4cG9ydHMuc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihzcGVjaWZpZXIpKSB7XG4gICAgc3BlY2lmaWVyID0gJy8nICsgc3BlY2lmaWVyXG4gIH1cblxuICBsZXQgc3RhdHVzXG5cbiAgaWYgKHJlc29sdXRpb25zKSB7XG4gICAgc3RhdHVzID0geWllbGQqIGV4cG9ydHMucHJlcmVzb2x2ZWQoc3BlY2lmaWVyLCByZXNvbHV0aW9ucywgcGFyZW50VVJMLCBvcHRzKVxuXG4gICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICB9XG5cbiAgc3RhdHVzID0geWllbGQqIGV4cG9ydHMudXJsKHNwZWNpZmllciwgcGFyZW50VVJMLCBvcHRzKVxuXG4gIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcblxuICBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlSW1wb3J0cyhzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcblxuICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG5cbiAgaWYgKFxuICAgIHNwZWNpZmllciA9PT0gJy4nIHx8XG4gICAgc3BlY2lmaWVyID09PSAnLi4nIHx8XG4gICAgc3BlY2lmaWVyWzBdID09PSAnLycgfHxcbiAgICBzcGVjaWZpZXJbMF0gPT09ICdcXFxcJyB8fFxuICAgIHNwZWNpZmllci5zdGFydHNXaXRoKCcuLycpIHx8XG4gICAgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy5cXFxcJykgfHxcbiAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi4vJykgfHxcbiAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi5cXFxcJylcbiAgKSB7XG4gICAgaWYgKGltcG9ydHMpIHtcbiAgICAgIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnBhY2thZ2VJbXBvcnRzRXhwb3J0cyhcbiAgICAgICAgc3BlY2lmaWVyLFxuICAgICAgICBpbXBvcnRzLFxuICAgICAgICBwYXJlbnRVUkwsXG4gICAgICAgIHRydWUsXG4gICAgICAgIG9wdHNcbiAgICAgIClcblxuICAgICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLmRlZmVycmVkKHNwZWNpZmllciwgb3B0cylcblxuICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcblxuICAgIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLmZpbGUoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIGZhbHNlLCBvcHRzKVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gUkVTT0xWRUQpIHJldHVybiBzdGF0dXNcblxuICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5kaXJlY3Rvcnkoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG4gIH1cblxuICByZXR1cm4geWllbGQqIGV4cG9ydHMucGFja2FnZShzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcbn1cblxuZXhwb3J0cy51cmwgPSBmdW5jdGlvbiogKHVybCwgcGFyZW50VVJMLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBpbXBvcnRzID0gbnVsbCwgZGVmZXJyZWRQcm90b2NvbCA9ICdkZWZlcnJlZDonIH0gPSBvcHRzXG5cbiAgbGV0IHJlc29sdXRpb25cbiAgdHJ5IHtcbiAgICByZXNvbHV0aW9uID0gbmV3IFVSTCh1cmwpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBVTlJFU09MVkVEXG4gIH1cblxuICBpZiAoaW1wb3J0cykge1xuICAgIGNvbnN0IHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnBhY2thZ2VJbXBvcnRzRXhwb3J0cyhcbiAgICAgIHJlc29sdXRpb24uaHJlZixcbiAgICAgIGltcG9ydHMsXG4gICAgICBwYXJlbnRVUkwsXG4gICAgICB0cnVlLFxuICAgICAgb3B0c1xuICAgIClcblxuICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgfVxuXG4gIGlmIChyZXNvbHV0aW9uLnByb3RvY29sID09PSBkZWZlcnJlZFByb3RvY29sKSB7XG4gICAgY29uc3Qgc3BlY2lmaWVyID0gcmVzb2x1dGlvbi5wYXRobmFtZVxuXG4gICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLm1vZHVsZShzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcbiAgfVxuXG4gIGlmIChyZXNvbHV0aW9uLnByb3RvY29sID09PSAnbm9kZTonKSB7XG4gICAgY29uc3Qgc3BlY2lmaWVyID0gcmVzb2x1dGlvbi5wYXRobmFtZVxuXG4gICAgaWYgKFxuICAgICAgc3BlY2lmaWVyID09PSAnLicgfHxcbiAgICAgIHNwZWNpZmllciA9PT0gJy4uJyB8fFxuICAgICAgc3BlY2lmaWVyWzBdID09PSAnLycgfHxcbiAgICAgIHNwZWNpZmllci5zdGFydHNXaXRoKCcuLycpIHx8XG4gICAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi4vJylcbiAgICApIHtcbiAgICAgIHRocm93IGVycm9ycy5JTlZBTElEX01PRFVMRV9TUEVDSUZJRVIoXG4gICAgICAgIGBNb2R1bGUgc3BlY2lmaWVyICcke3VybH0nIGlzIG5vdCBhIHZhbGlkIHBhY2thZ2UgbmFtZWBcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4geWllbGQqIGV4cG9ydHMucGFja2FnZShzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkID0geWllbGQgeyByZXNvbHV0aW9uIH1cblxuICByZXR1cm4gcmVzb2x2ZWQgPyBSRVNPTFZFRCA6IFlJRUxERURcbn1cblxuZXhwb3J0cy5wcmVyZXNvbHZlZCA9IGZ1bmN0aW9uKiAoc3BlY2lmaWVyLCByZXNvbHV0aW9ucywgcGFyZW50VVJMLCBvcHRzID0ge30pIHtcbiAgY29uc3QgaW1wb3J0cyA9IHJlc29sdXRpb25zW3BhcmVudFVSTC5ocmVmXVxuXG4gIGlmICh0eXBlb2YgaW1wb3J0cyA9PT0gJ29iamVjdCcgJiYgaW1wb3J0cyAhPT0gbnVsbCkge1xuICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5wYWNrYWdlSW1wb3J0c0V4cG9ydHMoXG4gICAgICBzcGVjaWZpZXIsXG4gICAgICBpbXBvcnRzLFxuICAgICAgcGFyZW50VVJMLFxuICAgICAgdHJ1ZSxcbiAgICAgIG9wdHNcbiAgICApXG4gIH1cblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLmRlZmVycmVkID0gZnVuY3Rpb24qIChzcGVjaWZpZXIsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGRlZmVycmVkUHJvdG9jb2wgPSAnZGVmZXJyZWQ6JywgZGVmZXIgPSBbXSB9ID0gb3B0c1xuXG4gIGlmIChkZWZlci5pbmNsdWRlcyhzcGVjaWZpZXIpKSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB5aWVsZCB7IHJlc29sdXRpb246IG5ldyBVUkwoZGVmZXJyZWRQcm90b2NvbCArIHNwZWNpZmllcikgfVxuXG4gICAgcmV0dXJuIHJlc29sdmVkID8gUkVTT0xWRUQgOiBZSUVMREVEXG4gIH1cblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLnBhY2thZ2UgPSBmdW5jdGlvbiogKHBhY2thZ2VTcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgYnVpbHRpbnMgPSBbXSB9ID0gb3B0c1xuXG4gIGlmIChwYWNrYWdlU3BlY2lmaWVyID09PSAnJykge1xuICAgIHRocm93IGVycm9ycy5JTlZBTElEX01PRFVMRV9TUEVDSUZJRVIoXG4gICAgICBgTW9kdWxlIHNwZWNpZmllciAnJHtwYWNrYWdlU3BlY2lmaWVyfScgaXMgbm90IGEgdmFsaWQgcGFja2FnZSBuYW1lYFxuICAgIClcbiAgfVxuXG4gIGxldCBwYWNrYWdlTmFtZVxuXG4gIGlmIChwYWNrYWdlU3BlY2lmaWVyWzBdICE9PSAnQCcpIHtcbiAgICBwYWNrYWdlTmFtZSA9IHBhY2thZ2VTcGVjaWZpZXIuc3BsaXQoJy8nLCAxKS5qb2luKClcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXBhY2thZ2VTcGVjaWZpZXIuaW5jbHVkZXMoJy8nKSkge1xuICAgICAgdGhyb3cgZXJyb3JzLklOVkFMSURfTU9EVUxFX1NQRUNJRklFUihcbiAgICAgICAgYE1vZHVsZSBzcGVjaWZpZXIgJyR7cGFja2FnZVNwZWNpZmllcn0nIGlzIG5vdCBhIHZhbGlkIHBhY2thZ2UgbmFtZWBcbiAgICAgIClcbiAgICB9XG5cbiAgICBwYWNrYWdlTmFtZSA9IHBhY2thZ2VTcGVjaWZpZXIuc3BsaXQoJy8nLCAyKS5qb2luKCcvJylcbiAgfVxuXG4gIGlmIChcbiAgICBwYWNrYWdlTmFtZVswXSA9PT0gJy4nIHx8XG4gICAgcGFja2FnZU5hbWUuaW5jbHVkZXMoJ1xcXFwnKSB8fFxuICAgIHBhY2thZ2VOYW1lLmluY2x1ZGVzKCclJylcbiAgKSB7XG4gICAgdGhyb3cgZXJyb3JzLklOVkFMSURfTU9EVUxFX1NQRUNJRklFUihcbiAgICAgIGBNb2R1bGUgc3BlY2lmaWVyICcke3BhY2thZ2VTcGVjaWZpZXJ9JyBpcyBub3QgYSB2YWxpZCBwYWNrYWdlIG5hbWVgXG4gICAgKVxuICB9XG5cbiAgbGV0IHN0YXR1c1xuXG4gIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLmJ1aWx0aW5UYXJnZXQocGFja2FnZVNwZWNpZmllciwgbnVsbCwgYnVpbHRpbnMsIG9wdHMpXG5cbiAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuXG4gIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLmRlZmVycmVkKHBhY2thZ2VTcGVjaWZpZXIsIG9wdHMpXG5cbiAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuXG4gIGxldCBwYWNrYWdlU3VicGF0aCA9ICcuJyArIHBhY2thZ2VTcGVjaWZpZXIuc3Vic3RyaW5nKHBhY2thZ2VOYW1lLmxlbmd0aClcblxuICBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlU2VsZihcbiAgICBwYWNrYWdlTmFtZSxcbiAgICBwYWNrYWdlU3VicGF0aCxcbiAgICBwYXJlbnRVUkwsXG4gICAgb3B0c1xuICApXG5cbiAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuXG4gIHBhcmVudFVSTCA9IG5ldyBVUkwocGFyZW50VVJMLmhyZWYpXG5cbiAgZG8ge1xuICAgIGNvbnN0IHBhY2thZ2VVUkwgPSBuZXcgVVJMKCdub2RlX21vZHVsZXMvJyArIHBhY2thZ2VOYW1lICsgJy8nLCBwYXJlbnRVUkwpXG5cbiAgICBwYXJlbnRVUkwucGF0aG5hbWUgPSBwYXJlbnRVUkwucGF0aG5hbWUuc3Vic3RyaW5nKFxuICAgICAgMCxcbiAgICAgIHBhcmVudFVSTC5wYXRobmFtZS5sYXN0SW5kZXhPZignLycpXG4gICAgKVxuXG4gICAgY29uc3QgaW5mbyA9IHlpZWxkIHsgcGFja2FnZTogbmV3IFVSTCgncGFja2FnZS5qc29uJywgcGFja2FnZVVSTCkgfVxuXG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGlmIChpbmZvLmVuZ2luZXMpIGV4cG9ydHMudmFsaWRhdGVFbmdpbmVzKHBhY2thZ2VVUkwsIGluZm8uZW5naW5lcywgb3B0cylcblxuICAgICAgaWYgKGluZm8uZXhwb3J0cykge1xuICAgICAgICByZXR1cm4geWllbGQqIGV4cG9ydHMucGFja2FnZUV4cG9ydHMoXG4gICAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgICBwYWNrYWdlU3VicGF0aCxcbiAgICAgICAgICBpbmZvLmV4cG9ydHMsXG4gICAgICAgICAgb3B0c1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChwYWNrYWdlU3VicGF0aCA9PT0gJy4nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5mby5tYWluID09PSAnc3RyaW5nJyAmJiBpbmZvLm1haW4gIT09ICcnKSB7XG4gICAgICAgICAgcGFja2FnZVN1YnBhdGggPSBpbmZvLm1haW5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geWllbGQqIGV4cG9ydHMuZmlsZSgnaW5kZXgnLCBwYWNrYWdlVVJMLCB0cnVlLCBvcHRzKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLmZpbGUocGFja2FnZVN1YnBhdGgsIHBhY2thZ2VVUkwsIGZhbHNlLCBvcHRzKVxuXG4gICAgICBpZiAoc3RhdHVzID09PSBSRVNPTFZFRCkgcmV0dXJuIHN0YXR1c1xuXG4gICAgICByZXR1cm4geWllbGQqIGV4cG9ydHMuZGlyZWN0b3J5KHBhY2thZ2VTdWJwYXRoLCBwYWNrYWdlVVJMLCBvcHRzKVxuICAgIH1cbiAgfSB3aGlsZSAocGFyZW50VVJMLnBhdGhuYW1lICE9PSAnJyAmJiBwYXJlbnRVUkwucGF0aG5hbWUgIT09ICcvJylcblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLnBhY2thZ2VTZWxmID0gZnVuY3Rpb24qIChcbiAgcGFja2FnZU5hbWUsXG4gIHBhY2thZ2VTdWJwYXRoLFxuICBwYXJlbnRVUkwsXG4gIG9wdHMgPSB7fVxuKSB7XG4gIGZvciAoY29uc3QgcGFja2FnZVVSTCBvZiBleHBvcnRzLmxvb2t1cFBhY2thZ2VTY29wZShwYXJlbnRVUkwsIG9wdHMpKSB7XG4gICAgY29uc3QgaW5mbyA9IHlpZWxkIHsgcGFja2FnZTogcGFja2FnZVVSTCB9XG5cbiAgICBpZiAoaW5mbykge1xuICAgICAgaWYgKGluZm8ubmFtZSAhPT0gcGFja2FnZU5hbWUpIHJldHVybiBmYWxzZVxuXG4gICAgICBpZiAoaW5mby5leHBvcnRzKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5wYWNrYWdlRXhwb3J0cyhcbiAgICAgICAgICBwYWNrYWdlVVJMLFxuICAgICAgICAgIHBhY2thZ2VTdWJwYXRoLFxuICAgICAgICAgIGluZm8uZXhwb3J0cyxcbiAgICAgICAgICBvcHRzXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKHBhY2thZ2VTdWJwYXRoID09PSAnLicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmZvLm1haW4gPT09ICdzdHJpbmcnICYmIGluZm8ubWFpbiAhPT0gJycpIHtcbiAgICAgICAgICBwYWNrYWdlU3VicGF0aCA9IGluZm8ubWFpblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5maWxlKCdpbmRleCcsIHBhY2thZ2VVUkwsIHRydWUsIG9wdHMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhdHVzID0geWllbGQqIGV4cG9ydHMuZmlsZShcbiAgICAgICAgcGFja2FnZVN1YnBhdGgsXG4gICAgICAgIHBhY2thZ2VVUkwsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBvcHRzXG4gICAgICApXG5cbiAgICAgIGlmIChzdGF0dXMgPT09IFJFU09MVkVEKSByZXR1cm4gc3RhdHVzXG5cbiAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5kaXJlY3RvcnkocGFja2FnZVN1YnBhdGgsIHBhY2thZ2VVUkwsIG9wdHMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOUkVTT0xWRURcbn1cblxuZXhwb3J0cy5wYWNrYWdlRXhwb3J0cyA9IGZ1bmN0aW9uKiAoXG4gIHBhY2thZ2VVUkwsXG4gIHN1YnBhdGgsXG4gIHBhY2thZ2VFeHBvcnRzLFxuICBvcHRzID0ge31cbikge1xuICBpZiAoc3VicGF0aCA9PT0gJy4nKSB7XG4gICAgbGV0IG1haW5FeHBvcnRcblxuICAgIGlmICh0eXBlb2YgcGFja2FnZUV4cG9ydHMgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkocGFja2FnZUV4cG9ydHMpKSB7XG4gICAgICBtYWluRXhwb3J0ID0gcGFja2FnZUV4cG9ydHNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYWNrYWdlRXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgcGFja2FnZUV4cG9ydHMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYWNrYWdlRXhwb3J0cylcblxuICAgICAgaWYgKGtleXMuc29tZSgoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aCgnLicpKSkge1xuICAgICAgICBpZiAoJy4nIGluIHBhY2thZ2VFeHBvcnRzKSBtYWluRXhwb3J0ID0gcGFja2FnZUV4cG9ydHNbJy4nXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFpbkV4cG9ydCA9IHBhY2thZ2VFeHBvcnRzXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1haW5FeHBvcnQpIHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnBhY2thZ2VUYXJnZXQoXG4gICAgICAgIHBhY2thZ2VVUkwsXG4gICAgICAgIG1haW5FeHBvcnQsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBvcHRzXG4gICAgICApXG5cbiAgICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhY2thZ2VFeHBvcnRzID09PSAnb2JqZWN0JyAmJiBwYWNrYWdlRXhwb3J0cyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYWNrYWdlRXhwb3J0cylcblxuICAgIGlmIChrZXlzLmV2ZXJ5KChrZXkpID0+IGtleS5zdGFydHNXaXRoKCcuJykpKSB7XG4gICAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlSW1wb3J0c0V4cG9ydHMoXG4gICAgICAgIHN1YnBhdGgsXG4gICAgICAgIHBhY2thZ2VFeHBvcnRzLFxuICAgICAgICBwYWNrYWdlVVJMLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgb3B0c1xuICAgICAgKVxuXG4gICAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG4gICAgfVxuICB9XG5cbiAgcGFja2FnZVVSTCA9IG5ldyBVUkwoJ3BhY2thZ2UuanNvbicsIHBhY2thZ2VVUkwpXG5cbiAgdGhyb3cgZXJyb3JzLlBBQ0tBR0VfUEFUSF9OT1RfRVhQT1JURUQoXG4gICAgYFBhY2thZ2Ugc3VicGF0aCAnJHtzdWJwYXRofScgaXMgbm90IGRlZmluZWQgYnkgXCJleHBvcnRzXCIgaW4gJyR7cGFja2FnZVVSTH0nYFxuICApXG59XG5cbmV4cG9ydHMucGFja2FnZUltcG9ydHMgPSBmdW5jdGlvbiogKHNwZWNpZmllciwgcGFyZW50VVJMLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBpbXBvcnRzID0gbnVsbCB9ID0gb3B0c1xuXG4gIGlmIChzcGVjaWZpZXIgPT09ICcjJyB8fCBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnIy8nKSkge1xuICAgIHRocm93IGVycm9ycy5JTlZBTElEX01PRFVMRV9TUEVDSUZJRVIoXG4gICAgICBgTW9kdWxlIHNwZWNpZmllciAnJHtzcGVjaWZpZXJ9JyBpcyBub3QgYSB2YWxpZCBpbnRlcm5hbCBpbXBvcnRzIHNwZWNpZmllcmBcbiAgICApXG4gIH1cblxuICBmb3IgKGNvbnN0IHBhY2thZ2VVUkwgb2YgZXhwb3J0cy5sb29rdXBQYWNrYWdlU2NvcGUocGFyZW50VVJMLCBvcHRzKSkge1xuICAgIGNvbnN0IGluZm8gPSB5aWVsZCB7IHBhY2thZ2U6IHBhY2thZ2VVUkwgfVxuXG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGlmIChpbmZvLmltcG9ydHMpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0geWllbGQqIGV4cG9ydHMucGFja2FnZUltcG9ydHNFeHBvcnRzKFxuICAgICAgICAgIHNwZWNpZmllcixcbiAgICAgICAgICBpbmZvLmltcG9ydHMsXG4gICAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIG9wdHNcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWNpZmllci5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JzLlBBQ0tBR0VfSU1QT1JUX05PVF9ERUZJTkVEKFxuICAgICAgICAgIGBQYWNrYWdlIGltcG9ydCBzcGVjaWZpZXIgJyR7c3BlY2lmaWVyfScgaXMgbm90IGRlZmluZWQgYnkgXCJpbXBvcnRzXCIgaW4gJyR7cGFja2FnZVVSTH0nYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKGltcG9ydHMpIHtcbiAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlSW1wb3J0c0V4cG9ydHMoXG4gICAgICBzcGVjaWZpZXIsXG4gICAgICBpbXBvcnRzLFxuICAgICAgcGFyZW50VVJMLFxuICAgICAgdHJ1ZSxcbiAgICAgIG9wdHNcbiAgICApXG5cbiAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG4gIH1cblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLnBhY2thZ2VJbXBvcnRzRXhwb3J0cyA9IGZ1bmN0aW9uKiAoXG4gIG1hdGNoS2V5LFxuICBtYXRjaE9iamVjdCxcbiAgcGFja2FnZVVSTCxcbiAgaXNJbXBvcnRzLFxuICBvcHRzID0ge31cbikge1xuICBpZiAobWF0Y2hLZXkgaW4gbWF0Y2hPYmplY3QgJiYgIW1hdGNoS2V5LmluY2x1ZGVzKCcqJykpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBtYXRjaE9iamVjdFttYXRjaEtleV1cblxuICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5wYWNrYWdlVGFyZ2V0KFxuICAgICAgcGFja2FnZVVSTCxcbiAgICAgIHRhcmdldCxcbiAgICAgIG51bGwsXG4gICAgICBpc0ltcG9ydHMsXG4gICAgICBvcHRzXG4gICAgKVxuICB9XG5cbiAgY29uc3QgZXhwYW5zaW9uS2V5cyA9IE9iamVjdC5rZXlzKG1hdGNoT2JqZWN0KVxuICAgIC5maWx0ZXIoKGtleSkgPT4ga2V5LmluY2x1ZGVzKCcqJykpXG4gICAgLnNvcnQoZXhwb3J0cy5wYXR0ZXJuS2V5Q29tcGFyZSlcblxuICBmb3IgKGNvbnN0IGV4cGFuc2lvbktleSBvZiBleHBhbnNpb25LZXlzKSB7XG4gICAgY29uc3QgcGF0dGVybkluZGV4ID0gZXhwYW5zaW9uS2V5LmluZGV4T2YoJyonKVxuICAgIGNvbnN0IHBhdHRlcm5CYXNlID0gZXhwYW5zaW9uS2V5LnN1YnN0cmluZygwLCBwYXR0ZXJuSW5kZXgpXG5cbiAgICBpZiAobWF0Y2hLZXkuc3RhcnRzV2l0aChwYXR0ZXJuQmFzZSkgJiYgbWF0Y2hLZXkgIT09IHBhdHRlcm5CYXNlKSB7XG4gICAgICBjb25zdCBwYXR0ZXJuVHJhaWxlciA9IGV4cGFuc2lvbktleS5zdWJzdHJpbmcocGF0dGVybkluZGV4ICsgMSlcblxuICAgICAgaWYgKFxuICAgICAgICBwYXR0ZXJuVHJhaWxlciA9PT0gJycgfHxcbiAgICAgICAgKG1hdGNoS2V5LmVuZHNXaXRoKHBhdHRlcm5UcmFpbGVyKSAmJlxuICAgICAgICAgIG1hdGNoS2V5Lmxlbmd0aCA+PSBleHBhbnNpb25LZXkubGVuZ3RoKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG1hdGNoT2JqZWN0W2V4cGFuc2lvbktleV1cblxuICAgICAgICBjb25zdCBwYXR0ZXJuTWF0Y2ggPSBtYXRjaEtleS5zdWJzdHJpbmcoXG4gICAgICAgICAgcGF0dGVybkJhc2UubGVuZ3RoLFxuICAgICAgICAgIG1hdGNoS2V5Lmxlbmd0aCAtIHBhdHRlcm5UcmFpbGVyLmxlbmd0aFxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLnBhY2thZ2VUYXJnZXQoXG4gICAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgcGF0dGVybk1hdGNoLFxuICAgICAgICAgIGlzSW1wb3J0cyxcbiAgICAgICAgICBvcHRzXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLnZhbGlkYXRlRW5naW5lcyA9IGZ1bmN0aW9uIHZhbGlkYXRlRW5naW5lcyhcbiAgcGFja2FnZVVSTCxcbiAgcGFja2FnZUVuZ2luZXMsXG4gIG9wdHMgPSB7fVxuKSB7XG4gIGNvbnN0IHsgZW5naW5lcyA9IHt9IH0gPSBvcHRzXG5cbiAgZm9yIChjb25zdCBbZW5naW5lLCByYW5nZV0gb2YgT2JqZWN0LmVudHJpZXMocGFja2FnZUVuZ2luZXMpKSB7XG4gICAgaWYgKGVuZ2luZSBpbiBlbmdpbmVzKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gZW5naW5lc1tlbmdpbmVdXG5cbiAgICAgIGlmICghc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlKSkge1xuICAgICAgICBwYWNrYWdlVVJMID0gbmV3IFVSTCgncGFja2FnZS5qc29uJywgcGFja2FnZVVSTClcblxuICAgICAgICB0aHJvdyBlcnJvcnMuVU5TVVBQT1JURURfRU5HSU5FKFxuICAgICAgICAgIGBQYWNrYWdlIG5vdCBjb21wYXRpYmxlIHdpdGggZW5naW5lICcke2VuZ2luZX0nICR7dmVyc2lvbn0sIHJlcXVpcmVzIHJhbmdlICcke3JhbmdlfScgZGVmaW5lZCBieSBcImVuZ2luZXNcIiBpbiAnJHtwYWNrYWdlVVJMfSdgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5wYXR0ZXJuS2V5Q29tcGFyZSA9IGZ1bmN0aW9uIHBhdHRlcm5LZXlDb21wYXJlKGtleUEsIGtleUIpIHtcbiAgY29uc3QgcGF0dGVybkluZGV4QSA9IGtleUEuaW5kZXhPZignKicpXG4gIGNvbnN0IHBhdHRlcm5JbmRleEIgPSBrZXlCLmluZGV4T2YoJyonKVxuICBjb25zdCBiYXNlTGVuZ3RoQSA9IHBhdHRlcm5JbmRleEEgPT09IC0xID8ga2V5QS5sZW5ndGggOiBwYXR0ZXJuSW5kZXhBICsgMVxuICBjb25zdCBiYXNlTGVuZ3RoQiA9IHBhdHRlcm5JbmRleEIgPT09IC0xID8ga2V5Qi5sZW5ndGggOiBwYXR0ZXJuSW5kZXhCICsgMVxuICBpZiAoYmFzZUxlbmd0aEEgPiBiYXNlTGVuZ3RoQikgcmV0dXJuIC0xXG4gIGlmIChiYXNlTGVuZ3RoQiA+IGJhc2VMZW5ndGhBKSByZXR1cm4gMVxuICBpZiAocGF0dGVybkluZGV4QSA9PT0gLTEpIHJldHVybiAxXG4gIGlmIChwYXR0ZXJuSW5kZXhCID09PSAtMSkgcmV0dXJuIC0xXG4gIGlmIChrZXlBLmxlbmd0aCA+IGtleUIubGVuZ3RoKSByZXR1cm4gLTFcbiAgaWYgKGtleUIubGVuZ3RoID4ga2V5QS5sZW5ndGgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbmV4cG9ydHMucGFja2FnZVRhcmdldCA9IGZ1bmN0aW9uKiAoXG4gIHBhY2thZ2VVUkwsXG4gIHRhcmdldCxcbiAgcGF0dGVybk1hdGNoLFxuICBpc0ltcG9ydHMsXG4gIG9wdHMgPSB7fVxuKSB7XG4gIGNvbnN0IHsgY29uZGl0aW9ucyA9IFtdLCBtYXRjaGVkQ29uZGl0aW9ucyA9IFtdIH0gPSBvcHRzXG5cbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF0YXJnZXQuc3RhcnRzV2l0aCgnLi8nKSAmJiAhaXNJbXBvcnRzKSB7XG4gICAgICBwYWNrYWdlVVJMID0gbmV3IFVSTCgncGFja2FnZS5qc29uJywgcGFja2FnZVVSTClcblxuICAgICAgdGhyb3cgZXJyb3JzLklOVkFMSURfUEFDS0FHRV9UQVJHRVQoXG4gICAgICAgIGBJbnZhbGlkIHRhcmdldCAnJHt0YXJnZXR9JyBkZWZpbmVkIGJ5IFwiZXhwb3J0c1wiIGluICcke3BhY2thZ2VVUkx9J2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAocGF0dGVybk1hdGNoICE9PSBudWxsKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucmVwbGFjZUFsbCgnKicsIHBhdHRlcm5NYXRjaClcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy51cmwodGFyZ2V0LCBwYWNrYWdlVVJMLCBvcHRzKVxuXG4gICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuXG4gICAgaWYgKFxuICAgICAgdGFyZ2V0ID09PSAnLicgfHxcbiAgICAgIHRhcmdldCA9PT0gJy4uJyB8fFxuICAgICAgdGFyZ2V0WzBdID09PSAnLycgfHxcbiAgICAgIHRhcmdldC5zdGFydHNXaXRoKCcuLycpIHx8XG4gICAgICB0YXJnZXQuc3RhcnRzV2l0aCgnLi4vJylcbiAgICApIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0geWllbGQgeyByZXNvbHV0aW9uOiBuZXcgVVJMKHRhcmdldCwgcGFja2FnZVVSTCkgfVxuXG4gICAgICByZXR1cm4gcmVzb2x2ZWQgPyBSRVNPTFZFRCA6IFlJRUxERURcbiAgICB9XG5cbiAgICByZXR1cm4geWllbGQqIGV4cG9ydHMucGFja2FnZSh0YXJnZXQsIHBhY2thZ2VVUkwsIG9wdHMpXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgZm9yIChjb25zdCB0YXJnZXRWYWx1ZSBvZiB0YXJnZXQpIHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnBhY2thZ2VUYXJnZXQoXG4gICAgICAgIHBhY2thZ2VVUkwsXG4gICAgICAgIHRhcmdldFZhbHVlLFxuICAgICAgICBwYXR0ZXJuTWF0Y2gsXG4gICAgICAgIGlzSW1wb3J0cyxcbiAgICAgICAgb3B0c1xuICAgICAgKVxuXG4gICAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmIHRhcmdldCAhPT0gbnVsbCkge1xuICAgIGxldCBzdGF0dXMgPSBVTlJFU09MVkVEXG5cbiAgICBmb3IgKGNvbnN0IFtjb25kaXRpb24sIHRhcmdldFZhbHVlLCBzdWJzZXRdIG9mIGV4cG9ydHMuY29uZGl0aW9uTWF0Y2hlcyhcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbmRpdGlvbnMsXG4gICAgICBvcHRzXG4gICAgKSkge1xuICAgICAgbWF0Y2hlZENvbmRpdGlvbnMucHVzaChjb25kaXRpb24pXG5cbiAgICAgIHN0YXR1cyB8PSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlVGFyZ2V0KFxuICAgICAgICBwYWNrYWdlVVJMLFxuICAgICAgICB0YXJnZXRWYWx1ZSxcbiAgICAgICAgcGF0dGVybk1hdGNoLFxuICAgICAgICBpc0ltcG9ydHMsXG4gICAgICAgIHsgLi4ub3B0cywgY29uZGl0aW9uczogc3Vic2V0IH1cbiAgICAgIClcblxuICAgICAgbWF0Y2hlZENvbmRpdGlvbnMucG9wKClcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG4gIH1cblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLmJ1aWx0aW5UYXJnZXQgPSBmdW5jdGlvbiogKFxuICBwYWNrYWdlU3BlY2lmaWVyLFxuICBwYWNrYWdlVmVyc2lvbixcbiAgdGFyZ2V0LFxuICBvcHRzID0ge31cbikge1xuICBjb25zdCB7XG4gICAgYnVpbHRpblByb3RvY29sID0gJ2J1aWx0aW46JyxcbiAgICBjb25kaXRpb25zID0gW10sXG4gICAgbWF0Y2hlZENvbmRpdGlvbnMgPSBbXVxuICB9ID0gb3B0c1xuXG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHRhcmdldFBhcnRzID0gdGFyZ2V0LnNwbGl0KCdAJylcblxuICAgIGxldCB0YXJnZXROYW1lXG4gICAgbGV0IHRhcmdldFZlcnNpb25cblxuICAgIGlmICh0YXJnZXRbMF0gIT09ICdAJykge1xuICAgICAgdGFyZ2V0TmFtZSA9IHRhcmdldFBhcnRzWzBdXG4gICAgICB0YXJnZXRWZXJzaW9uID0gdGFyZ2V0UGFydHNbMV0gfHwgbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXROYW1lID0gdGFyZ2V0UGFydHMuc2xpY2UoMCwgMikuam9pbignQCcpXG4gICAgICB0YXJnZXRWZXJzaW9uID0gdGFyZ2V0UGFydHNbMl0gfHwgbnVsbFxuICAgIH1cblxuICAgIGlmIChwYWNrYWdlU3BlY2lmaWVyID09PSB0YXJnZXROYW1lKSB7XG4gICAgICBpZiAocGFja2FnZVZlcnNpb24gPT09IG51bGwgJiYgdGFyZ2V0VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBuZXcgVVJMKGJ1aWx0aW5Qcm90b2NvbCArIHBhY2thZ2VTcGVjaWZpZXIpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x2ZWQgPyBSRVNPTFZFRCA6IFlJRUxERURcbiAgICAgIH1cblxuICAgICAgbGV0IHZlcnNpb24gPSBudWxsXG5cbiAgICAgIGlmIChwYWNrYWdlVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICB2ZXJzaW9uID0gdGFyZ2V0VmVyc2lvblxuICAgICAgfSBlbHNlIGlmICh0YXJnZXRWZXJzaW9uID09PSBudWxsIHx8IHBhY2thZ2VWZXJzaW9uID09PSB0YXJnZXRWZXJzaW9uKSB7XG4gICAgICAgIHZlcnNpb24gPSBwYWNrYWdlVmVyc2lvblxuICAgICAgfVxuXG4gICAgICBpZiAodmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBuZXcgVVJMKFxuICAgICAgICAgICAgYnVpbHRpblByb3RvY29sICsgcGFja2FnZVNwZWNpZmllciArICdAJyArIHZlcnNpb25cbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x2ZWQgPyBSRVNPTFZFRCA6IFlJRUxERURcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgZm9yIChjb25zdCB0YXJnZXRWYWx1ZSBvZiB0YXJnZXQpIHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLmJ1aWx0aW5UYXJnZXQoXG4gICAgICAgIHBhY2thZ2VTcGVjaWZpZXIsXG4gICAgICAgIHBhY2thZ2VWZXJzaW9uLFxuICAgICAgICB0YXJnZXRWYWx1ZSxcbiAgICAgICAgb3B0c1xuICAgICAgKVxuXG4gICAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmIHRhcmdldCAhPT0gbnVsbCkge1xuICAgIGxldCBzdGF0dXMgPSBVTlJFU09MVkVEXG5cbiAgICBmb3IgKGNvbnN0IFtjb25kaXRpb24sIHRhcmdldFZhbHVlLCBzdWJzZXRdIG9mIGV4cG9ydHMuY29uZGl0aW9uTWF0Y2hlcyhcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbmRpdGlvbnMsXG4gICAgICBvcHRzXG4gICAgKSkge1xuICAgICAgbWF0Y2hlZENvbmRpdGlvbnMucHVzaChjb25kaXRpb24pXG5cbiAgICAgIHN0YXR1cyB8PSB5aWVsZCogZXhwb3J0cy5idWlsdGluVGFyZ2V0KFxuICAgICAgICBwYWNrYWdlU3BlY2lmaWVyLFxuICAgICAgICBwYWNrYWdlVmVyc2lvbixcbiAgICAgICAgdGFyZ2V0VmFsdWUsXG4gICAgICAgIHsgLi4ub3B0cywgY29uZGl0aW9uczogc3Vic2V0IH1cbiAgICAgIClcblxuICAgICAgbWF0Y2hlZENvbmRpdGlvbnMucG9wKClcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG4gIH1cblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLmNvbmRpdGlvbk1hdGNoZXMgPSBmdW5jdGlvbiogY29uZGl0aW9uTWF0Y2hlcyhcbiAgdGFyZ2V0LFxuICBjb25kaXRpb25zLFxuICBvcHRzID0ge31cbikge1xuICBpZiAoY29uZGl0aW9ucy5ldmVyeSgoY29uZGl0aW9uKSA9PiB0eXBlb2YgY29uZGl0aW9uID09PSAnc3RyaW5nJykpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KVxuXG4gICAgZm9yIChjb25zdCBjb25kaXRpb24gb2Yga2V5cykge1xuICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gJ2RlZmF1bHQnIHx8IGNvbmRpdGlvbnMuaW5jbHVkZXMoY29uZGl0aW9uKSkge1xuICAgICAgICB5aWVsZCBbY29uZGl0aW9uLCB0YXJnZXRbY29uZGl0aW9uXSwgY29uZGl0aW9uc11cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgbGV0IHlpZWxkZWQgPSBmYWxzZVxuXG4gIGZvciAoY29uc3Qgc3Vic2V0IG9mIGNvbmRpdGlvbnMpIHtcbiAgICBpZiAoeWllbGQqIGNvbmRpdGlvbk1hdGNoZXModGFyZ2V0LCBzdWJzZXQsIG9wdHMpKSB7XG4gICAgICB5aWVsZGVkID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB5aWVsZGVkXG59XG5cbmV4cG9ydHMubG9va3VwUGFja2FnZVNjb3BlID0gZnVuY3Rpb24qIGxvb2t1cFBhY2thZ2VTY29wZSh1cmwsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IHJlc29sdXRpb25zID0gbnVsbCB9ID0gb3B0c1xuXG4gIGlmIChyZXNvbHV0aW9ucykge1xuICAgIGZvciAoY29uc3QgeyByZXNvbHV0aW9uIH0gb2YgZXhwb3J0cy5wcmVyZXNvbHZlZChcbiAgICAgICcjcGFja2FnZScsXG4gICAgICByZXNvbHV0aW9ucyxcbiAgICAgIHVybCxcbiAgICAgIG9wdHNcbiAgICApKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbikgcmV0dXJuIHlpZWxkIHJlc29sdXRpb25cbiAgICB9XG5cbiAgICAvLyBJbnRlcm5hbCBwcmVyZXNvbHV0aW9uIHBhdGgsIGRvIG5vdCBkZXBlbmQgb24gdGhpcyEgSXQgd2lsbCBiZSByZW1vdmVkIHdpdGhvdXRcbiAgICAvLyB3YXJuaW5nLlxuICAgIGZvciAoY29uc3QgeyByZXNvbHV0aW9uIH0gb2YgZXhwb3J0cy5wcmVyZXNvbHZlZChcbiAgICAgICdiYXJlOnBhY2thZ2UnLFxuICAgICAgcmVzb2x1dGlvbnMsXG4gICAgICB1cmwsXG4gICAgICBvcHRzXG4gICAgKSkge1xuICAgICAgaWYgKHJlc29sdXRpb24pIHJldHVybiB5aWVsZCByZXNvbHV0aW9uXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2NvcGVVUkwgPSBuZXcgVVJMKHVybC5ocmVmKVxuXG4gIGRvIHtcbiAgICBpZiAoc2NvcGVVUkwucGF0aG5hbWUuZW5kc1dpdGgoJy9ub2RlX21vZHVsZXMnKSkgYnJlYWtcblxuICAgIHlpZWxkIG5ldyBVUkwoJ3BhY2thZ2UuanNvbicsIHNjb3BlVVJMKVxuXG4gICAgc2NvcGVVUkwucGF0aG5hbWUgPSBzY29wZVVSTC5wYXRobmFtZS5zdWJzdHJpbmcoXG4gICAgICAwLFxuICAgICAgc2NvcGVVUkwucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKVxuICAgIClcblxuICAgIGlmIChcbiAgICAgIHNjb3BlVVJMLnBhdGhuYW1lLmxlbmd0aCA9PT0gMyAmJlxuICAgICAgZXhwb3J0cy5pc1dpbmRvd3NEcml2ZUxldHRlcihzY29wZVVSTC5wYXRobmFtZS5zdWJzdHJpbmcoMSkpXG4gICAgKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfSB3aGlsZSAoc2NvcGVVUkwucGF0aG5hbWUgIT09ICcnICYmIHNjb3BlVVJMLnBhdGhuYW1lICE9PSAnLycpXG59XG5cbmV4cG9ydHMuZmlsZSA9IGZ1bmN0aW9uKiAoZmlsZW5hbWUsIHBhcmVudFVSTCwgaXNJbmRleCwgb3B0cyA9IHt9KSB7XG4gIGlmIChcbiAgICBmaWxlbmFtZSA9PT0gJy4nIHx8XG4gICAgZmlsZW5hbWUgPT09ICcuLicgfHxcbiAgICBmaWxlbmFtZVtmaWxlbmFtZS5sZW5ndGggLSAxXSA9PT0gJy8nIHx8XG4gICAgZmlsZW5hbWVbZmlsZW5hbWUubGVuZ3RoIC0gMV0gPT09ICdcXFxcJ1xuICApIHtcbiAgICByZXR1cm4gVU5SRVNPTFZFRFxuICB9XG5cbiAgaWYgKHBhcmVudFVSTC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyAmJiAvJTJmfCU1Yy9pLnRlc3QoZmlsZW5hbWUpKSB7XG4gICAgdGhyb3cgZXJyb3JzLklOVkFMSURfTU9EVUxFX1NQRUNJRklFUihcbiAgICAgIGBNb2R1bGUgc3BlY2lmaWVyICcke2ZpbGVuYW1lfScgaXMgaW52YWxpZGBcbiAgICApXG4gIH1cblxuICBjb25zdCB7IGV4dGVuc2lvbnMgPSBbXSB9ID0gb3B0c1xuXG4gIGxldCBzdGF0dXMgPSBVTlJFU09MVkVEXG5cbiAgaWYgKCFpc0luZGV4KSB7XG4gICAgaWYgKHlpZWxkIHsgcmVzb2x1dGlvbjogbmV3IFVSTChmaWxlbmFtZSwgcGFyZW50VVJMKSB9KSB7XG4gICAgICByZXR1cm4gUkVTT0xWRURcbiAgICB9XG5cbiAgICBzdGF0dXMgPSBZSUVMREVEXG4gIH1cblxuICBmb3IgKGNvbnN0IGV4dCBvZiBleHRlbnNpb25zKSB7XG4gICAgaWYgKHlpZWxkIHsgcmVzb2x1dGlvbjogbmV3IFVSTChmaWxlbmFtZSArIGV4dCwgcGFyZW50VVJMKSB9KSB7XG4gICAgICByZXR1cm4gUkVTT0xWRURcbiAgICB9XG5cbiAgICBzdGF0dXMgPSBZSUVMREVEXG4gIH1cblxuICByZXR1cm4gc3RhdHVzXG59XG5cbmV4cG9ydHMuZGlyZWN0b3J5ID0gZnVuY3Rpb24qIChkaXJuYW1lLCBwYXJlbnRVUkwsIG9wdHMgPSB7fSkge1xuICBsZXQgZGlyZWN0b3J5VVJMXG5cbiAgaWYgKFxuICAgIGRpcm5hbWVbZGlybmFtZS5sZW5ndGggLSAxXSA9PT0gJy8nIHx8XG4gICAgZGlybmFtZVtkaXJuYW1lLmxlbmd0aCAtIDFdID09PSAnXFxcXCdcbiAgKSB7XG4gICAgZGlyZWN0b3J5VVJMID0gbmV3IFVSTChkaXJuYW1lLCBwYXJlbnRVUkwpXG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0b3J5VVJMID0gbmV3IFVSTChkaXJuYW1lICsgJy8nLCBwYXJlbnRVUkwpXG4gIH1cblxuICBjb25zdCBpbmZvID0geWllbGQgeyBwYWNrYWdlOiBuZXcgVVJMKCdwYWNrYWdlLmpzb24nLCBkaXJlY3RvcnlVUkwpIH1cblxuICBpZiAoaW5mbykge1xuICAgIGlmIChpbmZvLmV4cG9ydHMpIHtcbiAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5wYWNrYWdlRXhwb3J0cyhcbiAgICAgICAgZGlyZWN0b3J5VVJMLFxuICAgICAgICAnLicsXG4gICAgICAgIGluZm8uZXhwb3J0cyxcbiAgICAgICAgb3B0c1xuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5mby5tYWluID09PSAnc3RyaW5nJyAmJiBpbmZvLm1haW4gIT09ICcnKSB7XG4gICAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5maWxlKGluZm8ubWFpbiwgZGlyZWN0b3J5VVJMLCBmYWxzZSwgb3B0cylcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gUkVTT0xWRUQpIHJldHVybiBzdGF0dXNcblxuICAgICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLmRpcmVjdG9yeShpbmZvLm1haW4sIGRpcmVjdG9yeVVSTCwgb3B0cylcbiAgICB9XG4gIH1cblxuICByZXR1cm4geWllbGQqIGV4cG9ydHMuZmlsZSgnaW5kZXgnLCBkaXJlY3RvcnlVUkwsIHRydWUsIG9wdHMpXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS11cHBlci1hbHBoYVxuZnVuY3Rpb24gaXNBU0NJSVVwcGVyQWxwaGEoYykge1xuICByZXR1cm4gYyA+PSAweDQxICYmIGMgPD0gMHg1YVxufVxuXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktbG93ZXItYWxwaGFcbmZ1bmN0aW9uIGlzQVNDSUlMb3dlckFscGhhKGMpIHtcbiAgcmV0dXJuIGMgPj0gMHg2MSAmJiBjIDw9IDB4N2Fcbn1cblxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLWFscGhhXG5mdW5jdGlvbiBpc0FTQ0lJQWxwaGEoYykge1xuICByZXR1cm4gaXNBU0NJSVVwcGVyQWxwaGEoYykgfHwgaXNBU0NJSUxvd2VyQWxwaGEoYylcbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN3aW5kb3dzLWRyaXZlLWxldHRlclxuZXhwb3J0cy5pc1dpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIGlzV2luZG93c0RyaXZlTGV0dGVyKGlucHV0KSB7XG4gIHJldHVybiAoXG4gICAgaW5wdXQubGVuZ3RoID49IDIgJiZcbiAgICBpc0FTQ0lJQWxwaGEoaW5wdXQuY2hhckNvZGVBdCgwKSkgJiZcbiAgICAoaW5wdXQuY2hhckNvZGVBdCgxKSA9PT0gMHgzYSB8fCBpbnB1dC5jaGFyQ29kZUF0KDEpID09PSAweDdjKVxuICApXG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc3RhcnQtd2l0aC1hLXdpbmRvd3MtZHJpdmUtbGV0dGVyXG5leHBvcnRzLnN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIgPSBmdW5jdGlvbiBzdGFydHNXaXRoV2luZG93c0RyaXZlTGV0dGVyKFxuICBpbnB1dFxuKSB7XG4gIHJldHVybiAoXG4gICAgaW5wdXQubGVuZ3RoID49IDIgJiZcbiAgICBleHBvcnRzLmlzV2luZG93c0RyaXZlTGV0dGVyKGlucHV0KSAmJlxuICAgIChpbnB1dC5sZW5ndGggPT09IDIgfHxcbiAgICAgIGlucHV0LmNoYXJDb2RlQXQoMikgPT09IDB4MmYgfHxcbiAgICAgIGlucHV0LmNoYXJDb2RlQXQoMikgPT09IDB4NWMgfHxcbiAgICAgIGlucHV0LmNoYXJDb2RlQXQoMikgPT09IDB4M2YgfHxcbiAgICAgIGlucHV0LmNoYXJDb2RlQXQoMikgPT09IDB4MjMpXG4gIClcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-module-resolve/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bare-module-resolve/lib/errors.js":
/*!********************************************************!*\
  !*** ./node_modules/bare-module-resolve/lib/errors.js ***!
  \********************************************************/
/***/ ((module) => {

eval("module.exports = class ModuleResolveError extends Error {\n  constructor(msg, code, fn = ModuleResolveError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'ModuleResolveError'\n  }\n\n  static INVALID_MODULE_SPECIFIER(msg) {\n    return new ModuleResolveError(\n      msg,\n      'INVALID_MODULE_SPECIFIER',\n      ModuleResolveError.INVALID_MODULE_SPECIFIER\n    )\n  }\n\n  static INVALID_PACKAGE_TARGET(msg) {\n    return new ModuleResolveError(\n      msg,\n      'INVALID_PACKAGE_TARGET',\n      ModuleResolveError.INVALID_PACKAGE_TARGET\n    )\n  }\n\n  static PACKAGE_PATH_NOT_EXPORTED(msg) {\n    return new ModuleResolveError(\n      msg,\n      'PACKAGE_PATH_NOT_EXPORTED',\n      ModuleResolveError.PACKAGE_PATH_NOT_EXPORTED\n    )\n  }\n\n  static PACKAGE_IMPORT_NOT_DEFINED(msg) {\n    return new ModuleResolveError(\n      msg,\n      'PACKAGE_IMPORT_NOT_DEFINED',\n      ModuleResolveError.PACKAGE_IMPORT_NOT_DEFINED\n    )\n  }\n\n  static UNSUPPORTED_ENGINE(msg) {\n    return new ModuleResolveError(\n      msg,\n      'UNSUPPORTED_ENGINE',\n      ModuleResolveError.UNSUPPORTED_ENGINE\n    )\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1tb2R1bGUtcmVzb2x2ZS9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxhQUFhLEtBQUssSUFBSSxJQUFJO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVTVUFSSU9cXERvY3VtZW50c1xcR2l0aHViXFxHYWxheHlLSi13YWxsZXQtLS1IYWNrXFx3ZWJcXG5vZGVfbW9kdWxlc1xcYmFyZS1tb2R1bGUtcmVzb2x2ZVxcbGliXFxlcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBNb2R1bGVSZXNvbHZlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1zZywgY29kZSwgZm4gPSBNb2R1bGVSZXNvbHZlRXJyb3IpIHtcbiAgICBzdXBlcihgJHtjb2RlfTogJHttc2d9YClcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGZuKVxuICAgIH1cbiAgfVxuXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiAnTW9kdWxlUmVzb2x2ZUVycm9yJ1xuICB9XG5cbiAgc3RhdGljIElOVkFMSURfTU9EVUxFX1NQRUNJRklFUihtc2cpIHtcbiAgICByZXR1cm4gbmV3IE1vZHVsZVJlc29sdmVFcnJvcihcbiAgICAgIG1zZyxcbiAgICAgICdJTlZBTElEX01PRFVMRV9TUEVDSUZJRVInLFxuICAgICAgTW9kdWxlUmVzb2x2ZUVycm9yLklOVkFMSURfTU9EVUxFX1NQRUNJRklFUlxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBJTlZBTElEX1BBQ0tBR0VfVEFSR0VUKG1zZykge1xuICAgIHJldHVybiBuZXcgTW9kdWxlUmVzb2x2ZUVycm9yKFxuICAgICAgbXNnLFxuICAgICAgJ0lOVkFMSURfUEFDS0FHRV9UQVJHRVQnLFxuICAgICAgTW9kdWxlUmVzb2x2ZUVycm9yLklOVkFMSURfUEFDS0FHRV9UQVJHRVRcbiAgICApXG4gIH1cblxuICBzdGF0aWMgUEFDS0FHRV9QQVRIX05PVF9FWFBPUlRFRChtc2cpIHtcbiAgICByZXR1cm4gbmV3IE1vZHVsZVJlc29sdmVFcnJvcihcbiAgICAgIG1zZyxcbiAgICAgICdQQUNLQUdFX1BBVEhfTk9UX0VYUE9SVEVEJyxcbiAgICAgIE1vZHVsZVJlc29sdmVFcnJvci5QQUNLQUdFX1BBVEhfTk9UX0VYUE9SVEVEXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIFBBQ0tBR0VfSU1QT1JUX05PVF9ERUZJTkVEKG1zZykge1xuICAgIHJldHVybiBuZXcgTW9kdWxlUmVzb2x2ZUVycm9yKFxuICAgICAgbXNnLFxuICAgICAgJ1BBQ0tBR0VfSU1QT1JUX05PVF9ERUZJTkVEJyxcbiAgICAgIE1vZHVsZVJlc29sdmVFcnJvci5QQUNLQUdFX0lNUE9SVF9OT1RfREVGSU5FRFxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBVTlNVUFBPUlRFRF9FTkdJTkUobXNnKSB7XG4gICAgcmV0dXJuIG5ldyBNb2R1bGVSZXNvbHZlRXJyb3IoXG4gICAgICBtc2csXG4gICAgICAnVU5TVVBQT1JURURfRU5HSU5FJyxcbiAgICAgIE1vZHVsZVJlc29sdmVFcnJvci5VTlNVUFBPUlRFRF9FTkdJTkVcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-module-resolve/lib/errors.js\n");

/***/ })

};
;