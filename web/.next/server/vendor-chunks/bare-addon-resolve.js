/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bare-addon-resolve";
exports.ids = ["vendor-chunks/bare-addon-resolve"];
exports.modules = {

/***/ "(ssr)/./node_modules/bare-addon-resolve/index.js":
/*!**************************************************!*\
  !*** ./node_modules/bare-addon-resolve/index.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const resolve = __webpack_require__(/*! bare-module-resolve */ \"(ssr)/./node_modules/bare-module-resolve/index.js\")\nconst { Version } = __webpack_require__(/*! bare-semver */ \"(ssr)/./node_modules/bare-semver/index.js\")\nconst errors = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/bare-addon-resolve/lib/errors.js\")\n\nmodule.exports = exports = function resolve(\n  specifier,\n  parentURL,\n  opts,\n  readPackage\n) {\n  if (typeof opts === 'function') {\n    readPackage = opts\n    opts = {}\n  } else if (typeof readPackage !== 'function') {\n    readPackage = defaultReadPackage\n  }\n\n  return {\n    *[Symbol.iterator]() {\n      const generator = exports.addon(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    },\n\n    async *[Symbol.asyncIterator]() {\n      const generator = exports.addon(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(await readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    }\n  }\n}\n\nfunction defaultReadPackage() {\n  return null\n}\n\nconst { UNRESOLVED, YIELDED, RESOLVED } = resolve.constants\n\nexports.constants = {\n  UNRESOLVED,\n  YIELDED,\n  RESOLVED\n}\n\nexports.addon = function* (specifier, parentURL, opts = {}) {\n  const { resolutions = null } = opts\n\n  if (exports.startsWithWindowsDriveLetter(specifier)) {\n    specifier = '/' + specifier\n  }\n\n  let status\n\n  if (resolutions) {\n    status = yield* resolve.preresolved(specifier, resolutions, parentURL, opts)\n\n    if (status) return status\n  }\n\n  status = yield* exports.url(specifier, parentURL, opts)\n\n  if (status) return status\n\n  let version = null\n\n  const i = specifier.lastIndexOf('@')\n\n  if (i > 0) {\n    version = specifier.substring(i + 1)\n\n    try {\n      Version.parse(version)\n\n      specifier = specifier.substring(0, i)\n    } catch {\n      version = null\n    }\n  }\n\n  if (\n    specifier === '.' ||\n    specifier === '..' ||\n    specifier[0] === '/' ||\n    specifier[0] === '\\\\' ||\n    specifier.startsWith('./') ||\n    specifier.startsWith('.\\\\') ||\n    specifier.startsWith('../') ||\n    specifier.startsWith('..\\\\')\n  ) {\n    return yield* exports.directory(specifier, version, parentURL, opts)\n  }\n\n  return yield* exports.package(specifier, version, parentURL, opts)\n}\n\nexports.url = function* (url, parentURL, opts = {}) {\n  let resolution\n  try {\n    resolution = new URL(url)\n  } catch {\n    return UNRESOLVED\n  }\n\n  const resolved = yield { resolution }\n\n  return resolved ? RESOLVED : YIELDED\n}\n\nexports[\"package\"] = function* (\n  packageSpecifier,\n  packageVersion,\n  parentURL,\n  opts = {}\n) {\n  if (packageSpecifier === '') {\n    throw errors.INVALID_ADDON_SPECIFIER(\n      `Addon specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  let packageName\n\n  if (packageSpecifier[0] !== '@') {\n    packageName = packageSpecifier.split('/', 1).join()\n  } else {\n    if (!packageSpecifier.includes('/')) {\n      throw errors.INVALID_ADDON_SPECIFIER(\n        `Addon specifier '${packageSpecifier}' is not a valid package name`\n      )\n    }\n\n    packageName = packageSpecifier.split('/', 2).join('/')\n  }\n\n  if (\n    packageName[0] === '.' ||\n    packageName.includes('\\\\') ||\n    packageName.includes('%')\n  ) {\n    throw errors.INVALID_ADDON_SPECIFIER(\n      `Addon specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  const packageSubpath = '.' + packageSpecifier.substring(packageName.length)\n\n  const status = yield* exports.packageSelf(\n    packageName,\n    packageSubpath,\n    packageVersion,\n    parentURL,\n    opts\n  )\n\n  if (status) return status\n\n  parentURL = new URL(parentURL.href)\n\n  do {\n    const packageURL = new URL('node_modules/' + packageName + '/', parentURL)\n\n    parentURL.pathname = parentURL.pathname.substring(\n      0,\n      parentURL.pathname.lastIndexOf('/')\n    )\n\n    const info = yield { package: new URL('package.json', packageURL) }\n\n    if (info) {\n      return yield* exports.directory(\n        packageSubpath,\n        packageVersion,\n        packageURL,\n        opts\n      )\n    }\n  } while (parentURL.pathname !== '' && parentURL.pathname !== '/')\n\n  return UNRESOLVED\n}\n\nexports.packageSelf = function* (\n  packageName,\n  packageSubpath,\n  packageVersion,\n  parentURL,\n  opts = {}\n) {\n  for (const packageURL of resolve.lookupPackageScope(parentURL, opts)) {\n    const info = yield { package: packageURL }\n\n    if (info) {\n      if (info.name === packageName) {\n        return yield* exports.directory(\n          packageSubpath,\n          packageVersion,\n          packageURL,\n          opts\n        )\n      }\n\n      break\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.lookupPrebuildsScope = function* lookupPrebuildsScope(url, opts = {}) {\n  const { resolutions = null } = opts\n\n  if (resolutions) {\n    for (const { resolution } of resolve.preresolved(\n      '#prebuilds',\n      resolutions,\n      url,\n      opts\n    )) {\n      if (resolution) return yield resolution\n    }\n  }\n\n  const scopeURL = new URL(url.href)\n\n  do {\n    yield new URL('prebuilds/', scopeURL)\n\n    scopeURL.pathname = scopeURL.pathname.substring(\n      0,\n      scopeURL.pathname.lastIndexOf('/')\n    )\n\n    if (\n      scopeURL.pathname.length === 3 &&\n      exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))\n    ) {\n      break\n    }\n  } while (scopeURL.pathname !== '' && scopeURL.pathname !== '/')\n}\n\nexports.file = function* (filename, parentURL, opts = {}) {\n  if (parentURL.protocol === 'file:' && /%2f|%5c/i.test(filename)) {\n    throw errors.INVALID_ADDON_SPECIFIER(\n      `Addon specifier '${filename}' is invalid`\n    )\n  }\n\n  const { extensions = [] } = opts\n\n  let status = UNRESOLVED\n\n  for (const ext of extensions) {\n    if (yield { resolution: new URL(filename + ext, parentURL) }) {\n      return RESOLVED\n    }\n\n    status = YIELDED\n  }\n\n  return status\n}\n\nexports.directory = function* (dirname, version, parentURL, opts = {}) {\n  const {\n    resolutions = null,\n    host = null, // Shorthand for single host resolution\n    hosts = host !== null ? [host] : [],\n    builtins = [],\n    matchedConditions = []\n  } = opts\n\n  let directoryURL\n\n  if (\n    dirname[dirname.length - 1] === '/' ||\n    dirname[dirname.length - 1] === '\\\\'\n  ) {\n    directoryURL = new URL(dirname, parentURL)\n  } else {\n    directoryURL = new URL(dirname + '/', parentURL)\n  }\n\n  // Internal preresolution path, do not depend on this! It will be removed without\n  // warning.\n  if (resolutions) {\n    const status = yield* resolve.preresolved(\n      'bare:addon',\n      resolutions,\n      directoryURL,\n      opts\n    )\n\n    if (status) return status\n  }\n\n  const unversioned = version === null\n\n  let name = null\n\n  const info = yield { package: new URL('package.json', directoryURL) }\n\n  if (info) {\n    if (typeof info.name === 'string' && info.name !== '') {\n      if (info.name.includes('__')) {\n        throw errors.INVALID_PACKAGE_NAME(\n          `Package name '${info.name}' is invalid`\n        )\n      }\n\n      name = info.name.replace(/\\//g, '__').replace(/^@/, '')\n    } else {\n      return UNRESOLVED\n    }\n\n    if (typeof info.version === 'string' && info.version !== '') {\n      if (version !== null && info.version !== version) return UNRESOLVED\n\n      version = info.version\n    }\n  } else {\n    return UNRESOLVED\n  }\n\n  let status\n\n  status = yield* resolve.builtinTarget(name, version, builtins, opts)\n\n  if (status) return status\n\n  for (const prebuildsURL of exports.lookupPrebuildsScope(directoryURL, opts)) {\n    status = UNRESOLVED\n\n    for (const host of hosts) {\n      const conditions = host.split('-')\n\n      matchedConditions.push(...conditions)\n\n      if (version !== null) {\n        status |= yield* exports.file(\n          host + '/' + name + '@' + version,\n          prebuildsURL,\n          opts\n        )\n      }\n\n      if (unversioned) {\n        status |= yield* exports.file(host + '/' + name, prebuildsURL, opts)\n      }\n\n      for (const _ of conditions) matchedConditions.pop()\n    }\n\n    if (status === RESOLVED) return status\n  }\n\n  return yield* exports.linked(name, version, opts)\n}\n\nexports.linked = function* (name, version = null, opts = {}) {\n  const {\n    linked = true,\n    host = null, // Shorthand for single host resolution\n    hosts = host !== null ? [host] : [],\n    matchedConditions = []\n  } = opts\n\n  if (linked === false || hosts.length === 0) return UNRESOLVED\n\n  let status = UNRESOLVED\n\n  for (const host of hosts) {\n    const [platform = null] = host.split('-', 1)\n\n    if (platform === null) continue\n\n    matchedConditions.push(platform)\n\n    status |= yield* platformArtefact(name, version, platform, opts)\n\n    matchedConditions.pop()\n  }\n\n  return status\n}\n\nfunction* platformArtefact(name, version = null, platform, opts = {}) {\n  const { linkedProtocol = 'linked:' } = opts\n\n  if (platform === 'darwin' || platform === 'ios') {\n    if (version !== null) {\n      if (\n        yield {\n          resolution: new URL(\n            `${linkedProtocol}${name}.${version}.framework/${name}.${version}`\n          )\n        }\n      ) {\n        return RESOLVED\n      }\n\n      if (platform === 'darwin') {\n        if (\n          yield {\n            resolution: new URL(`${linkedProtocol}lib${name}.${version}.dylib`)\n          }\n        ) {\n          return RESOLVED\n        }\n      }\n    }\n\n    if (\n      yield {\n        resolution: new URL(`${linkedProtocol}${name}.framework/${name}`)\n      }\n    ) {\n      return RESOLVED\n    }\n\n    if (platform === 'darwin') {\n      if (\n        yield {\n          resolution: new URL(`${linkedProtocol}lib${name}.dylib`)\n        }\n      ) {\n        return RESOLVED\n      }\n    }\n\n    return YIELDED\n  }\n\n  if (platform === 'linux' || platform === 'android') {\n    if (version !== null) {\n      if (\n        yield {\n          resolution: new URL(`${linkedProtocol}lib${name}.${version}.so`)\n        }\n      ) {\n        return RESOLVED\n      }\n    }\n\n    if (\n      yield {\n        resolution: new URL(`${linkedProtocol}lib${name}.so`)\n      }\n    ) {\n      return RESOLVED\n    }\n\n    return YIELDED\n  }\n\n  if (platform === 'win32') {\n    if (version !== null) {\n      if (\n        yield {\n          resolution: new URL(`${linkedProtocol}${name}-${version}.dll`)\n        }\n      ) {\n        return RESOLVED\n      }\n    }\n\n    if (\n      yield {\n        resolution: new URL(`${linkedProtocol}${name}.dll`)\n      }\n    ) {\n      return RESOLVED\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.isWindowsDriveLetter = resolve.isWindowsDriveLetter\n\nexports.startsWithWindowsDriveLetter = resolve.startsWithWindowsDriveLetter\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1hZGRvbi1yZXNvbHZlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFxQjtBQUM3QyxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQywyRUFBYzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxnQ0FBZ0M7O0FBRXhDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDZDQUE2QztBQUMxRCxVQUFVLHFCQUFxQjs7QUFFL0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsdUNBQXVDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZSxFQUFFLEtBQUssR0FBRyxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixlQUFlLEVBQUUsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QixvQ0FBb0MiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVVNVQVJJT1xcRG9jdW1lbnRzXFxHaXRodWJcXEdhbGF4eUtKLXdhbGxldC0tLUhhY2tcXHdlYlxcbm9kZV9tb2R1bGVzXFxiYXJlLWFkZG9uLXJlc29sdmVcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJlc29sdmUgPSByZXF1aXJlKCdiYXJlLW1vZHVsZS1yZXNvbHZlJylcbmNvbnN0IHsgVmVyc2lvbiB9ID0gcmVxdWlyZSgnYmFyZS1zZW12ZXInKVxuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9saWIvZXJyb3JzJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gcmVzb2x2ZShcbiAgc3BlY2lmaWVyLFxuICBwYXJlbnRVUkwsXG4gIG9wdHMsXG4gIHJlYWRQYWNrYWdlXG4pIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVhZFBhY2thZ2UgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRQYWNrYWdlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVhZFBhY2thZ2UgPSBkZWZhdWx0UmVhZFBhY2thZ2VcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gZXhwb3J0cy5hZGRvbihzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcblxuICAgICAgbGV0IG5leHQgPSBnZW5lcmF0b3IubmV4dCgpXG5cbiAgICAgIHdoaWxlIChuZXh0LmRvbmUgIT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXh0LnZhbHVlXG5cbiAgICAgICAgaWYgKHZhbHVlLnBhY2thZ2UpIHtcbiAgICAgICAgICBuZXh0ID0gZ2VuZXJhdG9yLm5leHQocmVhZFBhY2thZ2UodmFsdWUucGFja2FnZSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IGdlbmVyYXRvci5uZXh0KHlpZWxkIHZhbHVlLnJlc29sdXRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQudmFsdWVcbiAgICB9LFxuXG4gICAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICBjb25zdCBnZW5lcmF0b3IgPSBleHBvcnRzLmFkZG9uKHNwZWNpZmllciwgcGFyZW50VVJMLCBvcHRzKVxuXG4gICAgICBsZXQgbmV4dCA9IGdlbmVyYXRvci5uZXh0KClcblxuICAgICAgd2hpbGUgKG5leHQuZG9uZSAhPT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5leHQudmFsdWVcblxuICAgICAgICBpZiAodmFsdWUucGFja2FnZSkge1xuICAgICAgICAgIG5leHQgPSBnZW5lcmF0b3IubmV4dChhd2FpdCByZWFkUGFja2FnZSh2YWx1ZS5wYWNrYWdlKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gZ2VuZXJhdG9yLm5leHQoeWllbGQgdmFsdWUucmVzb2x1dGlvbilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dC52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVhZFBhY2thZ2UoKSB7XG4gIHJldHVybiBudWxsXG59XG5cbmNvbnN0IHsgVU5SRVNPTFZFRCwgWUlFTERFRCwgUkVTT0xWRUQgfSA9IHJlc29sdmUuY29uc3RhbnRzXG5cbmV4cG9ydHMuY29uc3RhbnRzID0ge1xuICBVTlJFU09MVkVELFxuICBZSUVMREVELFxuICBSRVNPTFZFRFxufVxuXG5leHBvcnRzLmFkZG9uID0gZnVuY3Rpb24qIChzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgcmVzb2x1dGlvbnMgPSBudWxsIH0gPSBvcHRzXG5cbiAgaWYgKGV4cG9ydHMuc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihzcGVjaWZpZXIpKSB7XG4gICAgc3BlY2lmaWVyID0gJy8nICsgc3BlY2lmaWVyXG4gIH1cblxuICBsZXQgc3RhdHVzXG5cbiAgaWYgKHJlc29sdXRpb25zKSB7XG4gICAgc3RhdHVzID0geWllbGQqIHJlc29sdmUucHJlcmVzb2x2ZWQoc3BlY2lmaWVyLCByZXNvbHV0aW9ucywgcGFyZW50VVJMLCBvcHRzKVxuXG4gICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICB9XG5cbiAgc3RhdHVzID0geWllbGQqIGV4cG9ydHMudXJsKHNwZWNpZmllciwgcGFyZW50VVJMLCBvcHRzKVxuXG4gIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcblxuICBsZXQgdmVyc2lvbiA9IG51bGxcblxuICBjb25zdCBpID0gc3BlY2lmaWVyLmxhc3RJbmRleE9mKCdAJylcblxuICBpZiAoaSA+IDApIHtcbiAgICB2ZXJzaW9uID0gc3BlY2lmaWVyLnN1YnN0cmluZyhpICsgMSlcblxuICAgIHRyeSB7XG4gICAgICBWZXJzaW9uLnBhcnNlKHZlcnNpb24pXG5cbiAgICAgIHNwZWNpZmllciA9IHNwZWNpZmllci5zdWJzdHJpbmcoMCwgaSlcbiAgICB9IGNhdGNoIHtcbiAgICAgIHZlcnNpb24gPSBudWxsXG4gICAgfVxuICB9XG5cbiAgaWYgKFxuICAgIHNwZWNpZmllciA9PT0gJy4nIHx8XG4gICAgc3BlY2lmaWVyID09PSAnLi4nIHx8XG4gICAgc3BlY2lmaWVyWzBdID09PSAnLycgfHxcbiAgICBzcGVjaWZpZXJbMF0gPT09ICdcXFxcJyB8fFxuICAgIHNwZWNpZmllci5zdGFydHNXaXRoKCcuLycpIHx8XG4gICAgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy5cXFxcJykgfHxcbiAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi4vJykgfHxcbiAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi5cXFxcJylcbiAgKSB7XG4gICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLmRpcmVjdG9yeShzcGVjaWZpZXIsIHZlcnNpb24sIHBhcmVudFVSTCwgb3B0cylcbiAgfVxuXG4gIHJldHVybiB5aWVsZCogZXhwb3J0cy5wYWNrYWdlKHNwZWNpZmllciwgdmVyc2lvbiwgcGFyZW50VVJMLCBvcHRzKVxufVxuXG5leHBvcnRzLnVybCA9IGZ1bmN0aW9uKiAodXJsLCBwYXJlbnRVUkwsIG9wdHMgPSB7fSkge1xuICBsZXQgcmVzb2x1dGlvblxuICB0cnkge1xuICAgIHJlc29sdXRpb24gPSBuZXcgVVJMKHVybClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFVOUkVTT0xWRURcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkID0geWllbGQgeyByZXNvbHV0aW9uIH1cblxuICByZXR1cm4gcmVzb2x2ZWQgPyBSRVNPTFZFRCA6IFlJRUxERURcbn1cblxuZXhwb3J0cy5wYWNrYWdlID0gZnVuY3Rpb24qIChcbiAgcGFja2FnZVNwZWNpZmllcixcbiAgcGFja2FnZVZlcnNpb24sXG4gIHBhcmVudFVSTCxcbiAgb3B0cyA9IHt9XG4pIHtcbiAgaWYgKHBhY2thZ2VTcGVjaWZpZXIgPT09ICcnKSB7XG4gICAgdGhyb3cgZXJyb3JzLklOVkFMSURfQURET05fU1BFQ0lGSUVSKFxuICAgICAgYEFkZG9uIHNwZWNpZmllciAnJHtwYWNrYWdlU3BlY2lmaWVyfScgaXMgbm90IGEgdmFsaWQgcGFja2FnZSBuYW1lYFxuICAgIClcbiAgfVxuXG4gIGxldCBwYWNrYWdlTmFtZVxuXG4gIGlmIChwYWNrYWdlU3BlY2lmaWVyWzBdICE9PSAnQCcpIHtcbiAgICBwYWNrYWdlTmFtZSA9IHBhY2thZ2VTcGVjaWZpZXIuc3BsaXQoJy8nLCAxKS5qb2luKClcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXBhY2thZ2VTcGVjaWZpZXIuaW5jbHVkZXMoJy8nKSkge1xuICAgICAgdGhyb3cgZXJyb3JzLklOVkFMSURfQURET05fU1BFQ0lGSUVSKFxuICAgICAgICBgQWRkb24gc3BlY2lmaWVyICcke3BhY2thZ2VTcGVjaWZpZXJ9JyBpcyBub3QgYSB2YWxpZCBwYWNrYWdlIG5hbWVgXG4gICAgICApXG4gICAgfVxuXG4gICAgcGFja2FnZU5hbWUgPSBwYWNrYWdlU3BlY2lmaWVyLnNwbGl0KCcvJywgMikuam9pbignLycpXG4gIH1cblxuICBpZiAoXG4gICAgcGFja2FnZU5hbWVbMF0gPT09ICcuJyB8fFxuICAgIHBhY2thZ2VOYW1lLmluY2x1ZGVzKCdcXFxcJykgfHxcbiAgICBwYWNrYWdlTmFtZS5pbmNsdWRlcygnJScpXG4gICkge1xuICAgIHRocm93IGVycm9ycy5JTlZBTElEX0FERE9OX1NQRUNJRklFUihcbiAgICAgIGBBZGRvbiBzcGVjaWZpZXIgJyR7cGFja2FnZVNwZWNpZmllcn0nIGlzIG5vdCBhIHZhbGlkIHBhY2thZ2UgbmFtZWBcbiAgICApXG4gIH1cblxuICBjb25zdCBwYWNrYWdlU3VicGF0aCA9ICcuJyArIHBhY2thZ2VTcGVjaWZpZXIuc3Vic3RyaW5nKHBhY2thZ2VOYW1lLmxlbmd0aClcblxuICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlU2VsZihcbiAgICBwYWNrYWdlTmFtZSxcbiAgICBwYWNrYWdlU3VicGF0aCxcbiAgICBwYWNrYWdlVmVyc2lvbixcbiAgICBwYXJlbnRVUkwsXG4gICAgb3B0c1xuICApXG5cbiAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuXG4gIHBhcmVudFVSTCA9IG5ldyBVUkwocGFyZW50VVJMLmhyZWYpXG5cbiAgZG8ge1xuICAgIGNvbnN0IHBhY2thZ2VVUkwgPSBuZXcgVVJMKCdub2RlX21vZHVsZXMvJyArIHBhY2thZ2VOYW1lICsgJy8nLCBwYXJlbnRVUkwpXG5cbiAgICBwYXJlbnRVUkwucGF0aG5hbWUgPSBwYXJlbnRVUkwucGF0aG5hbWUuc3Vic3RyaW5nKFxuICAgICAgMCxcbiAgICAgIHBhcmVudFVSTC5wYXRobmFtZS5sYXN0SW5kZXhPZignLycpXG4gICAgKVxuXG4gICAgY29uc3QgaW5mbyA9IHlpZWxkIHsgcGFja2FnZTogbmV3IFVSTCgncGFja2FnZS5qc29uJywgcGFja2FnZVVSTCkgfVxuXG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5kaXJlY3RvcnkoXG4gICAgICAgIHBhY2thZ2VTdWJwYXRoLFxuICAgICAgICBwYWNrYWdlVmVyc2lvbixcbiAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgb3B0c1xuICAgICAgKVxuICAgIH1cbiAgfSB3aGlsZSAocGFyZW50VVJMLnBhdGhuYW1lICE9PSAnJyAmJiBwYXJlbnRVUkwucGF0aG5hbWUgIT09ICcvJylcblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLnBhY2thZ2VTZWxmID0gZnVuY3Rpb24qIChcbiAgcGFja2FnZU5hbWUsXG4gIHBhY2thZ2VTdWJwYXRoLFxuICBwYWNrYWdlVmVyc2lvbixcbiAgcGFyZW50VVJMLFxuICBvcHRzID0ge31cbikge1xuICBmb3IgKGNvbnN0IHBhY2thZ2VVUkwgb2YgcmVzb2x2ZS5sb29rdXBQYWNrYWdlU2NvcGUocGFyZW50VVJMLCBvcHRzKSkge1xuICAgIGNvbnN0IGluZm8gPSB5aWVsZCB7IHBhY2thZ2U6IHBhY2thZ2VVUkwgfVxuXG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGlmIChpbmZvLm5hbWUgPT09IHBhY2thZ2VOYW1lKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5kaXJlY3RvcnkoXG4gICAgICAgICAgcGFja2FnZVN1YnBhdGgsXG4gICAgICAgICAgcGFja2FnZVZlcnNpb24sXG4gICAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgICBvcHRzXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLmxvb2t1cFByZWJ1aWxkc1Njb3BlID0gZnVuY3Rpb24qIGxvb2t1cFByZWJ1aWxkc1Njb3BlKHVybCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgcmVzb2x1dGlvbnMgPSBudWxsIH0gPSBvcHRzXG5cbiAgaWYgKHJlc29sdXRpb25zKSB7XG4gICAgZm9yIChjb25zdCB7IHJlc29sdXRpb24gfSBvZiByZXNvbHZlLnByZXJlc29sdmVkKFxuICAgICAgJyNwcmVidWlsZHMnLFxuICAgICAgcmVzb2x1dGlvbnMsXG4gICAgICB1cmwsXG4gICAgICBvcHRzXG4gICAgKSkge1xuICAgICAgaWYgKHJlc29sdXRpb24pIHJldHVybiB5aWVsZCByZXNvbHV0aW9uXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2NvcGVVUkwgPSBuZXcgVVJMKHVybC5ocmVmKVxuXG4gIGRvIHtcbiAgICB5aWVsZCBuZXcgVVJMKCdwcmVidWlsZHMvJywgc2NvcGVVUkwpXG5cbiAgICBzY29wZVVSTC5wYXRobmFtZSA9IHNjb3BlVVJMLnBhdGhuYW1lLnN1YnN0cmluZyhcbiAgICAgIDAsXG4gICAgICBzY29wZVVSTC5wYXRobmFtZS5sYXN0SW5kZXhPZignLycpXG4gICAgKVxuXG4gICAgaWYgKFxuICAgICAgc2NvcGVVUkwucGF0aG5hbWUubGVuZ3RoID09PSAzICYmXG4gICAgICBleHBvcnRzLmlzV2luZG93c0RyaXZlTGV0dGVyKHNjb3BlVVJMLnBhdGhuYW1lLnN1YnN0cmluZygxKSlcbiAgICApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9IHdoaWxlIChzY29wZVVSTC5wYXRobmFtZSAhPT0gJycgJiYgc2NvcGVVUkwucGF0aG5hbWUgIT09ICcvJylcbn1cblxuZXhwb3J0cy5maWxlID0gZnVuY3Rpb24qIChmaWxlbmFtZSwgcGFyZW50VVJMLCBvcHRzID0ge30pIHtcbiAgaWYgKHBhcmVudFVSTC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyAmJiAvJTJmfCU1Yy9pLnRlc3QoZmlsZW5hbWUpKSB7XG4gICAgdGhyb3cgZXJyb3JzLklOVkFMSURfQURET05fU1BFQ0lGSUVSKFxuICAgICAgYEFkZG9uIHNwZWNpZmllciAnJHtmaWxlbmFtZX0nIGlzIGludmFsaWRgXG4gICAgKVxuICB9XG5cbiAgY29uc3QgeyBleHRlbnNpb25zID0gW10gfSA9IG9wdHNcblxuICBsZXQgc3RhdHVzID0gVU5SRVNPTFZFRFxuXG4gIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbnMpIHtcbiAgICBpZiAoeWllbGQgeyByZXNvbHV0aW9uOiBuZXcgVVJMKGZpbGVuYW1lICsgZXh0LCBwYXJlbnRVUkwpIH0pIHtcbiAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgIH1cblxuICAgIHN0YXR1cyA9IFlJRUxERURcbiAgfVxuXG4gIHJldHVybiBzdGF0dXNcbn1cblxuZXhwb3J0cy5kaXJlY3RvcnkgPSBmdW5jdGlvbiogKGRpcm5hbWUsIHZlcnNpb24sIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICByZXNvbHV0aW9ucyA9IG51bGwsXG4gICAgaG9zdCA9IG51bGwsIC8vIFNob3J0aGFuZCBmb3Igc2luZ2xlIGhvc3QgcmVzb2x1dGlvblxuICAgIGhvc3RzID0gaG9zdCAhPT0gbnVsbCA/IFtob3N0XSA6IFtdLFxuICAgIGJ1aWx0aW5zID0gW10sXG4gICAgbWF0Y2hlZENvbmRpdGlvbnMgPSBbXVxuICB9ID0gb3B0c1xuXG4gIGxldCBkaXJlY3RvcnlVUkxcblxuICBpZiAoXG4gICAgZGlybmFtZVtkaXJuYW1lLmxlbmd0aCAtIDFdID09PSAnLycgfHxcbiAgICBkaXJuYW1lW2Rpcm5hbWUubGVuZ3RoIC0gMV0gPT09ICdcXFxcJ1xuICApIHtcbiAgICBkaXJlY3RvcnlVUkwgPSBuZXcgVVJMKGRpcm5hbWUsIHBhcmVudFVSTClcbiAgfSBlbHNlIHtcbiAgICBkaXJlY3RvcnlVUkwgPSBuZXcgVVJMKGRpcm5hbWUgKyAnLycsIHBhcmVudFVSTClcbiAgfVxuXG4gIC8vIEludGVybmFsIHByZXJlc29sdXRpb24gcGF0aCwgZG8gbm90IGRlcGVuZCBvbiB0aGlzISBJdCB3aWxsIGJlIHJlbW92ZWQgd2l0aG91dFxuICAvLyB3YXJuaW5nLlxuICBpZiAocmVzb2x1dGlvbnMpIHtcbiAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogcmVzb2x2ZS5wcmVyZXNvbHZlZChcbiAgICAgICdiYXJlOmFkZG9uJyxcbiAgICAgIHJlc29sdXRpb25zLFxuICAgICAgZGlyZWN0b3J5VVJMLFxuICAgICAgb3B0c1xuICAgIClcblxuICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgfVxuXG4gIGNvbnN0IHVudmVyc2lvbmVkID0gdmVyc2lvbiA9PT0gbnVsbFxuXG4gIGxldCBuYW1lID0gbnVsbFxuXG4gIGNvbnN0IGluZm8gPSB5aWVsZCB7IHBhY2thZ2U6IG5ldyBVUkwoJ3BhY2thZ2UuanNvbicsIGRpcmVjdG9yeVVSTCkgfVxuXG4gIGlmIChpbmZvKSB7XG4gICAgaWYgKHR5cGVvZiBpbmZvLm5hbWUgPT09ICdzdHJpbmcnICYmIGluZm8ubmFtZSAhPT0gJycpIHtcbiAgICAgIGlmIChpbmZvLm5hbWUuaW5jbHVkZXMoJ19fJykpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JzLklOVkFMSURfUEFDS0FHRV9OQU1FKFxuICAgICAgICAgIGBQYWNrYWdlIG5hbWUgJyR7aW5mby5uYW1lfScgaXMgaW52YWxpZGBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBuYW1lID0gaW5mby5uYW1lLnJlcGxhY2UoL1xcLy9nLCAnX18nKS5yZXBsYWNlKC9eQC8sICcnKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gVU5SRVNPTFZFRFxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5mby52ZXJzaW9uID09PSAnc3RyaW5nJyAmJiBpbmZvLnZlcnNpb24gIT09ICcnKSB7XG4gICAgICBpZiAodmVyc2lvbiAhPT0gbnVsbCAmJiBpbmZvLnZlcnNpb24gIT09IHZlcnNpb24pIHJldHVybiBVTlJFU09MVkVEXG5cbiAgICAgIHZlcnNpb24gPSBpbmZvLnZlcnNpb25cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFVOUkVTT0xWRURcbiAgfVxuXG4gIGxldCBzdGF0dXNcblxuICBzdGF0dXMgPSB5aWVsZCogcmVzb2x2ZS5idWlsdGluVGFyZ2V0KG5hbWUsIHZlcnNpb24sIGJ1aWx0aW5zLCBvcHRzKVxuXG4gIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcblxuICBmb3IgKGNvbnN0IHByZWJ1aWxkc1VSTCBvZiBleHBvcnRzLmxvb2t1cFByZWJ1aWxkc1Njb3BlKGRpcmVjdG9yeVVSTCwgb3B0cykpIHtcbiAgICBzdGF0dXMgPSBVTlJFU09MVkVEXG5cbiAgICBmb3IgKGNvbnN0IGhvc3Qgb2YgaG9zdHMpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSBob3N0LnNwbGl0KCctJylcblxuICAgICAgbWF0Y2hlZENvbmRpdGlvbnMucHVzaCguLi5jb25kaXRpb25zKVxuXG4gICAgICBpZiAodmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBzdGF0dXMgfD0geWllbGQqIGV4cG9ydHMuZmlsZShcbiAgICAgICAgICBob3N0ICsgJy8nICsgbmFtZSArICdAJyArIHZlcnNpb24sXG4gICAgICAgICAgcHJlYnVpbGRzVVJMLFxuICAgICAgICAgIG9wdHNcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAodW52ZXJzaW9uZWQpIHtcbiAgICAgICAgc3RhdHVzIHw9IHlpZWxkKiBleHBvcnRzLmZpbGUoaG9zdCArICcvJyArIG5hbWUsIHByZWJ1aWxkc1VSTCwgb3B0cylcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBfIG9mIGNvbmRpdGlvbnMpIG1hdGNoZWRDb25kaXRpb25zLnBvcCgpXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gUkVTT0xWRUQpIHJldHVybiBzdGF0dXNcbiAgfVxuXG4gIHJldHVybiB5aWVsZCogZXhwb3J0cy5saW5rZWQobmFtZSwgdmVyc2lvbiwgb3B0cylcbn1cblxuZXhwb3J0cy5saW5rZWQgPSBmdW5jdGlvbiogKG5hbWUsIHZlcnNpb24gPSBudWxsLCBvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGxpbmtlZCA9IHRydWUsXG4gICAgaG9zdCA9IG51bGwsIC8vIFNob3J0aGFuZCBmb3Igc2luZ2xlIGhvc3QgcmVzb2x1dGlvblxuICAgIGhvc3RzID0gaG9zdCAhPT0gbnVsbCA/IFtob3N0XSA6IFtdLFxuICAgIG1hdGNoZWRDb25kaXRpb25zID0gW11cbiAgfSA9IG9wdHNcblxuICBpZiAobGlua2VkID09PSBmYWxzZSB8fCBob3N0cy5sZW5ndGggPT09IDApIHJldHVybiBVTlJFU09MVkVEXG5cbiAgbGV0IHN0YXR1cyA9IFVOUkVTT0xWRURcblxuICBmb3IgKGNvbnN0IGhvc3Qgb2YgaG9zdHMpIHtcbiAgICBjb25zdCBbcGxhdGZvcm0gPSBudWxsXSA9IGhvc3Quc3BsaXQoJy0nLCAxKVxuXG4gICAgaWYgKHBsYXRmb3JtID09PSBudWxsKSBjb250aW51ZVxuXG4gICAgbWF0Y2hlZENvbmRpdGlvbnMucHVzaChwbGF0Zm9ybSlcblxuICAgIHN0YXR1cyB8PSB5aWVsZCogcGxhdGZvcm1BcnRlZmFjdChuYW1lLCB2ZXJzaW9uLCBwbGF0Zm9ybSwgb3B0cylcblxuICAgIG1hdGNoZWRDb25kaXRpb25zLnBvcCgpXG4gIH1cblxuICByZXR1cm4gc3RhdHVzXG59XG5cbmZ1bmN0aW9uKiBwbGF0Zm9ybUFydGVmYWN0KG5hbWUsIHZlcnNpb24gPSBudWxsLCBwbGF0Zm9ybSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgbGlua2VkUHJvdG9jb2wgPSAnbGlua2VkOicgfSA9IG9wdHNcblxuICBpZiAocGxhdGZvcm0gPT09ICdkYXJ3aW4nIHx8IHBsYXRmb3JtID09PSAnaW9zJykge1xuICAgIGlmICh2ZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBuZXcgVVJMKFxuICAgICAgICAgICAgYCR7bGlua2VkUHJvdG9jb2x9JHtuYW1lfS4ke3ZlcnNpb259LmZyYW1ld29yay8ke25hbWV9LiR7dmVyc2lvbn1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIFJFU09MVkVEXG4gICAgICB9XG5cbiAgICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHJlc29sdXRpb246IG5ldyBVUkwoYCR7bGlua2VkUHJvdG9jb2x9bGliJHtuYW1lfS4ke3ZlcnNpb259LmR5bGliYClcbiAgICAgICAgICB9XG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgeWllbGQge1xuICAgICAgICByZXNvbHV0aW9uOiBuZXcgVVJMKGAke2xpbmtlZFByb3RvY29sfSR7bmFtZX0uZnJhbWV3b3JrLyR7bmFtZX1gKVxuICAgICAgfVxuICAgICkge1xuICAgICAgcmV0dXJuIFJFU09MVkVEXG4gICAgfVxuXG4gICAgaWYgKHBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgICAgaWYgKFxuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVSTChgJHtsaW5rZWRQcm90b2NvbH1saWIke25hbWV9LmR5bGliYClcbiAgICAgICAgfVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBZSUVMREVEXG4gIH1cblxuICBpZiAocGxhdGZvcm0gPT09ICdsaW51eCcgfHwgcGxhdGZvcm0gPT09ICdhbmRyb2lkJykge1xuICAgIGlmICh2ZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBuZXcgVVJMKGAke2xpbmtlZFByb3RvY29sfWxpYiR7bmFtZX0uJHt2ZXJzaW9ufS5zb2ApXG4gICAgICAgIH1cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gUkVTT0xWRURcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB5aWVsZCB7XG4gICAgICAgIHJlc29sdXRpb246IG5ldyBVUkwoYCR7bGlua2VkUHJvdG9jb2x9bGliJHtuYW1lfS5zb2ApXG4gICAgICB9XG4gICAgKSB7XG4gICAgICByZXR1cm4gUkVTT0xWRURcbiAgICB9XG5cbiAgICByZXR1cm4gWUlFTERFRFxuICB9XG5cbiAgaWYgKHBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgaWYgKHZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgIGlmIChcbiAgICAgICAgeWllbGQge1xuICAgICAgICAgIHJlc29sdXRpb246IG5ldyBVUkwoYCR7bGlua2VkUHJvdG9jb2x9JHtuYW1lfS0ke3ZlcnNpb259LmRsbGApXG4gICAgICAgIH1cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gUkVTT0xWRURcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB5aWVsZCB7XG4gICAgICAgIHJlc29sdXRpb246IG5ldyBVUkwoYCR7bGlua2VkUHJvdG9jb2x9JHtuYW1lfS5kbGxgKVxuICAgICAgfVxuICAgICkge1xuICAgICAgcmV0dXJuIFJFU09MVkVEXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOUkVTT0xWRURcbn1cblxuZXhwb3J0cy5pc1dpbmRvd3NEcml2ZUxldHRlciA9IHJlc29sdmUuaXNXaW5kb3dzRHJpdmVMZXR0ZXJcblxuZXhwb3J0cy5zdGFydHNXaXRoV2luZG93c0RyaXZlTGV0dGVyID0gcmVzb2x2ZS5zdGFydHNXaXRoV2luZG93c0RyaXZlTGV0dGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-addon-resolve/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bare-addon-resolve/lib/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/bare-addon-resolve/lib/errors.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("module.exports = class AddonResolveError extends Error {\n  constructor(msg, code, fn = AddonResolveError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'AddonResolveError'\n  }\n\n  static INVALID_ADDON_SPECIFIER(msg) {\n    return new AddonResolveError(\n      msg,\n      'INVALID_ADDON_SPECIFIER',\n      AddonResolveError.INVALID_ADDON_SPECIFIER\n    )\n  }\n\n  static INVALID_PACKAGE_NAME(msg) {\n    return new AddonResolveError(\n      msg,\n      'INVALID_PACKAGE_NAME',\n      AddonResolveError.INVALID_PACKAGE_NAME\n    )\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1hZGRvbi1yZXNvbHZlL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGFBQWEsS0FBSyxJQUFJLElBQUk7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVVNVQVJJT1xcRG9jdW1lbnRzXFxHaXRodWJcXEdhbGF4eUtKLXdhbGxldC0tLUhhY2tcXHdlYlxcbm9kZV9tb2R1bGVzXFxiYXJlLWFkZG9uLXJlc29sdmVcXGxpYlxcZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQWRkb25SZXNvbHZlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1zZywgY29kZSwgZm4gPSBBZGRvblJlc29sdmVFcnJvcikge1xuICAgIHN1cGVyKGAke2NvZGV9OiAke21zZ31gKVxuICAgIHRoaXMuY29kZSA9IGNvZGVcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgZm4pXG4gICAgfVxuICB9XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuICdBZGRvblJlc29sdmVFcnJvcidcbiAgfVxuXG4gIHN0YXRpYyBJTlZBTElEX0FERE9OX1NQRUNJRklFUihtc2cpIHtcbiAgICByZXR1cm4gbmV3IEFkZG9uUmVzb2x2ZUVycm9yKFxuICAgICAgbXNnLFxuICAgICAgJ0lOVkFMSURfQURET05fU1BFQ0lGSUVSJyxcbiAgICAgIEFkZG9uUmVzb2x2ZUVycm9yLklOVkFMSURfQURET05fU1BFQ0lGSUVSXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIElOVkFMSURfUEFDS0FHRV9OQU1FKG1zZykge1xuICAgIHJldHVybiBuZXcgQWRkb25SZXNvbHZlRXJyb3IoXG4gICAgICBtc2csXG4gICAgICAnSU5WQUxJRF9QQUNLQUdFX05BTUUnLFxuICAgICAgQWRkb25SZXNvbHZlRXJyb3IuSU5WQUxJRF9QQUNLQUdFX05BTUVcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-addon-resolve/lib/errors.js\n");

/***/ })

};
;