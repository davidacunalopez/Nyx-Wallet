/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/urijs";
exports.ids = ["vendor-chunks/urijs"];
exports.modules = {

/***/ "(ssr)/./node_modules/urijs/src/IPv6.js":
/*!****************************************!*\
  !*** ./node_modules/urijs/src/IPv6.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * URI.js - Mutating URLs\n * IPv6 Support\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if ( true && module.exports) {\n    // Node\n    module.exports = factory();\n  } else if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function (root) {\n  'use strict';\n\n  /*\n  var _in = \"fe80:0000:0000:0000:0204:61ff:fe9d:f156\";\n  var _out = IPv6.best(_in);\n  var _expected = \"fe80::204:61ff:fe9d:f156\";\n\n  console.log(_in, _out, _expected, _out === _expected);\n  */\n\n  // save current IPv6 variable, if any\n  var _IPv6 = root && root.IPv6;\n\n  function bestPresentation(address) {\n    // based on:\n    // Javascript to test an IPv6 address for proper format, and to\n    // present the \"best text representation\" according to IETF Draft RFC at\n    // http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04\n    // 8 Feb 2010 Rich Brown, Dartware, LLC\n    // Please feel free to use this code as long as you provide a link to\n    // http://www.intermapper.com\n    // http://intermapper.com/support/tools/IPV6-Validator.aspx\n    // http://download.dartware.com/thirdparty/ipv6validator.js\n\n    var _address = address.toLowerCase();\n    var segments = _address.split(':');\n    var length = segments.length;\n    var total = 8;\n\n    // trim colons (:: or ::a:b:c… or …a:b:c::)\n    if (segments[0] === '' && segments[1] === '' && segments[2] === '') {\n      // must have been ::\n      // remove first two items\n      segments.shift();\n      segments.shift();\n    } else if (segments[0] === '' && segments[1] === '') {\n      // must have been ::xxxx\n      // remove the first item\n      segments.shift();\n    } else if (segments[length - 1] === '' && segments[length - 2] === '') {\n      // must have been xxxx::\n      segments.pop();\n    }\n\n    length = segments.length;\n\n    // adjust total segments for IPv4 trailer\n    if (segments[length - 1].indexOf('.') !== -1) {\n      // found a \".\" which means IPv4\n      total = 7;\n    }\n\n    // fill empty segments them with \"0000\"\n    var pos;\n    for (pos = 0; pos < length; pos++) {\n      if (segments[pos] === '') {\n        break;\n      }\n    }\n\n    if (pos < total) {\n      segments.splice(pos, 1, '0000');\n      while (segments.length < total) {\n        segments.splice(pos, 0, '0000');\n      }\n    }\n\n    // strip leading zeros\n    var _segments;\n    for (var i = 0; i < total; i++) {\n      _segments = segments[i].split('');\n      for (var j = 0; j < 3 ; j++) {\n        if (_segments[0] === '0' && _segments.length > 1) {\n          _segments.splice(0,1);\n        } else {\n          break;\n        }\n      }\n\n      segments[i] = _segments.join('');\n    }\n\n    // find longest sequence of zeroes and coalesce them into one segment\n    var best = -1;\n    var _best = 0;\n    var _current = 0;\n    var current = -1;\n    var inzeroes = false;\n    // i; already declared\n\n    for (i = 0; i < total; i++) {\n      if (inzeroes) {\n        if (segments[i] === '0') {\n          _current += 1;\n        } else {\n          inzeroes = false;\n          if (_current > _best) {\n            best = current;\n            _best = _current;\n          }\n        }\n      } else {\n        if (segments[i] === '0') {\n          inzeroes = true;\n          current = i;\n          _current = 1;\n        }\n      }\n    }\n\n    if (_current > _best) {\n      best = current;\n      _best = _current;\n    }\n\n    if (_best > 1) {\n      segments.splice(best, _best, '');\n    }\n\n    length = segments.length;\n\n    // assemble remaining segments\n    var result = '';\n    if (segments[0] === '')  {\n      result = ':';\n    }\n\n    for (i = 0; i < length; i++) {\n      result += segments[i];\n      if (i === length - 1) {\n        break;\n      }\n\n      result += ':';\n    }\n\n    if (segments[length - 1] === '') {\n      result += ':';\n    }\n\n    return result;\n  }\n\n  function noConflict() {\n    /*jshint validthis: true */\n    if (root.IPv6 === this) {\n      root.IPv6 = _IPv6;\n    }\n\n    return this;\n  }\n\n  return {\n    best: bestPresentation,\n    noConflict: noConflict\n  };\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXJpanMvc3JjL0lQdjYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUEwQjtBQUNoQztBQUNBO0FBQ0EsSUFBSSxTQUFTLElBQTBDO0FBQ3ZEO0FBQ0EsSUFBSSxvQ0FBTyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDbkIsSUFBSSxLQUFLLEVBR047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVYsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVVNVQVJJT1xcRG9jdW1lbnRzXFxHaXRodWJcXEdhbGF4eUtKLXdhbGxldC0tLUhhY2tcXHdlYlxcbm9kZV9tb2R1bGVzXFx1cmlqc1xcc3JjXFxJUHY2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVVJJLmpzIC0gTXV0YXRpbmcgVVJMc1xuICogSVB2NiBTdXBwb3J0XG4gKlxuICogVmVyc2lvbjogMS4xOS4xMVxuICpcbiAqIEF1dGhvcjogUm9kbmV5IFJlaG1cbiAqIFdlYjogaHR0cDovL21lZGlhbGl6ZS5naXRodWIuaW8vVVJJLmpzL1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyXG4gKiAgIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqXG4gKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIE5vZGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgcm9vdC5JUHY2ID0gZmFjdG9yeShyb290KTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAocm9vdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLypcbiAgdmFyIF9pbiA9IFwiZmU4MDowMDAwOjAwMDA6MDAwMDowMjA0OjYxZmY6ZmU5ZDpmMTU2XCI7XG4gIHZhciBfb3V0ID0gSVB2Ni5iZXN0KF9pbik7XG4gIHZhciBfZXhwZWN0ZWQgPSBcImZlODA6OjIwNDo2MWZmOmZlOWQ6ZjE1NlwiO1xuXG4gIGNvbnNvbGUubG9nKF9pbiwgX291dCwgX2V4cGVjdGVkLCBfb3V0ID09PSBfZXhwZWN0ZWQpO1xuICAqL1xuXG4gIC8vIHNhdmUgY3VycmVudCBJUHY2IHZhcmlhYmxlLCBpZiBhbnlcbiAgdmFyIF9JUHY2ID0gcm9vdCAmJiByb290LklQdjY7XG5cbiAgZnVuY3Rpb24gYmVzdFByZXNlbnRhdGlvbihhZGRyZXNzKSB7XG4gICAgLy8gYmFzZWQgb246XG4gICAgLy8gSmF2YXNjcmlwdCB0byB0ZXN0IGFuIElQdjYgYWRkcmVzcyBmb3IgcHJvcGVyIGZvcm1hdCwgYW5kIHRvXG4gICAgLy8gcHJlc2VudCB0aGUgXCJiZXN0IHRleHQgcmVwcmVzZW50YXRpb25cIiBhY2NvcmRpbmcgdG8gSUVURiBEcmFmdCBSRkMgYXRcbiAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLTZtYW4tdGV4dC1hZGRyLXJlcHJlc2VudGF0aW9uLTA0XG4gICAgLy8gOCBGZWIgMjAxMCBSaWNoIEJyb3duLCBEYXJ0d2FyZSwgTExDXG4gICAgLy8gUGxlYXNlIGZlZWwgZnJlZSB0byB1c2UgdGhpcyBjb2RlIGFzIGxvbmcgYXMgeW91IHByb3ZpZGUgYSBsaW5rIHRvXG4gICAgLy8gaHR0cDovL3d3dy5pbnRlcm1hcHBlci5jb21cbiAgICAvLyBodHRwOi8vaW50ZXJtYXBwZXIuY29tL3N1cHBvcnQvdG9vbHMvSVBWNi1WYWxpZGF0b3IuYXNweFxuICAgIC8vIGh0dHA6Ly9kb3dubG9hZC5kYXJ0d2FyZS5jb20vdGhpcmRwYXJ0eS9pcHY2dmFsaWRhdG9yLmpzXG5cbiAgICB2YXIgX2FkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHNlZ21lbnRzID0gX2FkZHJlc3Muc3BsaXQoJzonKTtcbiAgICB2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHZhciB0b3RhbCA9IDg7XG5cbiAgICAvLyB0cmltIGNvbG9ucyAoOjogb3IgOjphOmI6Y+KApiBvciDigKZhOmI6Yzo6KVxuICAgIGlmIChzZWdtZW50c1swXSA9PT0gJycgJiYgc2VnbWVudHNbMV0gPT09ICcnICYmIHNlZ21lbnRzWzJdID09PSAnJykge1xuICAgICAgLy8gbXVzdCBoYXZlIGJlZW4gOjpcbiAgICAgIC8vIHJlbW92ZSBmaXJzdCB0d28gaXRlbXNcbiAgICAgIHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICBzZWdtZW50cy5zaGlmdCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudHNbMF0gPT09ICcnICYmIHNlZ21lbnRzWzFdID09PSAnJykge1xuICAgICAgLy8gbXVzdCBoYXZlIGJlZW4gOjp4eHh4XG4gICAgICAvLyByZW1vdmUgdGhlIGZpcnN0IGl0ZW1cbiAgICAgIHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50c1tsZW5ndGggLSAxXSA9PT0gJycgJiYgc2VnbWVudHNbbGVuZ3RoIC0gMl0gPT09ICcnKSB7XG4gICAgICAvLyBtdXN0IGhhdmUgYmVlbiB4eHh4OjpcbiAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgIH1cblxuICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgIC8vIGFkanVzdCB0b3RhbCBzZWdtZW50cyBmb3IgSVB2NCB0cmFpbGVyXG4gICAgaWYgKHNlZ21lbnRzW2xlbmd0aCAtIDFdLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgIC8vIGZvdW5kIGEgXCIuXCIgd2hpY2ggbWVhbnMgSVB2NFxuICAgICAgdG90YWwgPSA3O1xuICAgIH1cblxuICAgIC8vIGZpbGwgZW1wdHkgc2VnbWVudHMgdGhlbSB3aXRoIFwiMDAwMFwiXG4gICAgdmFyIHBvcztcbiAgICBmb3IgKHBvcyA9IDA7IHBvcyA8IGxlbmd0aDsgcG9zKyspIHtcbiAgICAgIGlmIChzZWdtZW50c1twb3NdID09PSAnJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zIDwgdG90YWwpIHtcbiAgICAgIHNlZ21lbnRzLnNwbGljZShwb3MsIDEsICcwMDAwJyk7XG4gICAgICB3aGlsZSAoc2VnbWVudHMubGVuZ3RoIDwgdG90YWwpIHtcbiAgICAgICAgc2VnbWVudHMuc3BsaWNlKHBvcywgMCwgJzAwMDAnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm9zXG4gICAgdmFyIF9zZWdtZW50cztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIF9zZWdtZW50cyA9IHNlZ21lbnRzW2ldLnNwbGl0KCcnKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMyA7IGorKykge1xuICAgICAgICBpZiAoX3NlZ21lbnRzWzBdID09PSAnMCcgJiYgX3NlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBfc2VnbWVudHMuc3BsaWNlKDAsMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VnbWVudHNbaV0gPSBfc2VnbWVudHMuam9pbignJyk7XG4gICAgfVxuXG4gICAgLy8gZmluZCBsb25nZXN0IHNlcXVlbmNlIG9mIHplcm9lcyBhbmQgY29hbGVzY2UgdGhlbSBpbnRvIG9uZSBzZWdtZW50XG4gICAgdmFyIGJlc3QgPSAtMTtcbiAgICB2YXIgX2Jlc3QgPSAwO1xuICAgIHZhciBfY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnQgPSAtMTtcbiAgICB2YXIgaW56ZXJvZXMgPSBmYWxzZTtcbiAgICAvLyBpOyBhbHJlYWR5IGRlY2xhcmVkXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgaWYgKGluemVyb2VzKSB7XG4gICAgICAgIGlmIChzZWdtZW50c1tpXSA9PT0gJzAnKSB7XG4gICAgICAgICAgX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnplcm9lcyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChfY3VycmVudCA+IF9iZXN0KSB7XG4gICAgICAgICAgICBiZXN0ID0gY3VycmVudDtcbiAgICAgICAgICAgIF9iZXN0ID0gX2N1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2VnbWVudHNbaV0gPT09ICcwJykge1xuICAgICAgICAgIGluemVyb2VzID0gdHJ1ZTtcbiAgICAgICAgICBjdXJyZW50ID0gaTtcbiAgICAgICAgICBfY3VycmVudCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX2N1cnJlbnQgPiBfYmVzdCkge1xuICAgICAgYmVzdCA9IGN1cnJlbnQ7XG4gICAgICBfYmVzdCA9IF9jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChfYmVzdCA+IDEpIHtcbiAgICAgIHNlZ21lbnRzLnNwbGljZShiZXN0LCBfYmVzdCwgJycpO1xuICAgIH1cblxuICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgIC8vIGFzc2VtYmxlIHJlbWFpbmluZyBzZWdtZW50c1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBpZiAoc2VnbWVudHNbMF0gPT09ICcnKSAge1xuICAgICAgcmVzdWx0ID0gJzonO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHNlZ21lbnRzW2ldO1xuICAgICAgaWYgKGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSAnOic7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnRzW2xlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgcmVzdWx0ICs9ICc6JztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAvKmpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgICBpZiAocm9vdC5JUHY2ID09PSB0aGlzKSB7XG4gICAgICByb290LklQdjYgPSBfSVB2NjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmVzdDogYmVzdFByZXNlbnRhdGlvbixcbiAgICBub0NvbmZsaWN0OiBub0NvbmZsaWN0XG4gIH07XG59KSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/urijs/src/IPv6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/urijs/src/SecondLevelDomains.js":
/*!******************************************************!*\
  !*** ./node_modules/urijs/src/SecondLevelDomains.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * URI.js - Mutating URLs\n * Second Level Domain (SLD) Support\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if ( true && module.exports) {\n    // Node\n    module.exports = factory();\n  } else if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function (root) {\n  'use strict';\n\n  // save current SecondLevelDomains variable, if any\n  var _SecondLevelDomains = root && root.SecondLevelDomains;\n\n  var SLD = {\n    // list of known Second Level Domains\n    // converted list of SLDs from https://github.com/gavingmiller/second-level-domains\n    // ----\n    // publicsuffix.org is more current and actually used by a couple of browsers internally.\n    // downside is it also contains domains like \"dyndns.org\" - which is fine for the security\n    // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js\n    // ----\n    list: {\n      'ac':' com gov mil net org ',\n      'ae':' ac co gov mil name net org pro sch ',\n      'af':' com edu gov net org ',\n      'al':' com edu gov mil net org ',\n      'ao':' co ed gv it og pb ',\n      'ar':' com edu gob gov int mil net org tur ',\n      'at':' ac co gv or ',\n      'au':' asn com csiro edu gov id net org ',\n      'ba':' co com edu gov mil net org rs unbi unmo unsa untz unze ',\n      'bb':' biz co com edu gov info net org store tv ',\n      'bh':' biz cc com edu gov info net org ',\n      'bn':' com edu gov net org ',\n      'bo':' com edu gob gov int mil net org tv ',\n      'br':' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',\n      'bs':' com edu gov net org ',\n      'bz':' du et om ov rg ',\n      'ca':' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',\n      'ck':' biz co edu gen gov info net org ',\n      'cn':' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',\n      'co':' com edu gov mil net nom org ',\n      'cr':' ac c co ed fi go or sa ',\n      'cy':' ac biz com ekloges gov ltd name net org parliament press pro tm ',\n      'do':' art com edu gob gov mil net org sld web ',\n      'dz':' art asso com edu gov net org pol ',\n      'ec':' com edu fin gov info med mil net org pro ',\n      'eg':' com edu eun gov mil name net org sci ',\n      'er':' com edu gov ind mil net org rochest w ',\n      'es':' com edu gob nom org ',\n      'et':' biz com edu gov info name net org ',\n      'fj':' ac biz com info mil name net org pro ',\n      'fk':' ac co gov net nom org ',\n      'fr':' asso com f gouv nom prd presse tm ',\n      'gg':' co net org ',\n      'gh':' com edu gov mil org ',\n      'gn':' ac com gov net org ',\n      'gr':' com edu gov mil net org ',\n      'gt':' com edu gob ind mil net org ',\n      'gu':' com edu gov net org ',\n      'hk':' com edu gov idv net org ',\n      'hu':' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',\n      'id':' ac co go mil net or sch web ',\n      'il':' ac co gov idf k12 muni net org ',\n      'in':' ac co edu ernet firm gen gov i ind mil net nic org res ',\n      'iq':' com edu gov i mil net org ',\n      'ir':' ac co dnssec gov i id net org sch ',\n      'it':' edu gov ',\n      'je':' co net org ',\n      'jo':' com edu gov mil name net org sch ',\n      'jp':' ac ad co ed go gr lg ne or ',\n      'ke':' ac co go info me mobi ne or sc ',\n      'kh':' com edu gov mil net org per ',\n      'ki':' biz com de edu gov info mob net org tel ',\n      'km':' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',\n      'kn':' edu gov net org ',\n      'kr':' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',\n      'kw':' com edu gov net org ',\n      'ky':' com edu gov net org ',\n      'kz':' com edu gov mil net org ',\n      'lb':' com edu gov net org ',\n      'lk':' assn com edu gov grp hotel int ltd net ngo org sch soc web ',\n      'lr':' com edu gov net org ',\n      'lv':' asn com conf edu gov id mil net org ',\n      'ly':' com edu gov id med net org plc sch ',\n      'ma':' ac co gov m net org press ',\n      'mc':' asso tm ',\n      'me':' ac co edu gov its net org priv ',\n      'mg':' com edu gov mil nom org prd tm ',\n      'mk':' com edu gov inf name net org pro ',\n      'ml':' com edu gov net org presse ',\n      'mn':' edu gov org ',\n      'mo':' com edu gov net org ',\n      'mt':' com edu gov net org ',\n      'mv':' aero biz com coop edu gov info int mil museum name net org pro ',\n      'mw':' ac co com coop edu gov int museum net org ',\n      'mx':' com edu gob net org ',\n      'my':' com edu gov mil name net org sch ',\n      'nf':' arts com firm info net other per rec store web ',\n      'ng':' biz com edu gov mil mobi name net org sch ',\n      'ni':' ac co com edu gob mil net nom org ',\n      'np':' com edu gov mil net org ',\n      'nr':' biz com edu gov info net org ',\n      'om':' ac biz co com edu gov med mil museum net org pro sch ',\n      'pe':' com edu gob mil net nom org sld ',\n      'ph':' com edu gov i mil net ngo org ',\n      'pk':' biz com edu fam gob gok gon gop gos gov net org web ',\n      'pl':' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',\n      'pr':' ac biz com edu est gov info isla name net org pro prof ',\n      'ps':' com edu gov net org plo sec ',\n      'pw':' belau co ed go ne or ',\n      'ro':' arts com firm info nom nt org rec store tm www ',\n      'rs':' ac co edu gov in org ',\n      'sb':' com edu gov net org ',\n      'sc':' com edu gov net org ',\n      'sh':' co com edu gov net nom org ',\n      'sl':' com edu gov net org ',\n      'st':' co com consulado edu embaixada gov mil net org principe saotome store ',\n      'sv':' com edu gob org red ',\n      'sz':' ac co org ',\n      'tr':' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',\n      'tt':' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',\n      'tw':' club com ebiz edu game gov idv mil net org ',\n      'mu':' ac co com gov net or org ',\n      'mz':' ac co edu gov org ',\n      'na':' co com ',\n      'nz':' ac co cri geek gen govt health iwi maori mil net org parliament school ',\n      'pa':' abo ac com edu gob ing med net nom org sld ',\n      'pt':' com edu gov int net nome org publ ',\n      'py':' com edu gov mil net org ',\n      'qa':' com edu gov mil net org ',\n      're':' asso com nom ',\n      'ru':' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',\n      'rw':' ac co com edu gouv gov int mil net ',\n      'sa':' com edu gov med net org pub sch ',\n      'sd':' com edu gov info med net org tv ',\n      'se':' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',\n      'sg':' com edu gov idn net org per ',\n      'sn':' art com edu gouv org perso univ ',\n      'sy':' com edu gov mil net news org ',\n      'th':' ac co go in mi net or ',\n      'tj':' ac biz co com edu go gov info int mil name net nic org test web ',\n      'tn':' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',\n      'tz':' ac co go ne or ',\n      'ua':' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',\n      'ug':' ac co go ne or org sc ',\n      'uk':' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',\n      'us':' dni fed isa kids nsn ',\n      'uy':' com edu gub mil net org ',\n      've':' co com edu gob info mil net org web ',\n      'vi':' co com k12 net org ',\n      'vn':' ac biz com edu gov health info int name net org pro ',\n      'ye':' co com gov ltd me net org plc ',\n      'yu':' ac co edu gov org ',\n      'za':' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',\n      'zm':' ac co com edu gov net org sch ',\n      // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains\n      'com': 'ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ',\n      'net': 'gb jp se uk ',\n      'org': 'ae',\n      'de': 'com '\n    },\n    // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost\n    // in both performance and memory footprint. No initialization required.\n    // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4\n    // Following methods use lastIndexOf() rather than array.split() in order\n    // to avoid any memory allocations.\n    has: function(domain) {\n      var tldOffset = domain.lastIndexOf('.');\n      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {\n        return false;\n      }\n      var sldOffset = domain.lastIndexOf('.', tldOffset-1);\n      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {\n        return false;\n      }\n      var sldList = SLD.list[domain.slice(tldOffset+1)];\n      if (!sldList) {\n        return false;\n      }\n      return sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') >= 0;\n    },\n    is: function(domain) {\n      var tldOffset = domain.lastIndexOf('.');\n      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {\n        return false;\n      }\n      var sldOffset = domain.lastIndexOf('.', tldOffset-1);\n      if (sldOffset >= 0) {\n        return false;\n      }\n      var sldList = SLD.list[domain.slice(tldOffset+1)];\n      if (!sldList) {\n        return false;\n      }\n      return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;\n    },\n    get: function(domain) {\n      var tldOffset = domain.lastIndexOf('.');\n      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {\n        return null;\n      }\n      var sldOffset = domain.lastIndexOf('.', tldOffset-1);\n      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {\n        return null;\n      }\n      var sldList = SLD.list[domain.slice(tldOffset+1)];\n      if (!sldList) {\n        return null;\n      }\n      if (sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') < 0) {\n        return null;\n      }\n      return domain.slice(sldOffset+1);\n    },\n    noConflict: function(){\n      if (root.SecondLevelDomains === this) {\n        root.SecondLevelDomains = _SecondLevelDomains;\n      }\n      return this;\n    }\n  };\n\n  return SLD;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXJpanMvc3JjL1NlY29uZExldmVsRG9tYWlucy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQTBCO0FBQ2hDO0FBQ0E7QUFDQSxJQUFJLFNBQVMsSUFBMEM7QUFDdkQ7QUFDQSxJQUFJLG9DQUFPLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUNuQixJQUFJLEtBQUssRUFHTjtBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVVNVQVJJT1xcRG9jdW1lbnRzXFxHaXRodWJcXEdhbGF4eUtKLXdhbGxldC0tLUhhY2tcXHdlYlxcbm9kZV9tb2R1bGVzXFx1cmlqc1xcc3JjXFxTZWNvbmRMZXZlbERvbWFpbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBVUkkuanMgLSBNdXRhdGluZyBVUkxzXG4gKiBTZWNvbmQgTGV2ZWwgRG9tYWluIChTTEQpIFN1cHBvcnRcbiAqXG4gKiBWZXJzaW9uOiAxLjE5LjExXG4gKlxuICogQXV0aG9yOiBSb2RuZXkgUmVobVxuICogV2ViOiBodHRwOi8vbWVkaWFsaXplLmdpdGh1Yi5pby9VUkkuanMvXG4gKlxuICogTGljZW5zZWQgdW5kZXJcbiAqICAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuICpcbiAqL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kL2Jsb2IvbWFzdGVyL3JldHVybkV4cG9ydHMuanNcbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gTm9kZVxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoZmFjdG9yeSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICByb290LlNlY29uZExldmVsRG9tYWlucyA9IGZhY3Rvcnkocm9vdCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKHJvb3QpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHNhdmUgY3VycmVudCBTZWNvbmRMZXZlbERvbWFpbnMgdmFyaWFibGUsIGlmIGFueVxuICB2YXIgX1NlY29uZExldmVsRG9tYWlucyA9IHJvb3QgJiYgcm9vdC5TZWNvbmRMZXZlbERvbWFpbnM7XG5cbiAgdmFyIFNMRCA9IHtcbiAgICAvLyBsaXN0IG9mIGtub3duIFNlY29uZCBMZXZlbCBEb21haW5zXG4gICAgLy8gY29udmVydGVkIGxpc3Qgb2YgU0xEcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nYXZpbmdtaWxsZXIvc2Vjb25kLWxldmVsLWRvbWFpbnNcbiAgICAvLyAtLS0tXG4gICAgLy8gcHVibGljc3VmZml4Lm9yZyBpcyBtb3JlIGN1cnJlbnQgYW5kIGFjdHVhbGx5IHVzZWQgYnkgYSBjb3VwbGUgb2YgYnJvd3NlcnMgaW50ZXJuYWxseS5cbiAgICAvLyBkb3duc2lkZSBpcyBpdCBhbHNvIGNvbnRhaW5zIGRvbWFpbnMgbGlrZSBcImR5bmRucy5vcmdcIiAtIHdoaWNoIGlzIGZpbmUgZm9yIHRoZSBzZWN1cml0eVxuICAgIC8vIGlzc3VlcyBicm93c2VyIGhhdmUgdG8gZGVhbCB3aXRoIChTT1AgZm9yIGNvb2tpZXMsIGV0YykgLSBidXQgaXMgd2F5IG92ZXJib2FyZCBmb3IgVVJJLmpzXG4gICAgLy8gLS0tLVxuICAgIGxpc3Q6IHtcbiAgICAgICdhYyc6JyBjb20gZ292IG1pbCBuZXQgb3JnICcsXG4gICAgICAnYWUnOicgYWMgY28gZ292IG1pbCBuYW1lIG5ldCBvcmcgcHJvIHNjaCAnLFxuICAgICAgJ2FmJzonIGNvbSBlZHUgZ292IG5ldCBvcmcgJyxcbiAgICAgICdhbCc6JyBjb20gZWR1IGdvdiBtaWwgbmV0IG9yZyAnLFxuICAgICAgJ2FvJzonIGNvIGVkIGd2IGl0IG9nIHBiICcsXG4gICAgICAnYXInOicgY29tIGVkdSBnb2IgZ292IGludCBtaWwgbmV0IG9yZyB0dXIgJyxcbiAgICAgICdhdCc6JyBhYyBjbyBndiBvciAnLFxuICAgICAgJ2F1JzonIGFzbiBjb20gY3Npcm8gZWR1IGdvdiBpZCBuZXQgb3JnICcsXG4gICAgICAnYmEnOicgY28gY29tIGVkdSBnb3YgbWlsIG5ldCBvcmcgcnMgdW5iaSB1bm1vIHVuc2EgdW50eiB1bnplICcsXG4gICAgICAnYmInOicgYml6IGNvIGNvbSBlZHUgZ292IGluZm8gbmV0IG9yZyBzdG9yZSB0diAnLFxuICAgICAgJ2JoJzonIGJpeiBjYyBjb20gZWR1IGdvdiBpbmZvIG5ldCBvcmcgJyxcbiAgICAgICdibic6JyBjb20gZWR1IGdvdiBuZXQgb3JnICcsXG4gICAgICAnYm8nOicgY29tIGVkdSBnb2IgZ292IGludCBtaWwgbmV0IG9yZyB0diAnLFxuICAgICAgJ2JyJzonIGFkbSBhZHYgYWdyIGFtIGFycSBhcnQgYXRvIGIgYmlvIGJsb2cgYm1kIGNpbSBjbmcgY250IGNvbSBjb29wIGVjbiBlZHUgZW5nIGVzcCBldGMgZXRpIGZhciBmbG9nIGZtIGZuZCBmb3QgZnN0IGcxMiBnZ2YgZ292IGltYiBpbmQgaW5mIGpvciBqdXMgbGVsIG1hdCBtZWQgbWlsIG11cyBuZXQgbm9tIG5vdCBudHIgb2RvIG9yZyBwcGcgcHJvIHBzYyBwc2kgcXNsIHJlYyBzbGcgc3J2IHRtcCB0cmQgdHVyIHR2IHZldCB2bG9nIHdpa2kgemxnICcsXG4gICAgICAnYnMnOicgY29tIGVkdSBnb3YgbmV0IG9yZyAnLFxuICAgICAgJ2J6JzonIGR1IGV0IG9tIG92IHJnICcsXG4gICAgICAnY2EnOicgYWIgYmMgbWIgbmIgbmYgbmwgbnMgbnQgbnUgb24gcGUgcWMgc2sgeWsgJyxcbiAgICAgICdjayc6JyBiaXogY28gZWR1IGdlbiBnb3YgaW5mbyBuZXQgb3JnICcsXG4gICAgICAnY24nOicgYWMgYWggYmogY29tIGNxIGVkdSBmaiBnZCBnb3YgZ3MgZ3ggZ3ogaGEgaGIgaGUgaGkgaGwgaG4gamwganMganggbG4gbWlsIG5ldCBubSBueCBvcmcgcWggc2Mgc2Qgc2ggc24gc3ggdGogdHcgeGogeHogeW4gemogJyxcbiAgICAgICdjbyc6JyBjb20gZWR1IGdvdiBtaWwgbmV0IG5vbSBvcmcgJyxcbiAgICAgICdjcic6JyBhYyBjIGNvIGVkIGZpIGdvIG9yIHNhICcsXG4gICAgICAnY3knOicgYWMgYml6IGNvbSBla2xvZ2VzIGdvdiBsdGQgbmFtZSBuZXQgb3JnIHBhcmxpYW1lbnQgcHJlc3MgcHJvIHRtICcsXG4gICAgICAnZG8nOicgYXJ0IGNvbSBlZHUgZ29iIGdvdiBtaWwgbmV0IG9yZyBzbGQgd2ViICcsXG4gICAgICAnZHonOicgYXJ0IGFzc28gY29tIGVkdSBnb3YgbmV0IG9yZyBwb2wgJyxcbiAgICAgICdlYyc6JyBjb20gZWR1IGZpbiBnb3YgaW5mbyBtZWQgbWlsIG5ldCBvcmcgcHJvICcsXG4gICAgICAnZWcnOicgY29tIGVkdSBldW4gZ292IG1pbCBuYW1lIG5ldCBvcmcgc2NpICcsXG4gICAgICAnZXInOicgY29tIGVkdSBnb3YgaW5kIG1pbCBuZXQgb3JnIHJvY2hlc3QgdyAnLFxuICAgICAgJ2VzJzonIGNvbSBlZHUgZ29iIG5vbSBvcmcgJyxcbiAgICAgICdldCc6JyBiaXogY29tIGVkdSBnb3YgaW5mbyBuYW1lIG5ldCBvcmcgJyxcbiAgICAgICdmaic6JyBhYyBiaXogY29tIGluZm8gbWlsIG5hbWUgbmV0IG9yZyBwcm8gJyxcbiAgICAgICdmayc6JyBhYyBjbyBnb3YgbmV0IG5vbSBvcmcgJyxcbiAgICAgICdmcic6JyBhc3NvIGNvbSBmIGdvdXYgbm9tIHByZCBwcmVzc2UgdG0gJyxcbiAgICAgICdnZyc6JyBjbyBuZXQgb3JnICcsXG4gICAgICAnZ2gnOicgY29tIGVkdSBnb3YgbWlsIG9yZyAnLFxuICAgICAgJ2duJzonIGFjIGNvbSBnb3YgbmV0IG9yZyAnLFxuICAgICAgJ2dyJzonIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnICcsXG4gICAgICAnZ3QnOicgY29tIGVkdSBnb2IgaW5kIG1pbCBuZXQgb3JnICcsXG4gICAgICAnZ3UnOicgY29tIGVkdSBnb3YgbmV0IG9yZyAnLFxuICAgICAgJ2hrJzonIGNvbSBlZHUgZ292IGlkdiBuZXQgb3JnICcsXG4gICAgICAnaHUnOicgMjAwMCBhZ3JhciBib2x0IGNhc2lubyBjaXR5IGNvIGVyb3RpY2EgZXJvdGlrYSBmaWxtIGZvcnVtIGdhbWVzIGhvdGVsIGluZm8gaW5nYXRsYW4gam9nYXN6IGtvbnl2ZWxvIGxha2FzIG1lZGlhIG5ld3Mgb3JnIHByaXYgcmVrbGFtIHNleCBzaG9wIHNwb3J0IHN1bGkgc3pleCB0bSB0b3pzZGUgdXRhemFzIHZpZGVvICcsXG4gICAgICAnaWQnOicgYWMgY28gZ28gbWlsIG5ldCBvciBzY2ggd2ViICcsXG4gICAgICAnaWwnOicgYWMgY28gZ292IGlkZiBrMTIgbXVuaSBuZXQgb3JnICcsXG4gICAgICAnaW4nOicgYWMgY28gZWR1IGVybmV0IGZpcm0gZ2VuIGdvdiBpIGluZCBtaWwgbmV0IG5pYyBvcmcgcmVzICcsXG4gICAgICAnaXEnOicgY29tIGVkdSBnb3YgaSBtaWwgbmV0IG9yZyAnLFxuICAgICAgJ2lyJzonIGFjIGNvIGRuc3NlYyBnb3YgaSBpZCBuZXQgb3JnIHNjaCAnLFxuICAgICAgJ2l0JzonIGVkdSBnb3YgJyxcbiAgICAgICdqZSc6JyBjbyBuZXQgb3JnICcsXG4gICAgICAnam8nOicgY29tIGVkdSBnb3YgbWlsIG5hbWUgbmV0IG9yZyBzY2ggJyxcbiAgICAgICdqcCc6JyBhYyBhZCBjbyBlZCBnbyBnciBsZyBuZSBvciAnLFxuICAgICAgJ2tlJzonIGFjIGNvIGdvIGluZm8gbWUgbW9iaSBuZSBvciBzYyAnLFxuICAgICAgJ2toJzonIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnIHBlciAnLFxuICAgICAgJ2tpJzonIGJpeiBjb20gZGUgZWR1IGdvdiBpbmZvIG1vYiBuZXQgb3JnIHRlbCAnLFxuICAgICAgJ2ttJzonIGFzc28gY29tIGNvb3AgZWR1IGdvdXYgayBtZWRlY2luIG1pbCBub20gbm90YWlyZXMgcGhhcm1hY2llbnMgcHJlc3NlIHRtIHZldGVyaW5haXJlICcsXG4gICAgICAna24nOicgZWR1IGdvdiBuZXQgb3JnICcsXG4gICAgICAna3InOicgYWMgYnVzYW4gY2h1bmdidWsgY2h1bmduYW0gY28gZGFlZ3UgZGFlamVvbiBlcyBnYW5nd29uIGdvIGd3YW5nanUgZ3llb25nYnVrIGd5ZW9uZ2dpIGd5ZW9uZ25hbSBocyBpbmNoZW9uIGplanUgamVvbmJ1ayBqZW9ubmFtIGsga2cgbWlsIG1zIG5lIG9yIHBlIHJlIHNjIHNlb3VsIHVsc2FuICcsXG4gICAgICAna3cnOicgY29tIGVkdSBnb3YgbmV0IG9yZyAnLFxuICAgICAgJ2t5JzonIGNvbSBlZHUgZ292IG5ldCBvcmcgJyxcbiAgICAgICdreic6JyBjb20gZWR1IGdvdiBtaWwgbmV0IG9yZyAnLFxuICAgICAgJ2xiJzonIGNvbSBlZHUgZ292IG5ldCBvcmcgJyxcbiAgICAgICdsayc6JyBhc3NuIGNvbSBlZHUgZ292IGdycCBob3RlbCBpbnQgbHRkIG5ldCBuZ28gb3JnIHNjaCBzb2Mgd2ViICcsXG4gICAgICAnbHInOicgY29tIGVkdSBnb3YgbmV0IG9yZyAnLFxuICAgICAgJ2x2JzonIGFzbiBjb20gY29uZiBlZHUgZ292IGlkIG1pbCBuZXQgb3JnICcsXG4gICAgICAnbHknOicgY29tIGVkdSBnb3YgaWQgbWVkIG5ldCBvcmcgcGxjIHNjaCAnLFxuICAgICAgJ21hJzonIGFjIGNvIGdvdiBtIG5ldCBvcmcgcHJlc3MgJyxcbiAgICAgICdtYyc6JyBhc3NvIHRtICcsXG4gICAgICAnbWUnOicgYWMgY28gZWR1IGdvdiBpdHMgbmV0IG9yZyBwcml2ICcsXG4gICAgICAnbWcnOicgY29tIGVkdSBnb3YgbWlsIG5vbSBvcmcgcHJkIHRtICcsXG4gICAgICAnbWsnOicgY29tIGVkdSBnb3YgaW5mIG5hbWUgbmV0IG9yZyBwcm8gJyxcbiAgICAgICdtbCc6JyBjb20gZWR1IGdvdiBuZXQgb3JnIHByZXNzZSAnLFxuICAgICAgJ21uJzonIGVkdSBnb3Ygb3JnICcsXG4gICAgICAnbW8nOicgY29tIGVkdSBnb3YgbmV0IG9yZyAnLFxuICAgICAgJ210JzonIGNvbSBlZHUgZ292IG5ldCBvcmcgJyxcbiAgICAgICdtdic6JyBhZXJvIGJpeiBjb20gY29vcCBlZHUgZ292IGluZm8gaW50IG1pbCBtdXNldW0gbmFtZSBuZXQgb3JnIHBybyAnLFxuICAgICAgJ213JzonIGFjIGNvIGNvbSBjb29wIGVkdSBnb3YgaW50IG11c2V1bSBuZXQgb3JnICcsXG4gICAgICAnbXgnOicgY29tIGVkdSBnb2IgbmV0IG9yZyAnLFxuICAgICAgJ215JzonIGNvbSBlZHUgZ292IG1pbCBuYW1lIG5ldCBvcmcgc2NoICcsXG4gICAgICAnbmYnOicgYXJ0cyBjb20gZmlybSBpbmZvIG5ldCBvdGhlciBwZXIgcmVjIHN0b3JlIHdlYiAnLFxuICAgICAgJ25nJzonIGJpeiBjb20gZWR1IGdvdiBtaWwgbW9iaSBuYW1lIG5ldCBvcmcgc2NoICcsXG4gICAgICAnbmknOicgYWMgY28gY29tIGVkdSBnb2IgbWlsIG5ldCBub20gb3JnICcsXG4gICAgICAnbnAnOicgY29tIGVkdSBnb3YgbWlsIG5ldCBvcmcgJyxcbiAgICAgICducic6JyBiaXogY29tIGVkdSBnb3YgaW5mbyBuZXQgb3JnICcsXG4gICAgICAnb20nOicgYWMgYml6IGNvIGNvbSBlZHUgZ292IG1lZCBtaWwgbXVzZXVtIG5ldCBvcmcgcHJvIHNjaCAnLFxuICAgICAgJ3BlJzonIGNvbSBlZHUgZ29iIG1pbCBuZXQgbm9tIG9yZyBzbGQgJyxcbiAgICAgICdwaCc6JyBjb20gZWR1IGdvdiBpIG1pbCBuZXQgbmdvIG9yZyAnLFxuICAgICAgJ3BrJzonIGJpeiBjb20gZWR1IGZhbSBnb2IgZ29rIGdvbiBnb3AgZ29zIGdvdiBuZXQgb3JnIHdlYiAnLFxuICAgICAgJ3BsJzonIGFydCBiaWFseXN0b2sgYml6IGNvbSBlZHUgZ2RhIGdkYW5zayBnb3J6b3cgZ292IGluZm8ga2F0b3dpY2Uga3Jha293IGxvZHogbHVibGluIG1pbCBuZXQgbmdvIG9sc3p0eW4gb3JnIHBvem5hbiBwd3IgcmFkb20gc2x1cHNrIHN6Y3plY2luIHRvcnVuIHdhcnN6YXdhIHdhdyB3cm9jIHdyb2NsYXcgemdvcmEgJyxcbiAgICAgICdwcic6JyBhYyBiaXogY29tIGVkdSBlc3QgZ292IGluZm8gaXNsYSBuYW1lIG5ldCBvcmcgcHJvIHByb2YgJyxcbiAgICAgICdwcyc6JyBjb20gZWR1IGdvdiBuZXQgb3JnIHBsbyBzZWMgJyxcbiAgICAgICdwdyc6JyBiZWxhdSBjbyBlZCBnbyBuZSBvciAnLFxuICAgICAgJ3JvJzonIGFydHMgY29tIGZpcm0gaW5mbyBub20gbnQgb3JnIHJlYyBzdG9yZSB0bSB3d3cgJyxcbiAgICAgICdycyc6JyBhYyBjbyBlZHUgZ292IGluIG9yZyAnLFxuICAgICAgJ3NiJzonIGNvbSBlZHUgZ292IG5ldCBvcmcgJyxcbiAgICAgICdzYyc6JyBjb20gZWR1IGdvdiBuZXQgb3JnICcsXG4gICAgICAnc2gnOicgY28gY29tIGVkdSBnb3YgbmV0IG5vbSBvcmcgJyxcbiAgICAgICdzbCc6JyBjb20gZWR1IGdvdiBuZXQgb3JnICcsXG4gICAgICAnc3QnOicgY28gY29tIGNvbnN1bGFkbyBlZHUgZW1iYWl4YWRhIGdvdiBtaWwgbmV0IG9yZyBwcmluY2lwZSBzYW90b21lIHN0b3JlICcsXG4gICAgICAnc3YnOicgY29tIGVkdSBnb2Igb3JnIHJlZCAnLFxuICAgICAgJ3N6JzonIGFjIGNvIG9yZyAnLFxuICAgICAgJ3RyJzonIGF2IGJicyBiZWwgYml6IGNvbSBkciBlZHUgZ2VuIGdvdiBpbmZvIGsxMiBuYW1lIG5ldCBvcmcgcG9sIHRlbCB0c2sgdHYgd2ViICcsXG4gICAgICAndHQnOicgYWVybyBiaXogY2F0IGNvIGNvbSBjb29wIGVkdSBnb3YgaW5mbyBpbnQgam9icyBtaWwgbW9iaSBtdXNldW0gbmFtZSBuZXQgb3JnIHBybyB0ZWwgdHJhdmVsICcsXG4gICAgICAndHcnOicgY2x1YiBjb20gZWJpeiBlZHUgZ2FtZSBnb3YgaWR2IG1pbCBuZXQgb3JnICcsXG4gICAgICAnbXUnOicgYWMgY28gY29tIGdvdiBuZXQgb3Igb3JnICcsXG4gICAgICAnbXonOicgYWMgY28gZWR1IGdvdiBvcmcgJyxcbiAgICAgICduYSc6JyBjbyBjb20gJyxcbiAgICAgICdueic6JyBhYyBjbyBjcmkgZ2VlayBnZW4gZ292dCBoZWFsdGggaXdpIG1hb3JpIG1pbCBuZXQgb3JnIHBhcmxpYW1lbnQgc2Nob29sICcsXG4gICAgICAncGEnOicgYWJvIGFjIGNvbSBlZHUgZ29iIGluZyBtZWQgbmV0IG5vbSBvcmcgc2xkICcsXG4gICAgICAncHQnOicgY29tIGVkdSBnb3YgaW50IG5ldCBub21lIG9yZyBwdWJsICcsXG4gICAgICAncHknOicgY29tIGVkdSBnb3YgbWlsIG5ldCBvcmcgJyxcbiAgICAgICdxYSc6JyBjb20gZWR1IGdvdiBtaWwgbmV0IG9yZyAnLFxuICAgICAgJ3JlJzonIGFzc28gY29tIG5vbSAnLFxuICAgICAgJ3J1JzonIGFjIGFkeWdleWEgYWx0YWkgYW11ciBhcmtoYW5nZWxzayBhc3RyYWtoYW4gYmFzaGtpcmlhIGJlbGdvcm9kIGJpciBicnlhbnNrIGJ1cnlhdGlhIGNiZyBjaGVsIGNoZWx5YWJpbnNrIGNoaXRhIGNodWtvdGthIGNodXZhc2hpYSBjb20gZGFnZXN0YW4gZS1idXJnIGVkdSBnb3YgZ3Jvem55IGludCBpcmt1dHNrIGl2YW5vdm8gaXpoZXZzayBqYXIgam9zaGthci1vbGEga2FsbXlraWEga2FsdWdhIGthbWNoYXRrYSBrYXJlbGlhIGthemFuIGtjaHIga2VtZXJvdm8ga2hhYmFyb3ZzayBraGFrYXNzaWEga2h2IGtpcm92IGtvZW5pZyBrb21pIGtvc3Ryb21hIGtyYW5veWFyc2sga3ViYW4ga3VyZ2FuIGt1cnNrIGxpcGV0c2sgbWFnYWRhbiBtYXJpIG1hcmktZWwgbWFyaW5lIG1pbCBtb3Jkb3ZpYSBtb3NyZWcgbXNrIG11cm1hbnNrIG5hbGNoaWsgbmV0IG5ub3Ygbm92IG5vdm9zaWJpcnNrIG5zayBvbXNrIG9yZW5idXJnIG9yZyBvcnlvbCBwZW56YSBwZXJtIHBwIHBza292IHB0eiBybmQgcnlhemFuIHNha2hhbGluIHNhbWFyYSBzYXJhdG92IHNpbWJpcnNrIHNtb2xlbnNrIHNwYiBzdGF2cm9wb2wgc3R2IHN1cmd1dCB0YW1ib3YgdGF0YXJzdGFuIHRvbSB0b21zayB0c2FyaXRzeW4gdHNrIHR1bGEgdHV2YSB0dmVyIHR5dW1lbiB1ZG0gdWRtdXJ0aWEgdWxhbi11ZGUgdmxhZGlrYXZrYXogdmxhZGltaXIgdmxhZGl2b3N0b2sgdm9sZ29ncmFkIHZvbG9nZGEgdm9yb25lemggdnJuIHZ5YXRrYSB5YWt1dGlhIHlhbWFsIHlla2F0ZXJpbmJ1cmcgeXV6aG5vLXNha2hhbGluc2sgJyxcbiAgICAgICdydyc6JyBhYyBjbyBjb20gZWR1IGdvdXYgZ292IGludCBtaWwgbmV0ICcsXG4gICAgICAnc2EnOicgY29tIGVkdSBnb3YgbWVkIG5ldCBvcmcgcHViIHNjaCAnLFxuICAgICAgJ3NkJzonIGNvbSBlZHUgZ292IGluZm8gbWVkIG5ldCBvcmcgdHYgJyxcbiAgICAgICdzZSc6JyBhIGFjIGIgYmQgYyBkIGUgZiBnIGggaSBrIGwgbSBuIG8gb3JnIHAgcGFydGkgcHAgcHJlc3MgciBzIHQgdG0gdSB3IHggeSB6ICcsXG4gICAgICAnc2cnOicgY29tIGVkdSBnb3YgaWRuIG5ldCBvcmcgcGVyICcsXG4gICAgICAnc24nOicgYXJ0IGNvbSBlZHUgZ291diBvcmcgcGVyc28gdW5pdiAnLFxuICAgICAgJ3N5JzonIGNvbSBlZHUgZ292IG1pbCBuZXQgbmV3cyBvcmcgJyxcbiAgICAgICd0aCc6JyBhYyBjbyBnbyBpbiBtaSBuZXQgb3IgJyxcbiAgICAgICd0aic6JyBhYyBiaXogY28gY29tIGVkdSBnbyBnb3YgaW5mbyBpbnQgbWlsIG5hbWUgbmV0IG5pYyBvcmcgdGVzdCB3ZWIgJyxcbiAgICAgICd0bic6JyBhZ3JpbmV0IGNvbSBkZWZlbnNlIGVkdW5ldCBlbnMgZmluIGdvdiBpbmQgaW5mbyBpbnRsIG1pbmNvbSBuYXQgbmV0IG9yZyBwZXJzbyBybnJ0IHJucyBybnUgdG91cmlzbSAnLFxuICAgICAgJ3R6JzonIGFjIGNvIGdvIG5lIG9yICcsXG4gICAgICAndWEnOicgYml6IGNoZXJrYXNzeSBjaGVybmlnb3YgY2hlcm5vdnRzeSBjayBjbiBjbyBjb20gY3JpbWVhIGN2IGRuIGRuZXByb3BldHJvdnNrIGRvbmV0c2sgZHAgZWR1IGdvdiBpZiBpbiBpdmFuby1mcmFua2l2c2sga2gga2hhcmtvdiBraGVyc29uIGtobWVsbml0c2tpeSBraWV2IGtpcm92b2dyYWQga20ga3Iga3Mga3YgbGcgbHVnYW5zayBsdXRzayBsdml2IG1lIG1rIG5ldCBuaWtvbGFldiBvZCBvZGVzc2Egb3JnIHBsIHBvbHRhdmEgcHAgcm92bm8gcnYgc2ViYXN0b3BvbCBzdW15IHRlIHRlcm5vcGlsIHV6aGdvcm9kIHZpbm5pY2Egdm4gemFwb3Jpemh6aGUgemhpdG9taXIgenAgenQgJyxcbiAgICAgICd1Zyc6JyBhYyBjbyBnbyBuZSBvciBvcmcgc2MgJyxcbiAgICAgICd1ayc6JyBhYyBibCBicml0aXNoLWxpYnJhcnkgY28gY3ltIGdvdiBnb3Z0IGljbmV0IGpldCBsZWEgbHRkIG1lIG1pbCBtb2QgbmF0aW9uYWwtbGlicmFyeS1zY290bGFuZCBuZWwgbmV0IG5ocyBuaWMgbmxzIG9yZyBvcmduIHBhcmxpYW1lbnQgcGxjIHBvbGljZSBzY2ggc2NvdCBzb2MgJyxcbiAgICAgICd1cyc6JyBkbmkgZmVkIGlzYSBraWRzIG5zbiAnLFxuICAgICAgJ3V5JzonIGNvbSBlZHUgZ3ViIG1pbCBuZXQgb3JnICcsXG4gICAgICAndmUnOicgY28gY29tIGVkdSBnb2IgaW5mbyBtaWwgbmV0IG9yZyB3ZWIgJyxcbiAgICAgICd2aSc6JyBjbyBjb20gazEyIG5ldCBvcmcgJyxcbiAgICAgICd2bic6JyBhYyBiaXogY29tIGVkdSBnb3YgaGVhbHRoIGluZm8gaW50IG5hbWUgbmV0IG9yZyBwcm8gJyxcbiAgICAgICd5ZSc6JyBjbyBjb20gZ292IGx0ZCBtZSBuZXQgb3JnIHBsYyAnLFxuICAgICAgJ3l1JzonIGFjIGNvIGVkdSBnb3Ygb3JnICcsXG4gICAgICAnemEnOicgYWMgYWdyaWMgYWx0IGJvdXJzZSBjaXR5IGNvIGN5YmVybmV0IGRiIGVkdSBnb3YgZ3JvbmRhciBpYWNjZXNzIGltdCBpbmNhIGxhbmRlc2lnbiBsYXcgbWlsIG5ldCBuZ28gbmlzIG5vbSBvbGl2ZXR0aSBvcmcgcGl4IHNjaG9vbCB0bSB3ZWIgJyxcbiAgICAgICd6bSc6JyBhYyBjbyBjb20gZWR1IGdvdiBuZXQgb3JnIHNjaCAnLFxuICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbE5pYyNTZWNvbmQtbGV2ZWxfZG9tYWluc1xuICAgICAgJ2NvbSc6ICdhciBiciBjbiBkZSBldSBnYiBnciBodSBqcG4ga3Igbm8gcWMgcnUgc2Egc2UgdWsgdXMgdXkgemEgJyxcbiAgICAgICduZXQnOiAnZ2IganAgc2UgdWsgJyxcbiAgICAgICdvcmcnOiAnYWUnLFxuICAgICAgJ2RlJzogJ2NvbSAnXG4gICAgfSxcbiAgICAvLyBnb3JoaWxsIDIwMTMtMTAtMjU6IFVzaW5nIGluZGV4T2YoKSBpbnN0ZWFkIFJlZ2V4cCgpLiBTaWduaWZpY2FudCBib29zdFxuICAgIC8vIGluIGJvdGggcGVyZm9ybWFuY2UgYW5kIG1lbW9yeSBmb290cHJpbnQuIE5vIGluaXRpYWxpemF0aW9uIHJlcXVpcmVkLlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL3VyaS1qcy1zbGQtcmVnZXgtdnMtYmluYXJ5LXNlYXJjaC80XG4gICAgLy8gRm9sbG93aW5nIG1ldGhvZHMgdXNlIGxhc3RJbmRleE9mKCkgcmF0aGVyIHRoYW4gYXJyYXkuc3BsaXQoKSBpbiBvcmRlclxuICAgIC8vIHRvIGF2b2lkIGFueSBtZW1vcnkgYWxsb2NhdGlvbnMuXG4gICAgaGFzOiBmdW5jdGlvbihkb21haW4pIHtcbiAgICAgIHZhciB0bGRPZmZzZXQgPSBkb21haW4ubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIGlmICh0bGRPZmZzZXQgPD0gMCB8fCB0bGRPZmZzZXQgPj0gKGRvbWFpbi5sZW5ndGgtMSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHNsZE9mZnNldCA9IGRvbWFpbi5sYXN0SW5kZXhPZignLicsIHRsZE9mZnNldC0xKTtcbiAgICAgIGlmIChzbGRPZmZzZXQgPD0gMCB8fCBzbGRPZmZzZXQgPj0gKHRsZE9mZnNldC0xKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc2xkTGlzdCA9IFNMRC5saXN0W2RvbWFpbi5zbGljZSh0bGRPZmZzZXQrMSldO1xuICAgICAgaWYgKCFzbGRMaXN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGRMaXN0LmluZGV4T2YoJyAnICsgZG9tYWluLnNsaWNlKHNsZE9mZnNldCsxLCB0bGRPZmZzZXQpICsgJyAnKSA+PSAwO1xuICAgIH0sXG4gICAgaXM6IGZ1bmN0aW9uKGRvbWFpbikge1xuICAgICAgdmFyIHRsZE9mZnNldCA9IGRvbWFpbi5sYXN0SW5kZXhPZignLicpO1xuICAgICAgaWYgKHRsZE9mZnNldCA8PSAwIHx8IHRsZE9mZnNldCA+PSAoZG9tYWluLmxlbmd0aC0xKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc2xkT2Zmc2V0ID0gZG9tYWluLmxhc3RJbmRleE9mKCcuJywgdGxkT2Zmc2V0LTEpO1xuICAgICAgaWYgKHNsZE9mZnNldCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBzbGRMaXN0ID0gU0xELmxpc3RbZG9tYWluLnNsaWNlKHRsZE9mZnNldCsxKV07XG4gICAgICBpZiAoIXNsZExpc3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsZExpc3QuaW5kZXhPZignICcgKyBkb21haW4uc2xpY2UoMCwgdGxkT2Zmc2V0KSArICcgJykgPj0gMDtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgICB2YXIgdGxkT2Zmc2V0ID0gZG9tYWluLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICBpZiAodGxkT2Zmc2V0IDw9IDAgfHwgdGxkT2Zmc2V0ID49IChkb21haW4ubGVuZ3RoLTEpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHNsZE9mZnNldCA9IGRvbWFpbi5sYXN0SW5kZXhPZignLicsIHRsZE9mZnNldC0xKTtcbiAgICAgIGlmIChzbGRPZmZzZXQgPD0gMCB8fCBzbGRPZmZzZXQgPj0gKHRsZE9mZnNldC0xKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBzbGRMaXN0ID0gU0xELmxpc3RbZG9tYWluLnNsaWNlKHRsZE9mZnNldCsxKV07XG4gICAgICBpZiAoIXNsZExpc3QpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoc2xkTGlzdC5pbmRleE9mKCcgJyArIGRvbWFpbi5zbGljZShzbGRPZmZzZXQrMSwgdGxkT2Zmc2V0KSArICcgJykgPCAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbWFpbi5zbGljZShzbGRPZmZzZXQrMSk7XG4gICAgfSxcbiAgICBub0NvbmZsaWN0OiBmdW5jdGlvbigpe1xuICAgICAgaWYgKHJvb3QuU2Vjb25kTGV2ZWxEb21haW5zID09PSB0aGlzKSB7XG4gICAgICAgIHJvb3QuU2Vjb25kTGV2ZWxEb21haW5zID0gX1NlY29uZExldmVsRG9tYWlucztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU0xEO1xufSkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/urijs/src/SecondLevelDomains.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/urijs/src/URI.js":
/*!***************************************!*\
  !*** ./node_modules/urijs/src/URI.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * URI.js - Mutating URLs\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if ( true && module.exports) {\n    // Node\n    module.exports = factory(__webpack_require__(/*! ./punycode */ \"(ssr)/./node_modules/urijs/src/punycode.js\"), __webpack_require__(/*! ./IPv6 */ \"(ssr)/./node_modules/urijs/src/IPv6.js\"), __webpack_require__(/*! ./SecondLevelDomains */ \"(ssr)/./node_modules/urijs/src/SecondLevelDomains.js\"));\n  } else if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./punycode */ \"(ssr)/./node_modules/urijs/src/punycode.js\"), __webpack_require__(/*! ./IPv6 */ \"(ssr)/./node_modules/urijs/src/IPv6.js\"), __webpack_require__(/*! ./SecondLevelDomains */ \"(ssr)/./node_modules/urijs/src/SecondLevelDomains.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function (punycode, IPv6, SLD, root) {\n  'use strict';\n  /*global location, escape, unescape */\n  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n  /*jshint camelcase: false */\n\n  // save current URI variable, if any\n  var _URI = root && root.URI;\n\n  function URI(url, base) {\n    var _urlSupplied = arguments.length >= 1;\n    var _baseSupplied = arguments.length >= 2;\n\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof URI)) {\n      if (_urlSupplied) {\n        if (_baseSupplied) {\n          return new URI(url, base);\n        }\n\n        return new URI(url);\n      }\n\n      return new URI();\n    }\n\n    if (url === undefined) {\n      if (_urlSupplied) {\n        throw new TypeError('undefined is not a valid argument for URI');\n      }\n\n      if (typeof location !== 'undefined') {\n        url = location.href + '';\n      } else {\n        url = '';\n      }\n    }\n\n    if (url === null) {\n      if (_urlSupplied) {\n        throw new TypeError('null is not a valid argument for URI');\n      }\n    }\n\n    this.href(url);\n\n    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor\n    if (base !== undefined) {\n      return this.absoluteTo(base);\n    }\n\n    return this;\n  }\n\n  function isInteger(value) {\n    return /^[0-9]+$/.test(value);\n  }\n\n  URI.version = '1.19.11';\n\n  var p = URI.prototype;\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  function escapeRegEx(string) {\n    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963\n    return string.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  }\n\n  function getType(value) {\n    // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value\n    if (value === undefined) {\n      return 'Undefined';\n    }\n\n    return String(Object.prototype.toString.call(value)).slice(8, -1);\n  }\n\n  function isArray(obj) {\n    return getType(obj) === 'Array';\n  }\n\n  function filterArrayValues(data, value) {\n    var lookup = {};\n    var i, length;\n\n    if (getType(value) === 'RegExp') {\n      lookup = null;\n    } else if (isArray(value)) {\n      for (i = 0, length = value.length; i < length; i++) {\n        lookup[value[i]] = true;\n      }\n    } else {\n      lookup[value] = true;\n    }\n\n    for (i = 0, length = data.length; i < length; i++) {\n      /*jshint laxbreak: true */\n      var _match = lookup && lookup[data[i]] !== undefined\n        || !lookup && value.test(data[i]);\n      /*jshint laxbreak: false */\n      if (_match) {\n        data.splice(i, 1);\n        length--;\n        i--;\n      }\n    }\n\n    return data;\n  }\n\n  function arrayContains(list, value) {\n    var i, length;\n\n    // value may be string, number, array, regexp\n    if (isArray(value)) {\n      // Note: this can be optimized to O(n) (instead of current O(m * n))\n      for (i = 0, length = value.length; i < length; i++) {\n        if (!arrayContains(list, value[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    var _type = getType(value);\n    for (i = 0, length = list.length; i < length; i++) {\n      if (_type === 'RegExp') {\n        if (typeof list[i] === 'string' && list[i].match(value)) {\n          return true;\n        }\n      } else if (list[i] === value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function arraysEqual(one, two) {\n    if (!isArray(one) || !isArray(two)) {\n      return false;\n    }\n\n    // arrays can't be equal if they have different amount of content\n    if (one.length !== two.length) {\n      return false;\n    }\n\n    one.sort();\n    two.sort();\n\n    for (var i = 0, l = one.length; i < l; i++) {\n      if (one[i] !== two[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function trimSlashes(text) {\n    var trim_expression = /^\\/+|\\/+$/g;\n    return text.replace(trim_expression, '');\n  }\n\n  URI._parts = function() {\n    return {\n      protocol: null,\n      username: null,\n      password: null,\n      hostname: null,\n      urn: null,\n      port: null,\n      path: null,\n      query: null,\n      fragment: null,\n      // state\n      preventInvalidHostname: URI.preventInvalidHostname,\n      duplicateQueryParameters: URI.duplicateQueryParameters,\n      escapeQuerySpace: URI.escapeQuerySpace\n    };\n  };\n  // state: throw on invalid hostname\n  // see https://github.com/medialize/URI.js/pull/345\n  // and https://github.com/medialize/URI.js/issues/354\n  URI.preventInvalidHostname = false;\n  // state: allow duplicate query parameters (a=1&a=1)\n  URI.duplicateQueryParameters = false;\n  // state: replaces + with %20 (space in query strings)\n  URI.escapeQuerySpace = true;\n  // static properties\n  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;\n  URI.idn_expression = /[^a-z0-9\\._-]/i;\n  URI.punycode_expression = /(xn--)/i;\n  // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?\n  URI.ip4_expression = /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/;\n  // credits to Rich Brown\n  // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096\n  // specification: http://www.ietf.org/rfc/rfc4291.txt\n  URI.ip6_expression = /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/;\n  // expression used is \"gruber revised\" (@gruber v2) determined to be the\n  // best solution in a regex-golf we did a couple of ages ago at\n  // * http://mathiasbynens.be/demo/url-regex\n  // * http://rodneyrehm.de/t/url-regex.html\n  URI.find_uri_expression = /\\b((?:[a-z][\\w-]+:(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?«»“”‘’]))/ig;\n  URI.findUri = {\n    // valid \"scheme://\" or \"www.\"\n    start: /\\b(?:([a-z][a-z0-9.+-]*:\\/\\/)|www\\.)/gi,\n    // everything up to the next whitespace\n    end: /[\\s\\r\\n]|$/,\n    // trim trailing punctuation captured by end RegExp\n    trim: /[`!()\\[\\]{};:'\".,<>?«»“”„‘’]+$/,\n    // balanced parens inclusion (), [], {}, <>\n    parens: /(\\([^\\)]*\\)|\\[[^\\]]*\\]|\\{[^}]*\\}|<[^>]*>)/g,\n  };\n  URI.leading_whitespace_expression = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/\n  // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n  URI.ascii_tab_whitespace = /[\\u0009\\u000A\\u000D]+/g\n  // http://www.iana.org/assignments/uri-schemes.html\n  // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports\n  URI.defaultPorts = {\n    http: '80',\n    https: '443',\n    ftp: '21',\n    gopher: '70',\n    ws: '80',\n    wss: '443'\n  };\n  // list of protocols which always require a hostname\n  URI.hostProtocols = [\n    'http',\n    'https'\n  ];\n\n  // allowed hostname characters according to RFC 3986\n  // ALPHA DIGIT \"-\" \".\" \"_\" \"~\" \"!\" \"$\" \"&\" \"'\" \"(\" \")\" \"*\" \"+\" \",\" \";\" \"=\" %encoded\n  // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . - _\n  URI.invalid_hostname_characters = /[^a-zA-Z0-9\\.\\-:_]/;\n  // map DOM Elements to their URI attribute\n  URI.domAttributes = {\n    'a': 'href',\n    'blockquote': 'cite',\n    'link': 'href',\n    'base': 'href',\n    'script': 'src',\n    'form': 'action',\n    'img': 'src',\n    'area': 'href',\n    'iframe': 'src',\n    'embed': 'src',\n    'source': 'src',\n    'track': 'src',\n    'input': 'src', // but only if type=\"image\"\n    'audio': 'src',\n    'video': 'src'\n  };\n  URI.getDomAttribute = function(node) {\n    if (!node || !node.nodeName) {\n      return undefined;\n    }\n\n    var nodeName = node.nodeName.toLowerCase();\n    // <input> should only expose src for type=\"image\"\n    if (nodeName === 'input' && node.type !== 'image') {\n      return undefined;\n    }\n\n    return URI.domAttributes[nodeName];\n  };\n\n  function escapeForDumbFirefox36(value) {\n    // https://github.com/medialize/URI.js/issues/91\n    return escape(value);\n  }\n\n  // encoding / decoding according to RFC3986\n  function strictEncodeURIComponent(string) {\n    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent\n    return encodeURIComponent(string)\n      .replace(/[!'()*]/g, escapeForDumbFirefox36)\n      .replace(/\\*/g, '%2A');\n  }\n  URI.encode = strictEncodeURIComponent;\n  URI.decode = decodeURIComponent;\n  URI.iso8859 = function() {\n    URI.encode = escape;\n    URI.decode = unescape;\n  };\n  URI.unicode = function() {\n    URI.encode = strictEncodeURIComponent;\n    URI.decode = decodeURIComponent;\n  };\n  URI.characters = {\n    pathname: {\n      encode: {\n        // RFC3986 2.1: For consistency, URI producers and normalizers should\n        // use uppercase hexadecimal digits for all percent-encodings.\n        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,\n        map: {\n          // -._~!'()*\n          '%24': '$',\n          '%26': '&',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '=',\n          '%3A': ':',\n          '%40': '@'\n        }\n      },\n      decode: {\n        expression: /[\\/\\?#]/g,\n        map: {\n          '/': '%2F',\n          '?': '%3F',\n          '#': '%23'\n        }\n      }\n    },\n    reserved: {\n      encode: {\n        // RFC3986 2.1: For consistency, URI producers and normalizers should\n        // use uppercase hexadecimal digits for all percent-encodings.\n        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,\n        map: {\n          // gen-delims\n          '%3A': ':',\n          '%2F': '/',\n          '%3F': '?',\n          '%23': '#',\n          '%5B': '[',\n          '%5D': ']',\n          '%40': '@',\n          // sub-delims\n          '%21': '!',\n          '%24': '$',\n          '%26': '&',\n          '%27': '\\'',\n          '%28': '(',\n          '%29': ')',\n          '%2A': '*',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '='\n        }\n      }\n    },\n    urnpath: {\n      // The characters under `encode` are the characters called out by RFC 2141 as being acceptable\n      // for usage in a URN. RFC2141 also calls out \"-\", \".\", and \"_\" as acceptable characters, but\n      // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also\n      // note that the colon character is not featured in the encoding map; this is because URI.js\n      // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it\n      // should not appear unencoded in a segment itself.\n      // See also the note above about RFC3986 and capitalalized hex digits.\n      encode: {\n        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,\n        map: {\n          '%21': '!',\n          '%24': '$',\n          '%27': '\\'',\n          '%28': '(',\n          '%29': ')',\n          '%2A': '*',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '=',\n          '%40': '@'\n        }\n      },\n      // These characters are the characters called out by RFC2141 as \"reserved\" characters that\n      // should never appear in a URN, plus the colon character (see note above).\n      decode: {\n        expression: /[\\/\\?#:]/g,\n        map: {\n          '/': '%2F',\n          '?': '%3F',\n          '#': '%23',\n          ':': '%3A'\n        }\n      }\n    }\n  };\n  URI.encodeQuery = function(string, escapeQuerySpace) {\n    var escaped = URI.encode(string + '');\n    if (escapeQuerySpace === undefined) {\n      escapeQuerySpace = URI.escapeQuerySpace;\n    }\n\n    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;\n  };\n  URI.decodeQuery = function(string, escapeQuerySpace) {\n    string += '';\n    if (escapeQuerySpace === undefined) {\n      escapeQuerySpace = URI.escapeQuerySpace;\n    }\n\n    try {\n      return URI.decode(escapeQuerySpace ? string.replace(/\\+/g, '%20') : string);\n    } catch(e) {\n      // we're not going to mess with weird encodings,\n      // give up and return the undecoded original string\n      // see https://github.com/medialize/URI.js/issues/87\n      // see https://github.com/medialize/URI.js/issues/92\n      return string;\n    }\n  };\n  // generate encode/decode path functions\n  var _parts = {'encode':'encode', 'decode':'decode'};\n  var _part;\n  var generateAccessor = function(_group, _part) {\n    return function(string) {\n      try {\n        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {\n          return URI.characters[_group][_part].map[c];\n        });\n      } catch (e) {\n        // we're not going to mess with weird encodings,\n        // give up and return the undecoded original string\n        // see https://github.com/medialize/URI.js/issues/87\n        // see https://github.com/medialize/URI.js/issues/92\n        return string;\n      }\n    };\n  };\n\n  for (_part in _parts) {\n    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);\n    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);\n  }\n\n  var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {\n    return function(string) {\n      // Why pass in names of functions, rather than the function objects themselves? The\n      // definitions of some functions (but in particular, URI.decode) will occasionally change due\n      // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure\n      // that the functions we use here are \"fresh\".\n      var actualCodingFunc;\n      if (!_innerCodingFuncName) {\n        actualCodingFunc = URI[_codingFuncName];\n      } else {\n        actualCodingFunc = function(string) {\n          return URI[_codingFuncName](URI[_innerCodingFuncName](string));\n        };\n      }\n\n      var segments = (string + '').split(_sep);\n\n      for (var i = 0, length = segments.length; i < length; i++) {\n        segments[i] = actualCodingFunc(segments[i]);\n      }\n\n      return segments.join(_sep);\n    };\n  };\n\n  // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.\n  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');\n  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');\n  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');\n  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');\n\n  URI.encodeReserved = generateAccessor('reserved', 'encode');\n\n  URI.parse = function(string, parts) {\n    var pos;\n    if (!parts) {\n      parts = {\n        preventInvalidHostname: URI.preventInvalidHostname\n      };\n    }\n\n    string = string.replace(URI.leading_whitespace_expression, '')\n    // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n    string = string.replace(URI.ascii_tab_whitespace, '')\n\n    // [protocol\"://\"[username[\":\"password]\"@\"]hostname[\":\"port]\"/\"?][path][\"?\"querystring][\"#\"fragment]\n\n    // extract fragment\n    pos = string.indexOf('#');\n    if (pos > -1) {\n      // escaping?\n      parts.fragment = string.substring(pos + 1) || null;\n      string = string.substring(0, pos);\n    }\n\n    // extract query\n    pos = string.indexOf('?');\n    if (pos > -1) {\n      // escaping?\n      parts.query = string.substring(pos + 1) || null;\n      string = string.substring(0, pos);\n    }\n\n    // slashes and backslashes have lost all meaning for the web protocols (https, http, wss, ws)\n    string = string.replace(/^(https?|ftp|wss?)?:+[/\\\\]*/i, '$1://');\n    // slashes and backslashes have lost all meaning for scheme relative URLs\n    string = string.replace(/^[/\\\\]{2,}/i, '//');\n\n    // extract protocol\n    if (string.substring(0, 2) === '//') {\n      // relative-scheme\n      parts.protocol = null;\n      string = string.substring(2);\n      // extract \"user:pass@host:port\"\n      string = URI.parseAuthority(string, parts);\n    } else {\n      pos = string.indexOf(':');\n      if (pos > -1) {\n        parts.protocol = string.substring(0, pos) || null;\n        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {\n          // : may be within the path\n          parts.protocol = undefined;\n        } else if (string.substring(pos + 1, pos + 3).replace(/\\\\/g, '/') === '//') {\n          string = string.substring(pos + 3);\n\n          // extract \"user:pass@host:port\"\n          string = URI.parseAuthority(string, parts);\n        } else {\n          string = string.substring(pos + 1);\n          parts.urn = true;\n        }\n      }\n    }\n\n    // what's left must be the path\n    parts.path = string;\n\n    // and we're done\n    return parts;\n  };\n  URI.parseHost = function(string, parts) {\n    if (!string) {\n      string = '';\n    }\n\n    // Copy chrome, IE, opera backslash-handling behavior.\n    // Back slashes before the query string get converted to forward slashes\n    // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124\n    // See: https://code.google.com/p/chromium/issues/detail?id=25916\n    // https://github.com/medialize/URI.js/pull/233\n    string = string.replace(/\\\\/g, '/');\n\n    // extract host:port\n    var pos = string.indexOf('/');\n    var bracketPos;\n    var t;\n\n    if (pos === -1) {\n      pos = string.length;\n    }\n\n    if (string.charAt(0) === '[') {\n      // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6\n      // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts\n      // IPv6+port in the format [2001:db8::1]:80 (for the time being)\n      bracketPos = string.indexOf(']');\n      parts.hostname = string.substring(1, bracketPos) || null;\n      parts.port = string.substring(bracketPos + 2, pos) || null;\n      if (parts.port === '/') {\n        parts.port = null;\n      }\n    } else {\n      var firstColon = string.indexOf(':');\n      var firstSlash = string.indexOf('/');\n      var nextColon = string.indexOf(':', firstColon + 1);\n      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {\n        // IPv6 host contains multiple colons - but no port\n        // this notation is actually not allowed by RFC 3986, but we're a liberal parser\n        parts.hostname = string.substring(0, pos) || null;\n        parts.port = null;\n      } else {\n        t = string.substring(0, pos).split(':');\n        parts.hostname = t[0] || null;\n        parts.port = t[1] || null;\n      }\n    }\n\n    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {\n      pos++;\n      string = '/' + string;\n    }\n\n    if (parts.preventInvalidHostname) {\n      URI.ensureValidHostname(parts.hostname, parts.protocol);\n    }\n\n    if (parts.port) {\n      URI.ensureValidPort(parts.port);\n    }\n\n    return string.substring(pos) || '/';\n  };\n  URI.parseAuthority = function(string, parts) {\n    string = URI.parseUserinfo(string, parts);\n    return URI.parseHost(string, parts);\n  };\n  URI.parseUserinfo = function(string, parts) {\n    // extract username:password\n    var _string = string\n    var firstBackSlash = string.indexOf('\\\\');\n    if (firstBackSlash !== -1) {\n      string = string.replace(/\\\\/g, '/')\n    }\n    var firstSlash = string.indexOf('/');\n    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);\n    var t;\n\n    // authority@ must come before /path or \\path\n    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {\n      t = string.substring(0, pos).split(':');\n      parts.username = t[0] ? URI.decode(t[0]) : null;\n      t.shift();\n      parts.password = t[0] ? URI.decode(t.join(':')) : null;\n      string = _string.substring(pos + 1);\n    } else {\n      parts.username = null;\n      parts.password = null;\n    }\n\n    return string;\n  };\n  URI.parseQuery = function(string, escapeQuerySpace) {\n    if (!string) {\n      return {};\n    }\n\n    // throw out the funky business - \"?\"[name\"=\"value\"&\"]+\n    string = string.replace(/&+/g, '&').replace(/^\\?*&*|&+$/g, '');\n\n    if (!string) {\n      return {};\n    }\n\n    var items = {};\n    var splits = string.split('&');\n    var length = splits.length;\n    var v, name, value;\n\n    for (var i = 0; i < length; i++) {\n      v = splits[i].split('=');\n      name = URI.decodeQuery(v.shift(), escapeQuerySpace);\n      // no \"=\" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters\n      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;\n\n      if (name === '__proto__') {\n        // ignore attempt at exploiting JavaScript internals\n        continue;\n      } else if (hasOwn.call(items, name)) {\n        if (typeof items[name] === 'string' || items[name] === null) {\n          items[name] = [items[name]];\n        }\n\n        items[name].push(value);\n      } else {\n        items[name] = value;\n      }\n    }\n\n    return items;\n  };\n\n  URI.build = function(parts) {\n    var t = '';\n    var requireAbsolutePath = false\n\n    if (parts.protocol) {\n      t += parts.protocol + ':';\n    }\n\n    if (!parts.urn && (t || parts.hostname)) {\n      t += '//';\n      requireAbsolutePath = true\n    }\n\n    t += (URI.buildAuthority(parts) || '');\n\n    if (typeof parts.path === 'string') {\n      if (parts.path.charAt(0) !== '/' && requireAbsolutePath) {\n        t += '/';\n      }\n\n      t += parts.path;\n    }\n\n    if (typeof parts.query === 'string' && parts.query) {\n      t += '?' + parts.query;\n    }\n\n    if (typeof parts.fragment === 'string' && parts.fragment) {\n      t += '#' + parts.fragment;\n    }\n    return t;\n  };\n  URI.buildHost = function(parts) {\n    var t = '';\n\n    if (!parts.hostname) {\n      return '';\n    } else if (URI.ip6_expression.test(parts.hostname)) {\n      t += '[' + parts.hostname + ']';\n    } else {\n      t += parts.hostname;\n    }\n\n    if (parts.port) {\n      t += ':' + parts.port;\n    }\n\n    return t;\n  };\n  URI.buildAuthority = function(parts) {\n    return URI.buildUserinfo(parts) + URI.buildHost(parts);\n  };\n  URI.buildUserinfo = function(parts) {\n    var t = '';\n\n    if (parts.username) {\n      t += URI.encode(parts.username);\n    }\n\n    if (parts.password) {\n      t += ':' + URI.encode(parts.password);\n    }\n\n    if (t) {\n      t += '@';\n    }\n\n    return t;\n  };\n  URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {\n    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html\n    // being »-._~!$&'()*+,;=:@/?« %HEX and alnum are allowed\n    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!\n    // URI.js treats the query string as being application/x-www-form-urlencoded\n    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type\n\n    var t = '';\n    var unique, key, i, length;\n    for (key in data) {\n      if (key === '__proto__') {\n        // ignore attempt at exploiting JavaScript internals\n        continue;\n      } else if (hasOwn.call(data, key)) {\n        if (isArray(data[key])) {\n          unique = {};\n          for (i = 0, length = data[key].length; i < length; i++) {\n            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {\n              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);\n              if (duplicateQueryParameters !== true) {\n                unique[data[key][i] + ''] = true;\n              }\n            }\n          }\n        } else if (data[key] !== undefined) {\n          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);\n        }\n      }\n    }\n\n    return t.substring(1);\n  };\n  URI.buildQueryParameter = function(name, value, escapeQuerySpace) {\n    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded\n    // don't append \"=\" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization\n    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');\n  };\n\n  URI.addQuery = function(data, name, value) {\n    if (typeof name === 'object') {\n      for (var key in name) {\n        if (hasOwn.call(name, key)) {\n          URI.addQuery(data, key, name[key]);\n        }\n      }\n    } else if (typeof name === 'string') {\n      if (data[name] === undefined) {\n        data[name] = value;\n        return;\n      } else if (typeof data[name] === 'string') {\n        data[name] = [data[name]];\n      }\n\n      if (!isArray(value)) {\n        value = [value];\n      }\n\n      data[name] = (data[name] || []).concat(value);\n    } else {\n      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');\n    }\n  };\n\n  URI.setQuery = function(data, name, value) {\n    if (typeof name === 'object') {\n      for (var key in name) {\n        if (hasOwn.call(name, key)) {\n          URI.setQuery(data, key, name[key]);\n        }\n      }\n    } else if (typeof name === 'string') {\n      data[name] = value === undefined ? null : value;\n    } else {\n      throw new TypeError('URI.setQuery() accepts an object, string as the name parameter');\n    }\n  };\n\n  URI.removeQuery = function(data, name, value) {\n    var i, length, key;\n\n    if (isArray(name)) {\n      for (i = 0, length = name.length; i < length; i++) {\n        data[name[i]] = undefined;\n      }\n    } else if (getType(name) === 'RegExp') {\n      for (key in data) {\n        if (name.test(key)) {\n          data[key] = undefined;\n        }\n      }\n    } else if (typeof name === 'object') {\n      for (key in name) {\n        if (hasOwn.call(name, key)) {\n          URI.removeQuery(data, key, name[key]);\n        }\n      }\n    } else if (typeof name === 'string') {\n      if (value !== undefined) {\n        if (getType(value) === 'RegExp') {\n          if (!isArray(data[name]) && value.test(data[name])) {\n            data[name] = undefined;\n          } else {\n            data[name] = filterArrayValues(data[name], value);\n          }\n        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {\n          data[name] = undefined;\n        } else if (isArray(data[name])) {\n          data[name] = filterArrayValues(data[name], value);\n        }\n      } else {\n        data[name] = undefined;\n      }\n    } else {\n      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');\n    }\n  };\n  URI.hasQuery = function(data, name, value, withinArray) {\n    switch (getType(name)) {\n      case 'String':\n        // Nothing to do here\n        break;\n\n      case 'RegExp':\n        for (var key in data) {\n          if (hasOwn.call(data, key)) {\n            if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n\n      case 'Object':\n        for (var _key in name) {\n          if (hasOwn.call(name, _key)) {\n            if (!URI.hasQuery(data, _key, name[_key])) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n\n      default:\n        throw new TypeError('URI.hasQuery() accepts a string, regular expression or object as the name parameter');\n    }\n\n    switch (getType(value)) {\n      case 'Undefined':\n        // true if exists (but may be empty)\n        return name in data; // data[name] !== undefined;\n\n      case 'Boolean':\n        // true if exists and non-empty\n        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);\n        return value === _booly;\n\n      case 'Function':\n        // allow complex comparison\n        return !!value(data[name], name, data);\n\n      case 'Array':\n        if (!isArray(data[name])) {\n          return false;\n        }\n\n        var op = withinArray ? arrayContains : arraysEqual;\n        return op(data[name], value);\n\n      case 'RegExp':\n        if (!isArray(data[name])) {\n          return Boolean(data[name] && data[name].match(value));\n        }\n\n        if (!withinArray) {\n          return false;\n        }\n\n        return arrayContains(data[name], value);\n\n      case 'Number':\n        value = String(value);\n        /* falls through */\n      case 'String':\n        if (!isArray(data[name])) {\n          return data[name] === value;\n        }\n\n        if (!withinArray) {\n          return false;\n        }\n\n        return arrayContains(data[name], value);\n\n      default:\n        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');\n    }\n  };\n\n\n  URI.joinPaths = function() {\n    var input = [];\n    var segments = [];\n    var nonEmptySegments = 0;\n\n    for (var i = 0; i < arguments.length; i++) {\n      var url = new URI(arguments[i]);\n      input.push(url);\n      var _segments = url.segment();\n      for (var s = 0; s < _segments.length; s++) {\n        if (typeof _segments[s] === 'string') {\n          segments.push(_segments[s]);\n        }\n\n        if (_segments[s]) {\n          nonEmptySegments++;\n        }\n      }\n    }\n\n    if (!segments.length || !nonEmptySegments) {\n      return new URI('');\n    }\n\n    var uri = new URI('').segment(segments);\n\n    if (input[0].path() === '' || input[0].path().slice(0, 1) === '/') {\n      uri.path('/' + uri.path());\n    }\n\n    return uri.normalize();\n  };\n\n  URI.commonPath = function(one, two) {\n    var length = Math.min(one.length, two.length);\n    var pos;\n\n    // find first non-matching character\n    for (pos = 0; pos < length; pos++) {\n      if (one.charAt(pos) !== two.charAt(pos)) {\n        pos--;\n        break;\n      }\n    }\n\n    if (pos < 1) {\n      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';\n    }\n\n    // revert to last /\n    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {\n      pos = one.substring(0, pos).lastIndexOf('/');\n    }\n\n    return one.substring(0, pos + 1);\n  };\n\n  URI.withinString = function(string, callback, options) {\n    options || (options = {});\n    var _start = options.start || URI.findUri.start;\n    var _end = options.end || URI.findUri.end;\n    var _trim = options.trim || URI.findUri.trim;\n    var _parens = options.parens || URI.findUri.parens;\n    var _attributeOpen = /[a-z0-9-]=[\"']?$/i;\n\n    _start.lastIndex = 0;\n    while (true) {\n      var match = _start.exec(string);\n      if (!match) {\n        break;\n      }\n\n      var start = match.index;\n      if (options.ignoreHtml) {\n        // attribut(e=[\"']?$)\n        var attributeOpen = string.slice(Math.max(start - 3, 0), start);\n        if (attributeOpen && _attributeOpen.test(attributeOpen)) {\n          continue;\n        }\n      }\n\n      var end = start + string.slice(start).search(_end);\n      var slice = string.slice(start, end);\n      // make sure we include well balanced parens\n      var parensEnd = -1;\n      while (true) {\n        var parensMatch = _parens.exec(slice);\n        if (!parensMatch) {\n          break;\n        }\n\n        var parensMatchEnd = parensMatch.index + parensMatch[0].length;\n        parensEnd = Math.max(parensEnd, parensMatchEnd);\n      }\n\n      if (parensEnd > -1) {\n        slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, '');\n      } else {\n        slice = slice.replace(_trim, '');\n      }\n\n      if (slice.length <= match[0].length) {\n        // the extract only contains the starting marker of a URI,\n        // e.g. \"www\" or \"http://\"\n        continue;\n      }\n\n      if (options.ignore && options.ignore.test(slice)) {\n        continue;\n      }\n\n      end = start + slice.length;\n      var result = callback(slice, start, end, string);\n      if (result === undefined) {\n        _start.lastIndex = end;\n        continue;\n      }\n\n      result = String(result);\n      string = string.slice(0, start) + result + string.slice(end);\n      _start.lastIndex = start + result.length;\n    }\n\n    _start.lastIndex = 0;\n    return string;\n  };\n\n  URI.ensureValidHostname = function(v, protocol) {\n    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)\n    // they are not part of DNS and therefore ignored by URI.js\n\n    var hasHostname = !!v; // not null and not an empty string\n    var hasProtocol = !!protocol;\n    var rejectEmptyHostname = false;\n\n    if (hasProtocol) {\n      rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);\n    }\n\n    if (rejectEmptyHostname && !hasHostname) {\n      throw new TypeError('Hostname cannot be empty, if protocol is ' + protocol);\n    } else if (v && v.match(URI.invalid_hostname_characters)) {\n      // test punycode\n      if (!punycode) {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');\n      }\n      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-:_]');\n      }\n    }\n  };\n\n  URI.ensureValidPort = function (v) {\n    if (!v) {\n      return;\n    }\n\n    var port = Number(v);\n    if (isInteger(port) && (port > 0) && (port < 65536)) {\n      return;\n    }\n\n    throw new TypeError('Port \"' + v + '\" is not a valid port');\n  };\n\n  // noConflict\n  URI.noConflict = function(removeAll) {\n    if (removeAll) {\n      var unconflicted = {\n        URI: this.noConflict()\n      };\n\n      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {\n        unconflicted.URITemplate = root.URITemplate.noConflict();\n      }\n\n      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {\n        unconflicted.IPv6 = root.IPv6.noConflict();\n      }\n\n      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {\n        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();\n      }\n\n      return unconflicted;\n    } else if (root.URI === this) {\n      root.URI = _URI;\n    }\n\n    return this;\n  };\n\n  p.build = function(deferBuild) {\n    if (deferBuild === true) {\n      this._deferred_build = true;\n    } else if (deferBuild === undefined || this._deferred_build) {\n      this._string = URI.build(this._parts);\n      this._deferred_build = false;\n    }\n\n    return this;\n  };\n\n  p.clone = function() {\n    return new URI(this);\n  };\n\n  p.valueOf = p.toString = function() {\n    return this.build(false)._string;\n  };\n\n\n  function generateSimpleAccessor(_part){\n    return function(v, build) {\n      if (v === undefined) {\n        return this._parts[_part] || '';\n      } else {\n        this._parts[_part] = v || null;\n        this.build(!build);\n        return this;\n      }\n    };\n  }\n\n  function generatePrefixAccessor(_part, _key){\n    return function(v, build) {\n      if (v === undefined) {\n        return this._parts[_part] || '';\n      } else {\n        if (v !== null) {\n          v = v + '';\n          if (v.charAt(0) === _key) {\n            v = v.substring(1);\n          }\n        }\n\n        this._parts[_part] = v;\n        this.build(!build);\n        return this;\n      }\n    };\n  }\n\n  p.protocol = generateSimpleAccessor('protocol');\n  p.username = generateSimpleAccessor('username');\n  p.password = generateSimpleAccessor('password');\n  p.hostname = generateSimpleAccessor('hostname');\n  p.port = generateSimpleAccessor('port');\n  p.query = generatePrefixAccessor('query', '?');\n  p.fragment = generatePrefixAccessor('fragment', '#');\n\n  p.search = function(v, build) {\n    var t = this.query(v, build);\n    return typeof t === 'string' && t.length ? ('?' + t) : t;\n  };\n  p.hash = function(v, build) {\n    var t = this.fragment(v, build);\n    return typeof t === 'string' && t.length ? ('#' + t) : t;\n  };\n\n  p.pathname = function(v, build) {\n    if (v === undefined || v === true) {\n      var res = this._parts.path || (this._parts.hostname ? '/' : '');\n      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;\n    } else {\n      if (this._parts.urn) {\n        this._parts.path = v ? URI.recodeUrnPath(v) : '';\n      } else {\n        this._parts.path = v ? URI.recodePath(v) : '/';\n      }\n      this.build(!build);\n      return this;\n    }\n  };\n  p.path = p.pathname;\n  p.href = function(href, build) {\n    var key;\n\n    if (href === undefined) {\n      return this.toString();\n    }\n\n    this._string = '';\n    this._parts = URI._parts();\n\n    var _URI = href instanceof URI;\n    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);\n    if (href.nodeName) {\n      var attribute = URI.getDomAttribute(href);\n      href = href[attribute] || '';\n      _object = false;\n    }\n\n    // window.location is reported to be an object, but it's not the sort\n    // of object we're looking for:\n    // * location.protocol ends with a colon\n    // * location.query != object.search\n    // * location.hash != object.fragment\n    // simply serializing the unknown object should do the trick\n    // (for location, not for everything...)\n    if (!_URI && _object && href.pathname !== undefined) {\n      href = href.toString();\n    }\n\n    if (typeof href === 'string' || href instanceof String) {\n      this._parts = URI.parse(String(href), this._parts);\n    } else if (_URI || _object) {\n      var src = _URI ? href._parts : href;\n      for (key in src) {\n        if (key === 'query') { continue; }\n        if (hasOwn.call(this._parts, key)) {\n          this._parts[key] = src[key];\n        }\n      }\n      if (src.query) {\n        this.query(src.query, false);\n      }\n    } else {\n      throw new TypeError('invalid input');\n    }\n\n    this.build(!build);\n    return this;\n  };\n\n  // identification accessors\n  p.is = function(what) {\n    var ip = false;\n    var ip4 = false;\n    var ip6 = false;\n    var name = false;\n    var sld = false;\n    var idn = false;\n    var punycode = false;\n    var relative = !this._parts.urn;\n\n    if (this._parts.hostname) {\n      relative = false;\n      ip4 = URI.ip4_expression.test(this._parts.hostname);\n      ip6 = URI.ip6_expression.test(this._parts.hostname);\n      ip = ip4 || ip6;\n      name = !ip;\n      sld = name && SLD && SLD.has(this._parts.hostname);\n      idn = name && URI.idn_expression.test(this._parts.hostname);\n      punycode = name && URI.punycode_expression.test(this._parts.hostname);\n    }\n\n    switch (what.toLowerCase()) {\n      case 'relative':\n        return relative;\n\n      case 'absolute':\n        return !relative;\n\n      // hostname identification\n      case 'domain':\n      case 'name':\n        return name;\n\n      case 'sld':\n        return sld;\n\n      case 'ip':\n        return ip;\n\n      case 'ip4':\n      case 'ipv4':\n      case 'inet4':\n        return ip4;\n\n      case 'ip6':\n      case 'ipv6':\n      case 'inet6':\n        return ip6;\n\n      case 'idn':\n        return idn;\n\n      case 'url':\n        return !this._parts.urn;\n\n      case 'urn':\n        return !!this._parts.urn;\n\n      case 'punycode':\n        return punycode;\n    }\n\n    return null;\n  };\n\n  // component specific input validation\n  var _protocol = p.protocol;\n  var _port = p.port;\n  var _hostname = p.hostname;\n\n  p.protocol = function(v, build) {\n    if (v) {\n      // accept trailing ://\n      v = v.replace(/:(\\/\\/)?$/, '');\n\n      if (!v.match(URI.protocol_expression)) {\n        throw new TypeError('Protocol \"' + v + '\" contains characters other than [A-Z0-9.+-] or doesn\\'t start with [A-Z]');\n      }\n    }\n\n    return _protocol.call(this, v, build);\n  };\n  p.scheme = p.protocol;\n  p.port = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v !== undefined) {\n      if (v === 0) {\n        v = null;\n      }\n\n      if (v) {\n        v += '';\n        if (v.charAt(0) === ':') {\n          v = v.substring(1);\n        }\n\n        URI.ensureValidPort(v);\n      }\n    }\n    return _port.call(this, v, build);\n  };\n  p.hostname = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v !== undefined) {\n      var x = { preventInvalidHostname: this._parts.preventInvalidHostname };\n      var res = URI.parseHost(v, x);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      v = x.hostname;\n      if (this._parts.preventInvalidHostname) {\n        URI.ensureValidHostname(v, this._parts.protocol);\n      }\n    }\n\n    return _hostname.call(this, v, build);\n  };\n\n  // compound accessors\n  p.origin = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      var protocol = this.protocol();\n      var authority = this.authority();\n      if (!authority) {\n        return '';\n      }\n\n      return (protocol ? protocol + '://' : '') + this.authority();\n    } else {\n      var origin = URI(v);\n      this\n        .protocol(origin.protocol())\n        .authority(origin.authority())\n        .build(!build);\n      return this;\n    }\n  };\n  p.host = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      return this._parts.hostname ? URI.buildHost(this._parts) : '';\n    } else {\n      var res = URI.parseHost(v, this._parts);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.authority = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';\n    } else {\n      var res = URI.parseAuthority(v, this._parts);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.userinfo = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      var t = URI.buildUserinfo(this._parts);\n      return t ? t.substring(0, t.length -1) : t;\n    } else {\n      if (v[v.length-1] !== '@') {\n        v += '@';\n      }\n\n      URI.parseUserinfo(v, this._parts);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.resource = function(v, build) {\n    var parts;\n\n    if (v === undefined) {\n      return this.path() + this.search() + this.hash();\n    }\n\n    parts = URI.parse(v);\n    this._parts.path = parts.path;\n    this._parts.query = parts.query;\n    this._parts.fragment = parts.fragment;\n    this.build(!build);\n    return this;\n  };\n\n  // fraction accessors\n  p.subdomain = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    // convenience, return \"www\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      // grab domain and add another segment\n      var end = this._parts.hostname.length - this.domain().length - 1;\n      return this._parts.hostname.substring(0, end) || '';\n    } else {\n      var e = this._parts.hostname.length - this.domain().length;\n      var sub = this._parts.hostname.substring(0, e);\n      var replace = new RegExp('^' + escapeRegEx(sub));\n\n      if (v && v.charAt(v.length - 1) !== '.') {\n        v += '.';\n      }\n\n      if (v.indexOf(':') !== -1) {\n        throw new TypeError('Domains cannot contain colons');\n      }\n\n      if (v) {\n        URI.ensureValidHostname(v, this._parts.protocol);\n      }\n\n      this._parts.hostname = this._parts.hostname.replace(replace, v);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.domain = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (typeof v === 'boolean') {\n      build = v;\n      v = undefined;\n    }\n\n    // convenience, return \"example.org\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      // if hostname consists of 1 or 2 segments, it must be the domain\n      var t = this._parts.hostname.match(/\\./g);\n      if (t && t.length < 2) {\n        return this._parts.hostname;\n      }\n\n      // grab tld and add another segment\n      var end = this._parts.hostname.length - this.tld(build).length - 1;\n      end = this._parts.hostname.lastIndexOf('.', end -1) + 1;\n      return this._parts.hostname.substring(end) || '';\n    } else {\n      if (!v) {\n        throw new TypeError('cannot set domain empty');\n      }\n\n      if (v.indexOf(':') !== -1) {\n        throw new TypeError('Domains cannot contain colons');\n      }\n\n      URI.ensureValidHostname(v, this._parts.protocol);\n\n      if (!this._parts.hostname || this.is('IP')) {\n        this._parts.hostname = v;\n      } else {\n        var replace = new RegExp(escapeRegEx(this.domain()) + '$');\n        this._parts.hostname = this._parts.hostname.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.tld = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (typeof v === 'boolean') {\n      build = v;\n      v = undefined;\n    }\n\n    // return \"org\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      var pos = this._parts.hostname.lastIndexOf('.');\n      var tld = this._parts.hostname.substring(pos + 1);\n\n      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {\n        return SLD.get(this._parts.hostname) || tld;\n      }\n\n      return tld;\n    } else {\n      var replace;\n\n      if (!v) {\n        throw new TypeError('cannot set TLD empty');\n      } else if (v.match(/[^a-zA-Z0-9-]/)) {\n        if (SLD && SLD.is(v)) {\n          replace = new RegExp(escapeRegEx(this.tld()) + '$');\n          this._parts.hostname = this._parts.hostname.replace(replace, v);\n        } else {\n          throw new TypeError('TLD \"' + v + '\" contains characters other than [A-Z0-9]');\n        }\n      } else if (!this._parts.hostname || this.is('IP')) {\n        throw new ReferenceError('cannot set TLD on non-domain host');\n      } else {\n        replace = new RegExp(escapeRegEx(this.tld()) + '$');\n        this._parts.hostname = this._parts.hostname.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.directory = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined || v === true) {\n      if (!this._parts.path && !this._parts.hostname) {\n        return '';\n      }\n\n      if (this._parts.path === '/') {\n        return '/';\n      }\n\n      var end = this._parts.path.length - this.filename().length - 1;\n      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');\n\n      return v ? URI.decodePath(res) : res;\n\n    } else {\n      var e = this._parts.path.length - this.filename().length;\n      var directory = this._parts.path.substring(0, e);\n      var replace = new RegExp('^' + escapeRegEx(directory));\n\n      // fully qualifier directories begin with a slash\n      if (!this.is('relative')) {\n        if (!v) {\n          v = '/';\n        }\n\n        if (v.charAt(0) !== '/') {\n          v = '/' + v;\n        }\n      }\n\n      // directories always end with a slash\n      if (v && v.charAt(v.length - 1) !== '/') {\n        v += '/';\n      }\n\n      v = URI.recodePath(v);\n      this._parts.path = this._parts.path.replace(replace, v);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.filename = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (typeof v !== 'string') {\n      if (!this._parts.path || this._parts.path === '/') {\n        return '';\n      }\n\n      var pos = this._parts.path.lastIndexOf('/');\n      var res = this._parts.path.substring(pos+1);\n\n      return v ? URI.decodePathSegment(res) : res;\n    } else {\n      var mutatedDirectory = false;\n\n      if (v.charAt(0) === '/') {\n        v = v.substring(1);\n      }\n\n      if (v.match(/\\.?\\//)) {\n        mutatedDirectory = true;\n      }\n\n      var replace = new RegExp(escapeRegEx(this.filename()) + '$');\n      v = URI.recodePath(v);\n      this._parts.path = this._parts.path.replace(replace, v);\n\n      if (mutatedDirectory) {\n        this.normalizePath(build);\n      } else {\n        this.build(!build);\n      }\n\n      return this;\n    }\n  };\n  p.suffix = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined || v === true) {\n      if (!this._parts.path || this._parts.path === '/') {\n        return '';\n      }\n\n      var filename = this.filename();\n      var pos = filename.lastIndexOf('.');\n      var s, res;\n\n      if (pos === -1) {\n        return '';\n      }\n\n      // suffix may only contain alnum characters (yup, I made this up.)\n      s = filename.substring(pos+1);\n      res = (/^[a-z0-9%]+$/i).test(s) ? s : '';\n      return v ? URI.decodePathSegment(res) : res;\n    } else {\n      if (v.charAt(0) === '.') {\n        v = v.substring(1);\n      }\n\n      var suffix = this.suffix();\n      var replace;\n\n      if (!suffix) {\n        if (!v) {\n          return this;\n        }\n\n        this._parts.path += '.' + URI.recodePath(v);\n      } else if (!v) {\n        replace = new RegExp(escapeRegEx('.' + suffix) + '$');\n      } else {\n        replace = new RegExp(escapeRegEx(suffix) + '$');\n      }\n\n      if (replace) {\n        v = URI.recodePath(v);\n        this._parts.path = this._parts.path.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.segment = function(segment, v, build) {\n    var separator = this._parts.urn ? ':' : '/';\n    var path = this.path();\n    var absolute = path.substring(0, 1) === '/';\n    var segments = path.split(separator);\n\n    if (segment !== undefined && typeof segment !== 'number') {\n      build = v;\n      v = segment;\n      segment = undefined;\n    }\n\n    if (segment !== undefined && typeof segment !== 'number') {\n      throw new Error('Bad segment \"' + segment + '\", must be 0-based integer');\n    }\n\n    if (absolute) {\n      segments.shift();\n    }\n\n    if (segment < 0) {\n      // allow negative indexes to address from the end\n      segment = Math.max(segments.length + segment, 0);\n    }\n\n    if (v === undefined) {\n      /*jshint laxbreak: true */\n      return segment === undefined\n        ? segments\n        : segments[segment];\n      /*jshint laxbreak: false */\n    } else if (segment === null || segments[segment] === undefined) {\n      if (isArray(v)) {\n        segments = [];\n        // collapse empty elements within array\n        for (var i=0, l=v.length; i < l; i++) {\n          if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {\n            continue;\n          }\n\n          if (segments.length && !segments[segments.length -1].length) {\n            segments.pop();\n          }\n\n          segments.push(trimSlashes(v[i]));\n        }\n      } else if (v || typeof v === 'string') {\n        v = trimSlashes(v);\n        if (segments[segments.length -1] === '') {\n          // empty trailing elements have to be overwritten\n          // to prevent results such as /foo//bar\n          segments[segments.length -1] = v;\n        } else {\n          segments.push(v);\n        }\n      }\n    } else {\n      if (v) {\n        segments[segment] = trimSlashes(v);\n      } else {\n        segments.splice(segment, 1);\n      }\n    }\n\n    if (absolute) {\n      segments.unshift('');\n    }\n\n    return this.path(segments.join(separator), build);\n  };\n  p.segmentCoded = function(segment, v, build) {\n    var segments, i, l;\n\n    if (typeof segment !== 'number') {\n      build = v;\n      v = segment;\n      segment = undefined;\n    }\n\n    if (v === undefined) {\n      segments = this.segment(segment, v, build);\n      if (!isArray(segments)) {\n        segments = segments !== undefined ? URI.decode(segments) : undefined;\n      } else {\n        for (i = 0, l = segments.length; i < l; i++) {\n          segments[i] = URI.decode(segments[i]);\n        }\n      }\n\n      return segments;\n    }\n\n    if (!isArray(v)) {\n      v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;\n    } else {\n      for (i = 0, l = v.length; i < l; i++) {\n        v[i] = URI.encode(v[i]);\n      }\n    }\n\n    return this.segment(segment, v, build);\n  };\n\n  // mutating query string\n  var q = p.query;\n  p.query = function(v, build) {\n    if (v === true) {\n      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    } else if (typeof v === 'function') {\n      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n      var result = v.call(this, data);\n      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n      this.build(!build);\n      return this;\n    } else if (v !== undefined && typeof v !== 'string') {\n      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n      this.build(!build);\n      return this;\n    } else {\n      return q.call(this, v, build);\n    }\n  };\n  p.setQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n\n    if (typeof name === 'string' || name instanceof String) {\n      data[name] = value !== undefined ? value : null;\n    } else if (typeof name === 'object') {\n      for (var key in name) {\n        if (hasOwn.call(name, key)) {\n          data[key] = name[key];\n        }\n      }\n    } else {\n      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');\n    }\n\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.addQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    URI.addQuery(data, name, value === undefined ? null : value);\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.removeQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    URI.removeQuery(data, name, value);\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.hasQuery = function(name, value, withinArray) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    return URI.hasQuery(data, name, value, withinArray);\n  };\n  p.setSearch = p.setQuery;\n  p.addSearch = p.addQuery;\n  p.removeSearch = p.removeQuery;\n  p.hasSearch = p.hasQuery;\n\n  // sanitizing URLs\n  p.normalize = function() {\n    if (this._parts.urn) {\n      return this\n        .normalizeProtocol(false)\n        .normalizePath(false)\n        .normalizeQuery(false)\n        .normalizeFragment(false)\n        .build();\n    }\n\n    return this\n      .normalizeProtocol(false)\n      .normalizeHostname(false)\n      .normalizePort(false)\n      .normalizePath(false)\n      .normalizeQuery(false)\n      .normalizeFragment(false)\n      .build();\n  };\n  p.normalizeProtocol = function(build) {\n    if (typeof this._parts.protocol === 'string') {\n      this._parts.protocol = this._parts.protocol.toLowerCase();\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeHostname = function(build) {\n    if (this._parts.hostname) {\n      if (this.is('IDN') && punycode) {\n        this._parts.hostname = punycode.toASCII(this._parts.hostname);\n      } else if (this.is('IPv6') && IPv6) {\n        this._parts.hostname = IPv6.best(this._parts.hostname);\n      }\n\n      this._parts.hostname = this._parts.hostname.toLowerCase();\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizePort = function(build) {\n    // remove port of it's the protocol's default\n    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {\n      this._parts.port = null;\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizePath = function(build) {\n    var _path = this._parts.path;\n    if (!_path) {\n      return this;\n    }\n\n    if (this._parts.urn) {\n      this._parts.path = URI.recodeUrnPath(this._parts.path);\n      this.build(!build);\n      return this;\n    }\n\n    if (this._parts.path === '/') {\n      return this;\n    }\n\n    _path = URI.recodePath(_path);\n\n    var _was_relative;\n    var _leadingParents = '';\n    var _parent, _pos;\n\n    // handle relative paths\n    if (_path.charAt(0) !== '/') {\n      _was_relative = true;\n      _path = '/' + _path;\n    }\n\n    // handle relative files (as opposed to directories)\n    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {\n      _path += '/';\n    }\n\n    // resolve simples\n    _path = _path\n      .replace(/(\\/(\\.\\/)+)|(\\/\\.$)/g, '/')\n      .replace(/\\/{2,}/g, '/');\n\n    // remember leading parents\n    if (_was_relative) {\n      _leadingParents = _path.substring(1).match(/^(\\.\\.\\/)+/) || '';\n      if (_leadingParents) {\n        _leadingParents = _leadingParents[0];\n      }\n    }\n\n    // resolve parents\n    while (true) {\n      _parent = _path.search(/\\/\\.\\.(\\/|$)/);\n      if (_parent === -1) {\n        // no more ../ to resolve\n        break;\n      } else if (_parent === 0) {\n        // top level cannot be relative, skip it\n        _path = _path.substring(3);\n        continue;\n      }\n\n      _pos = _path.substring(0, _parent).lastIndexOf('/');\n      if (_pos === -1) {\n        _pos = _parent;\n      }\n      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);\n    }\n\n    // revert to relative\n    if (_was_relative && this.is('relative')) {\n      _path = _leadingParents + _path.substring(1);\n    }\n\n    this._parts.path = _path;\n    this.build(!build);\n    return this;\n  };\n  p.normalizePathname = p.normalizePath;\n  p.normalizeQuery = function(build) {\n    if (typeof this._parts.query === 'string') {\n      if (!this._parts.query.length) {\n        this._parts.query = null;\n      } else {\n        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));\n      }\n\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeFragment = function(build) {\n    if (!this._parts.fragment) {\n      this._parts.fragment = null;\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeSearch = p.normalizeQuery;\n  p.normalizeHash = p.normalizeFragment;\n\n  p.iso8859 = function() {\n    // expect unicode input, iso8859 output\n    var e = URI.encode;\n    var d = URI.decode;\n\n    URI.encode = escape;\n    URI.decode = decodeURIComponent;\n    try {\n      this.normalize();\n    } finally {\n      URI.encode = e;\n      URI.decode = d;\n    }\n    return this;\n  };\n\n  p.unicode = function() {\n    // expect iso8859 input, unicode output\n    var e = URI.encode;\n    var d = URI.decode;\n\n    URI.encode = strictEncodeURIComponent;\n    URI.decode = unescape;\n    try {\n      this.normalize();\n    } finally {\n      URI.encode = e;\n      URI.decode = d;\n    }\n    return this;\n  };\n\n  p.readable = function() {\n    var uri = this.clone();\n    // removing username, password, because they shouldn't be displayed according to RFC 3986\n    uri.username('').password('').normalize();\n    var t = '';\n    if (uri._parts.protocol) {\n      t += uri._parts.protocol + '://';\n    }\n\n    if (uri._parts.hostname) {\n      if (uri.is('punycode') && punycode) {\n        t += punycode.toUnicode(uri._parts.hostname);\n        if (uri._parts.port) {\n          t += ':' + uri._parts.port;\n        }\n      } else {\n        t += uri.host();\n      }\n    }\n\n    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {\n      t += '/';\n    }\n\n    t += uri.path(true);\n    if (uri._parts.query) {\n      var q = '';\n      for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {\n        var kv = (qp[i] || '').split('=');\n        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)\n          .replace(/&/g, '%26');\n\n        if (kv[1] !== undefined) {\n          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)\n            .replace(/&/g, '%26');\n        }\n      }\n      t += '?' + q.substring(1);\n    }\n\n    t += URI.decodeQuery(uri.hash(), true);\n    return t;\n  };\n\n  // resolving relative and absolute URLs\n  p.absoluteTo = function(base) {\n    var resolved = this.clone();\n    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];\n    var basedir, i, p;\n\n    if (this._parts.urn) {\n      throw new Error('URNs do not have any generally defined hierarchical components');\n    }\n\n    if (!(base instanceof URI)) {\n      base = new URI(base);\n    }\n\n    if (resolved._parts.protocol) {\n      // Directly returns even if this._parts.hostname is empty.\n      return resolved;\n    } else {\n      resolved._parts.protocol = base._parts.protocol;\n    }\n\n    if (this._parts.hostname) {\n      return resolved;\n    }\n\n    for (i = 0; (p = properties[i]); i++) {\n      resolved._parts[p] = base._parts[p];\n    }\n\n    if (!resolved._parts.path) {\n      resolved._parts.path = base._parts.path;\n      if (!resolved._parts.query) {\n        resolved._parts.query = base._parts.query;\n      }\n    } else {\n      if (resolved._parts.path.substring(-2) === '..') {\n        resolved._parts.path += '/';\n      }\n\n      if (resolved.path().charAt(0) !== '/') {\n        basedir = base.directory();\n        basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';\n        resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;\n        resolved.normalizePath();\n      }\n    }\n\n    resolved.build();\n    return resolved;\n  };\n  p.relativeTo = function(base) {\n    var relative = this.clone().normalize();\n    var relativeParts, baseParts, common, relativePath, basePath;\n\n    if (relative._parts.urn) {\n      throw new Error('URNs do not have any generally defined hierarchical components');\n    }\n\n    base = new URI(base).normalize();\n    relativeParts = relative._parts;\n    baseParts = base._parts;\n    relativePath = relative.path();\n    basePath = base.path();\n\n    if (relativePath.charAt(0) !== '/') {\n      throw new Error('URI is already relative');\n    }\n\n    if (basePath.charAt(0) !== '/') {\n      throw new Error('Cannot calculate a URI relative to another relative URI');\n    }\n\n    if (relativeParts.protocol === baseParts.protocol) {\n      relativeParts.protocol = null;\n    }\n\n    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {\n      return relative.build();\n    }\n\n    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {\n      return relative.build();\n    }\n\n    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {\n      relativeParts.hostname = null;\n      relativeParts.port = null;\n    } else {\n      return relative.build();\n    }\n\n    if (relativePath === basePath) {\n      relativeParts.path = '';\n      return relative.build();\n    }\n\n    // determine common sub path\n    common = URI.commonPath(relativePath, basePath);\n\n    // If the paths have nothing in common, return a relative URL with the absolute path.\n    if (!common) {\n      return relative.build();\n    }\n\n    var parents = baseParts.path\n      .substring(common.length)\n      .replace(/[^\\/]*$/, '')\n      .replace(/.*?\\//g, '../');\n\n    relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';\n\n    return relative.build();\n  };\n\n  // comparing URIs\n  p.equals = function(uri) {\n    var one = this.clone();\n    var two = new URI(uri);\n    var one_map = {};\n    var two_map = {};\n    var checked = {};\n    var one_query, two_query, key;\n\n    one.normalize();\n    two.normalize();\n\n    // exact match\n    if (one.toString() === two.toString()) {\n      return true;\n    }\n\n    // extract query string\n    one_query = one.query();\n    two_query = two.query();\n    one.query('');\n    two.query('');\n\n    // definitely not equal if not even non-query parts match\n    if (one.toString() !== two.toString()) {\n      return false;\n    }\n\n    // query parameters have the same length, even if they're permuted\n    if (one_query.length !== two_query.length) {\n      return false;\n    }\n\n    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);\n    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);\n\n    for (key in one_map) {\n      if (hasOwn.call(one_map, key)) {\n        if (!isArray(one_map[key])) {\n          if (one_map[key] !== two_map[key]) {\n            return false;\n          }\n        } else if (!arraysEqual(one_map[key], two_map[key])) {\n          return false;\n        }\n\n        checked[key] = true;\n      }\n    }\n\n    for (key in two_map) {\n      if (hasOwn.call(two_map, key)) {\n        if (!checked[key]) {\n          // two contains a parameter not present in one\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  // state\n  p.preventInvalidHostname = function(v) {\n    this._parts.preventInvalidHostname = !!v;\n    return this;\n  };\n\n  p.duplicateQueryParameters = function(v) {\n    this._parts.duplicateQueryParameters = !!v;\n    return this;\n  };\n\n  p.escapeQuerySpace = function(v) {\n    this._parts.escapeQuerySpace = !!v;\n    return this;\n  };\n\n  return URI;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXJpanMvc3JjL1VSSS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQTBCO0FBQ2hDO0FBQ0EsNkJBQTZCLG1CQUFPLENBQUMsOERBQVksR0FBRyxtQkFBTyxDQUFDLHNEQUFRLEdBQUcsbUJBQU8sQ0FBQyxrRkFBc0I7QUFDckcsSUFBSSxTQUFTLElBQTBDO0FBQ3ZEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLG1GQUFZLEVBQUUsMkVBQVEsRUFBRSx1R0FBc0IsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQ3JFLElBQUksS0FBSyxFQUdOO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLElBQUksR0FBRyxFQUFFLGFBQWEsSUFBSSxtQkFBbUIsSUFBSSxHQUFHLEVBQUUsY0FBYyxJQUFJLHlFQUF5RSxFQUFFLG9CQUFvQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxFQUFFLElBQUksMkVBQTJFLEVBQUUsb0JBQW9CLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEVBQUUsSUFBSSxpQkFBaUIsSUFBSSwyRUFBMkUsRUFBRSxxQkFBcUIsSUFBSSxHQUFHLEVBQUUsZ0JBQWdCLElBQUksRUFBRSxJQUFJLGlCQUFpQixJQUFJLEVBQUUsSUFBSSx5RUFBeUUsRUFBRSxxQkFBcUIsSUFBSSxHQUFHLEVBQUUsZ0JBQWdCLElBQUksRUFBRSxJQUFJLGlCQUFpQixJQUFJLEVBQUUsSUFBSSx5RUFBeUUsRUFBRSxxQkFBcUIsSUFBSSxHQUFHLEVBQUUsZ0JBQWdCLElBQUksRUFBRSxJQUFJLGlCQUFpQixJQUFJLEVBQUUsSUFBSSx5RUFBeUUsRUFBRSx5QkFBeUIsSUFBSSxFQUFFLElBQUksaUJBQWlCLElBQUksRUFBRSxJQUFJLHlFQUF5RSxFQUFFO0FBQzlqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxJQUFJLGtCQUFrQixJQUFJLHlCQUF5QixJQUFJLDBHQUEwRztBQUN0TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsMkNBQTJDO0FBQzNDLHNDQUFzQyxHQUFHLElBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUc7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRzs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxPQUFPO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVU1VBUklPXFxEb2N1bWVudHNcXEdpdGh1YlxcR2FsYXh5S0otd2FsbGV0LS0tSGFja1xcd2ViXFxub2RlX21vZHVsZXNcXHVyaWpzXFxzcmNcXFVSSS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFVSSS5qcyAtIE11dGF0aW5nIFVSTHNcbiAqXG4gKiBWZXJzaW9uOiAxLjE5LjExXG4gKlxuICogQXV0aG9yOiBSb2RuZXkgUmVobVxuICogV2ViOiBodHRwOi8vbWVkaWFsaXplLmdpdGh1Yi5pby9VUkkuanMvXG4gKlxuICogTGljZW5zZWQgdW5kZXJcbiAqICAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuICpcbiAqL1xuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIE5vZGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnLi9wdW55Y29kZScpLCByZXF1aXJlKCcuL0lQdjYnKSwgcmVxdWlyZSgnLi9TZWNvbmRMZXZlbERvbWFpbnMnKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJy4vcHVueWNvZGUnLCAnLi9JUHY2JywgJy4vU2Vjb25kTGV2ZWxEb21haW5zJ10sIGZhY3RvcnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgcm9vdC5VUkkgPSBmYWN0b3J5KHJvb3QucHVueWNvZGUsIHJvb3QuSVB2Niwgcm9vdC5TZWNvbmRMZXZlbERvbWFpbnMsIHJvb3QpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uIChwdW55Y29kZSwgSVB2NiwgU0xELCByb290KSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLypnbG9iYWwgbG9jYXRpb24sIGVzY2FwZSwgdW5lc2NhcGUgKi9cbiAgLy8gRklYTUU6IHYyLjAuMCByZW5hbWNlIG5vbi1jYW1lbENhc2UgcHJvcGVydGllcyB0byB1cHBlcmNhc2VcbiAgLypqc2hpbnQgY2FtZWxjYXNlOiBmYWxzZSAqL1xuXG4gIC8vIHNhdmUgY3VycmVudCBVUkkgdmFyaWFibGUsIGlmIGFueVxuICB2YXIgX1VSSSA9IHJvb3QgJiYgcm9vdC5VUkk7XG5cbiAgZnVuY3Rpb24gVVJJKHVybCwgYmFzZSkge1xuICAgIHZhciBfdXJsU3VwcGxpZWQgPSBhcmd1bWVudHMubGVuZ3RoID49IDE7XG4gICAgdmFyIF9iYXNlU3VwcGxpZWQgPSBhcmd1bWVudHMubGVuZ3RoID49IDI7XG5cbiAgICAvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVVJJKSkge1xuICAgICAgaWYgKF91cmxTdXBwbGllZCkge1xuICAgICAgICBpZiAoX2Jhc2VTdXBwbGllZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVVJJKHVybCwgYmFzZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFVSSSh1cmwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFVSSSgpO1xuICAgIH1cblxuICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKF91cmxTdXBwbGllZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmRlZmluZWQgaXMgbm90IGEgdmFsaWQgYXJndW1lbnQgZm9yIFVSSScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB1cmwgPSBsb2NhdGlvbi5ocmVmICsgJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXJsID09PSBudWxsKSB7XG4gICAgICBpZiAoX3VybFN1cHBsaWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ251bGwgaXMgbm90IGEgdmFsaWQgYXJndW1lbnQgZm9yIFVSSScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaHJlZih1cmwpO1xuXG4gICAgLy8gcmVzb2x2ZSB0byBiYXNlIGFjY29yZGluZyB0byBodHRwOi8vZHZjcy53My5vcmcvaGcvdXJsL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sI2NvbnN0cnVjdG9yXG4gICAgaWYgKGJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzb2x1dGVUbyhiYXNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiAvXlswLTldKyQvLnRlc3QodmFsdWUpO1xuICB9XG5cbiAgVVJJLnZlcnNpb24gPSAnMS4xOS4xMSc7XG5cbiAgdmFyIHAgPSBVUkkucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmdW5jdGlvbiBlc2NhcGVSZWdFeChzdHJpbmcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL1VSSS5qcy9jb21taXQvODVhYzIxNzgzYzExZjhjY2FiMDYxMDZkYmE5NzM1YTMxYTg2OTI0ZCNjb21taXRjb21tZW50LTgyMTk2M1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFsuKis/Xj0hOiR7fSgpfFtcXF1cXC9cXFxcXSkvZywgJ1xcXFwkMScpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xuICAgIC8vIElFOCBkb2Vzbid0IHJldHVybiBbT2JqZWN0IFVuZGVmaW5lZF0gYnV0IFtPYmplY3QgT2JqZWN0XSBmb3IgdW5kZWZpbmVkIHZhbHVlXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnVW5kZWZpbmVkJztcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkpLnNsaWNlKDgsIC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIGdldFR5cGUob2JqKSA9PT0gJ0FycmF5JztcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlckFycmF5VmFsdWVzKGRhdGEsIHZhbHVlKSB7XG4gICAgdmFyIGxvb2t1cCA9IHt9O1xuICAgIHZhciBpLCBsZW5ndGg7XG5cbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdSZWdFeHAnKSB7XG4gICAgICBsb29rdXAgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxvb2t1cFt2YWx1ZVtpXV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb29rdXBbdmFsdWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAvKmpzaGludCBsYXhicmVhazogdHJ1ZSAqL1xuICAgICAgdmFyIF9tYXRjaCA9IGxvb2t1cCAmJiBsb29rdXBbZGF0YVtpXV0gIT09IHVuZGVmaW5lZFxuICAgICAgICB8fCAhbG9va3VwICYmIHZhbHVlLnRlc3QoZGF0YVtpXSk7XG4gICAgICAvKmpzaGludCBsYXhicmVhazogZmFsc2UgKi9cbiAgICAgIGlmIChfbWF0Y2gpIHtcbiAgICAgICAgZGF0YS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUNvbnRhaW5zKGxpc3QsIHZhbHVlKSB7XG4gICAgdmFyIGksIGxlbmd0aDtcblxuICAgIC8vIHZhbHVlIG1heSBiZSBzdHJpbmcsIG51bWJlciwgYXJyYXksIHJlZ2V4cFxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gTm90ZTogdGhpcyBjYW4gYmUgb3B0aW1pemVkIHRvIE8obikgKGluc3RlYWQgb2YgY3VycmVudCBPKG0gKiBuKSlcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghYXJyYXlDb250YWlucyhsaXN0LCB2YWx1ZVtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIF90eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKF90eXBlID09PSAnUmVnRXhwJykge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RbaV0gPT09ICdzdHJpbmcnICYmIGxpc3RbaV0ubWF0Y2godmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGlzdFtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlzRXF1YWwob25lLCB0d28pIHtcbiAgICBpZiAoIWlzQXJyYXkob25lKSB8fCAhaXNBcnJheSh0d28pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYXJyYXlzIGNhbid0IGJlIGVxdWFsIGlmIHRoZXkgaGF2ZSBkaWZmZXJlbnQgYW1vdW50IG9mIGNvbnRlbnRcbiAgICBpZiAob25lLmxlbmd0aCAhPT0gdHdvLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9uZS5zb3J0KCk7XG4gICAgdHdvLnNvcnQoKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb25lLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKG9uZVtpXSAhPT0gdHdvW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW1TbGFzaGVzKHRleHQpIHtcbiAgICB2YXIgdHJpbV9leHByZXNzaW9uID0gL15cXC8rfFxcLyskL2c7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSh0cmltX2V4cHJlc3Npb24sICcnKTtcbiAgfVxuXG4gIFVSSS5fcGFydHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvdG9jb2w6IG51bGwsXG4gICAgICB1c2VybmFtZTogbnVsbCxcbiAgICAgIHBhc3N3b3JkOiBudWxsLFxuICAgICAgaG9zdG5hbWU6IG51bGwsXG4gICAgICB1cm46IG51bGwsXG4gICAgICBwb3J0OiBudWxsLFxuICAgICAgcGF0aDogbnVsbCxcbiAgICAgIHF1ZXJ5OiBudWxsLFxuICAgICAgZnJhZ21lbnQ6IG51bGwsXG4gICAgICAvLyBzdGF0ZVxuICAgICAgcHJldmVudEludmFsaWRIb3N0bmFtZTogVVJJLnByZXZlbnRJbnZhbGlkSG9zdG5hbWUsXG4gICAgICBkdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnM6IFVSSS5kdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMsXG4gICAgICBlc2NhcGVRdWVyeVNwYWNlOiBVUkkuZXNjYXBlUXVlcnlTcGFjZVxuICAgIH07XG4gIH07XG4gIC8vIHN0YXRlOiB0aHJvdyBvbiBpbnZhbGlkIGhvc3RuYW1lXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL1VSSS5qcy9wdWxsLzM0NVxuICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9VUkkuanMvaXNzdWVzLzM1NFxuICBVUkkucHJldmVudEludmFsaWRIb3N0bmFtZSA9IGZhbHNlO1xuICAvLyBzdGF0ZTogYWxsb3cgZHVwbGljYXRlIHF1ZXJ5IHBhcmFtZXRlcnMgKGE9MSZhPTEpXG4gIFVSSS5kdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMgPSBmYWxzZTtcbiAgLy8gc3RhdGU6IHJlcGxhY2VzICsgd2l0aCAlMjAgKHNwYWNlIGluIHF1ZXJ5IHN0cmluZ3MpXG4gIFVSSS5lc2NhcGVRdWVyeVNwYWNlID0gdHJ1ZTtcbiAgLy8gc3RhdGljIHByb3BlcnRpZXNcbiAgVVJJLnByb3RvY29sX2V4cHJlc3Npb24gPSAvXlthLXpdW2EtejAtOS4rLV0qJC9pO1xuICBVUkkuaWRuX2V4cHJlc3Npb24gPSAvW15hLXowLTlcXC5fLV0vaTtcbiAgVVJJLnB1bnljb2RlX2V4cHJlc3Npb24gPSAvKHhuLS0pL2k7XG4gIC8vIHdlbGwsIDMzMy40NDQuNTU1LjY2NiBtYXRjaGVzLCBidXQgaXQgc3VyZSBhaW4ndCBubyBJUHY0IC0gZG8gd2UgY2FyZT9cbiAgVVJJLmlwNF9leHByZXNzaW9uID0gL15cXGR7MSwzfVxcLlxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfSQvO1xuICAvLyBjcmVkaXRzIHRvIFJpY2ggQnJvd25cbiAgLy8gc291cmNlOiBodHRwOi8vZm9ydW1zLmludGVybWFwcGVyLmNvbS92aWV3dG9waWMucGhwP3A9MTA5NiMxMDk2XG4gIC8vIHNwZWNpZmljYXRpb246IGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQyOTEudHh0XG4gIFVSSS5pcDZfZXhwcmVzc2lvbiA9IC9eXFxzKigoKFswLTlBLUZhLWZdezEsNH06KXs3fShbMC05QS1GYS1mXXsxLDR9fDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs2fSg6WzAtOUEtRmEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezV9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezR9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsM30pfCgoOlswLTlBLUZhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXszfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezJ9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNX0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7MX0oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSglLispP1xccyokLztcbiAgLy8gZXhwcmVzc2lvbiB1c2VkIGlzIFwiZ3J1YmVyIHJldmlzZWRcIiAoQGdydWJlciB2MikgZGV0ZXJtaW5lZCB0byBiZSB0aGVcbiAgLy8gYmVzdCBzb2x1dGlvbiBpbiBhIHJlZ2V4LWdvbGYgd2UgZGlkIGEgY291cGxlIG9mIGFnZXMgYWdvIGF0XG4gIC8vICogaHR0cDovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXhcbiAgLy8gKiBodHRwOi8vcm9kbmV5cmVobS5kZS90L3VybC1yZWdleC5odG1sXG4gIFVSSS5maW5kX3VyaV9leHByZXNzaW9uID0gL1xcYigoPzpbYS16XVtcXHctXSs6KD86XFwvezEsM318W2EtejAtOSVdKXx3d3dcXGR7MCwzfVsuXXxbYS16MC05LlxcLV0rWy5dW2Etel17Miw0fVxcLykoPzpbXlxccygpPD5dK3xcXCgoW15cXHMoKTw+XSt8KFxcKFteXFxzKCk8Pl0rXFwpKSkqXFwpKSsoPzpcXCgoW15cXHMoKTw+XSt8KFxcKFteXFxzKCk8Pl0rXFwpKSkqXFwpfFteXFxzYCEoKVxcW1xcXXt9OzonXCIuLDw+P8KrwrvigJzigJ3igJjigJldKSkvaWc7XG4gIFVSSS5maW5kVXJpID0ge1xuICAgIC8vIHZhbGlkIFwic2NoZW1lOi8vXCIgb3IgXCJ3d3cuXCJcbiAgICBzdGFydDogL1xcYig/OihbYS16XVthLXowLTkuKy1dKjpcXC9cXC8pfHd3d1xcLikvZ2ksXG4gICAgLy8gZXZlcnl0aGluZyB1cCB0byB0aGUgbmV4dCB3aGl0ZXNwYWNlXG4gICAgZW5kOiAvW1xcc1xcclxcbl18JC8sXG4gICAgLy8gdHJpbSB0cmFpbGluZyBwdW5jdHVhdGlvbiBjYXB0dXJlZCBieSBlbmQgUmVnRXhwXG4gICAgdHJpbTogL1tgISgpXFxbXFxde307OidcIi4sPD4/wqvCu+KAnOKAneKAnuKAmOKAmV0rJC8sXG4gICAgLy8gYmFsYW5jZWQgcGFyZW5zIGluY2x1c2lvbiAoKSwgW10sIHt9LCA8PlxuICAgIHBhcmVuczogLyhcXChbXlxcKV0qXFwpfFxcW1teXFxdXSpcXF18XFx7W159XSpcXH18PFtePl0qPikvZyxcbiAgfTtcbiAgVVJJLmxlYWRpbmdfd2hpdGVzcGFjZV9leHByZXNzaW9uID0gL15bXFx4MDAtXFx4MjBcXHUwMGEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMjhcXHUyMDI5XFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0rL1xuICAvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktdGFiLW9yLW5ld2xpbmVcbiAgVVJJLmFzY2lpX3RhYl93aGl0ZXNwYWNlID0gL1tcXHUwMDA5XFx1MDAwQVxcdTAwMERdKy9nXG4gIC8vIGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvdXJpLXNjaGVtZXMuaHRtbFxuICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfVENQX2FuZF9VRFBfcG9ydF9udW1iZXJzI1dlbGwta25vd25fcG9ydHNcbiAgVVJJLmRlZmF1bHRQb3J0cyA9IHtcbiAgICBodHRwOiAnODAnLFxuICAgIGh0dHBzOiAnNDQzJyxcbiAgICBmdHA6ICcyMScsXG4gICAgZ29waGVyOiAnNzAnLFxuICAgIHdzOiAnODAnLFxuICAgIHdzczogJzQ0MydcbiAgfTtcbiAgLy8gbGlzdCBvZiBwcm90b2NvbHMgd2hpY2ggYWx3YXlzIHJlcXVpcmUgYSBob3N0bmFtZVxuICBVUkkuaG9zdFByb3RvY29scyA9IFtcbiAgICAnaHR0cCcsXG4gICAgJ2h0dHBzJ1xuICBdO1xuXG4gIC8vIGFsbG93ZWQgaG9zdG5hbWUgY2hhcmFjdGVycyBhY2NvcmRpbmcgdG8gUkZDIDM5ODZcbiAgLy8gQUxQSEEgRElHSVQgXCItXCIgXCIuXCIgXCJfXCIgXCJ+XCIgXCIhXCIgXCIkXCIgXCImXCIgXCInXCIgXCIoXCIgXCIpXCIgXCIqXCIgXCIrXCIgXCIsXCIgXCI7XCIgXCI9XCIgJWVuY29kZWRcbiAgLy8gSSd2ZSBuZXZlciBzZWVuIGEgKG5vbi1JRE4pIGhvc3RuYW1lIG90aGVyIHRoYW46IEFMUEhBIERJR0lUIC4gLSBfXG4gIFVSSS5pbnZhbGlkX2hvc3RuYW1lX2NoYXJhY3RlcnMgPSAvW15hLXpBLVowLTlcXC5cXC06X10vO1xuICAvLyBtYXAgRE9NIEVsZW1lbnRzIHRvIHRoZWlyIFVSSSBhdHRyaWJ1dGVcbiAgVVJJLmRvbUF0dHJpYnV0ZXMgPSB7XG4gICAgJ2EnOiAnaHJlZicsXG4gICAgJ2Jsb2NrcXVvdGUnOiAnY2l0ZScsXG4gICAgJ2xpbmsnOiAnaHJlZicsXG4gICAgJ2Jhc2UnOiAnaHJlZicsXG4gICAgJ3NjcmlwdCc6ICdzcmMnLFxuICAgICdmb3JtJzogJ2FjdGlvbicsXG4gICAgJ2ltZyc6ICdzcmMnLFxuICAgICdhcmVhJzogJ2hyZWYnLFxuICAgICdpZnJhbWUnOiAnc3JjJyxcbiAgICAnZW1iZWQnOiAnc3JjJyxcbiAgICAnc291cmNlJzogJ3NyYycsXG4gICAgJ3RyYWNrJzogJ3NyYycsXG4gICAgJ2lucHV0JzogJ3NyYycsIC8vIGJ1dCBvbmx5IGlmIHR5cGU9XCJpbWFnZVwiXG4gICAgJ2F1ZGlvJzogJ3NyYycsXG4gICAgJ3ZpZGVvJzogJ3NyYydcbiAgfTtcbiAgVVJJLmdldERvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUgfHwgIW5vZGUubm9kZU5hbWUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIDxpbnB1dD4gc2hvdWxkIG9ubHkgZXhwb3NlIHNyYyBmb3IgdHlwZT1cImltYWdlXCJcbiAgICBpZiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgbm9kZS50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBVUkkuZG9tQXR0cmlidXRlc1tub2RlTmFtZV07XG4gIH07XG5cbiAgZnVuY3Rpb24gZXNjYXBlRm9yRHVtYkZpcmVmb3gzNih2YWx1ZSkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvVVJJLmpzL2lzc3Vlcy85MVxuICAgIHJldHVybiBlc2NhcGUodmFsdWUpO1xuICB9XG5cbiAgLy8gZW5jb2RpbmcgLyBkZWNvZGluZyBhY2NvcmRpbmcgdG8gUkZDMzk4NlxuICBmdW5jdGlvbiBzdHJpY3RFbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKSB7XG4gICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvZW5jb2RlVVJJQ29tcG9uZW50XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpXG4gICAgICAucmVwbGFjZSgvWyEnKCkqXS9nLCBlc2NhcGVGb3JEdW1iRmlyZWZveDM2KVxuICAgICAgLnJlcGxhY2UoL1xcKi9nLCAnJTJBJyk7XG4gIH1cbiAgVVJJLmVuY29kZSA9IHN0cmljdEVuY29kZVVSSUNvbXBvbmVudDtcbiAgVVJJLmRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcbiAgVVJJLmlzbzg4NTkgPSBmdW5jdGlvbigpIHtcbiAgICBVUkkuZW5jb2RlID0gZXNjYXBlO1xuICAgIFVSSS5kZWNvZGUgPSB1bmVzY2FwZTtcbiAgfTtcbiAgVVJJLnVuaWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICBVUkkuZW5jb2RlID0gc3RyaWN0RW5jb2RlVVJJQ29tcG9uZW50O1xuICAgIFVSSS5kZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG4gIH07XG4gIFVSSS5jaGFyYWN0ZXJzID0ge1xuICAgIHBhdGhuYW1lOiB7XG4gICAgICBlbmNvZGU6IHtcbiAgICAgICAgLy8gUkZDMzk4NiAyLjE6IEZvciBjb25zaXN0ZW5jeSwgVVJJIHByb2R1Y2VycyBhbmQgbm9ybWFsaXplcnMgc2hvdWxkXG4gICAgICAgIC8vIHVzZSB1cHBlcmNhc2UgaGV4YWRlY2ltYWwgZGlnaXRzIGZvciBhbGwgcGVyY2VudC1lbmNvZGluZ3MuXG4gICAgICAgIGV4cHJlc3Npb246IC8lKDI0fDI2fDJCfDJDfDNCfDNEfDNBfDQwKS9pZyxcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgLy8gLS5ffiEnKCkqXG4gICAgICAgICAgJyUyNCc6ICckJyxcbiAgICAgICAgICAnJTI2JzogJyYnLFxuICAgICAgICAgICclMkInOiAnKycsXG4gICAgICAgICAgJyUyQyc6ICcsJyxcbiAgICAgICAgICAnJTNCJzogJzsnLFxuICAgICAgICAgICclM0QnOiAnPScsXG4gICAgICAgICAgJyUzQSc6ICc6JyxcbiAgICAgICAgICAnJTQwJzogJ0AnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWNvZGU6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogL1tcXC9cXD8jXS9nLFxuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAnLyc6ICclMkYnLFxuICAgICAgICAgICc/JzogJyUzRicsXG4gICAgICAgICAgJyMnOiAnJTIzJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZXNlcnZlZDoge1xuICAgICAgZW5jb2RlOiB7XG4gICAgICAgIC8vIFJGQzM5ODYgMi4xOiBGb3IgY29uc2lzdGVuY3ksIFVSSSBwcm9kdWNlcnMgYW5kIG5vcm1hbGl6ZXJzIHNob3VsZFxuICAgICAgICAvLyB1c2UgdXBwZXJjYXNlIGhleGFkZWNpbWFsIGRpZ2l0cyBmb3IgYWxsIHBlcmNlbnQtZW5jb2RpbmdzLlxuICAgICAgICBleHByZXNzaW9uOiAvJSgyMXwyM3wyNHwyNnwyN3wyOHwyOXwyQXwyQnwyQ3wyRnwzQXwzQnwzRHwzRnw0MHw1Qnw1RCkvaWcsXG4gICAgICAgIG1hcDoge1xuICAgICAgICAgIC8vIGdlbi1kZWxpbXNcbiAgICAgICAgICAnJTNBJzogJzonLFxuICAgICAgICAgICclMkYnOiAnLycsXG4gICAgICAgICAgJyUzRic6ICc/JyxcbiAgICAgICAgICAnJTIzJzogJyMnLFxuICAgICAgICAgICclNUInOiAnWycsXG4gICAgICAgICAgJyU1RCc6ICddJyxcbiAgICAgICAgICAnJTQwJzogJ0AnLFxuICAgICAgICAgIC8vIHN1Yi1kZWxpbXNcbiAgICAgICAgICAnJTIxJzogJyEnLFxuICAgICAgICAgICclMjQnOiAnJCcsXG4gICAgICAgICAgJyUyNic6ICcmJyxcbiAgICAgICAgICAnJTI3JzogJ1xcJycsXG4gICAgICAgICAgJyUyOCc6ICcoJyxcbiAgICAgICAgICAnJTI5JzogJyknLFxuICAgICAgICAgICclMkEnOiAnKicsXG4gICAgICAgICAgJyUyQic6ICcrJyxcbiAgICAgICAgICAnJTJDJzogJywnLFxuICAgICAgICAgICclM0InOiAnOycsXG4gICAgICAgICAgJyUzRCc6ICc9J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB1cm5wYXRoOiB7XG4gICAgICAvLyBUaGUgY2hhcmFjdGVycyB1bmRlciBgZW5jb2RlYCBhcmUgdGhlIGNoYXJhY3RlcnMgY2FsbGVkIG91dCBieSBSRkMgMjE0MSBhcyBiZWluZyBhY2NlcHRhYmxlXG4gICAgICAvLyBmb3IgdXNhZ2UgaW4gYSBVUk4uIFJGQzIxNDEgYWxzbyBjYWxscyBvdXQgXCItXCIsIFwiLlwiLCBhbmQgXCJfXCIgYXMgYWNjZXB0YWJsZSBjaGFyYWN0ZXJzLCBidXRcbiAgICAgIC8vIHRoZXNlIGFyZW4ndCBlbmNvZGVkIGJ5IGVuY29kZVVSSUNvbXBvbmVudCwgc28gd2UgZG9uJ3QgaGF2ZSB0byBjYWxsIHRoZW0gb3V0IGhlcmUuIEFsc29cbiAgICAgIC8vIG5vdGUgdGhhdCB0aGUgY29sb24gY2hhcmFjdGVyIGlzIG5vdCBmZWF0dXJlZCBpbiB0aGUgZW5jb2RpbmcgbWFwOyB0aGlzIGlzIGJlY2F1c2UgVVJJLmpzXG4gICAgICAvLyBnaXZlcyB0aGUgY29sb25zIGluIFVSTnMgc2VtYW50aWMgbWVhbmluZyBhcyB0aGUgZGVsaW1pdGVycyBvZiBwYXRoIHNlZ2VtZW50cywgYW5kIHNvIGl0XG4gICAgICAvLyBzaG91bGQgbm90IGFwcGVhciB1bmVuY29kZWQgaW4gYSBzZWdtZW50IGl0c2VsZi5cbiAgICAgIC8vIFNlZSBhbHNvIHRoZSBub3RlIGFib3ZlIGFib3V0IFJGQzM5ODYgYW5kIGNhcGl0YWxhbGl6ZWQgaGV4IGRpZ2l0cy5cbiAgICAgIGVuY29kZToge1xuICAgICAgICBleHByZXNzaW9uOiAvJSgyMXwyNHwyN3wyOHwyOXwyQXwyQnwyQ3wzQnwzRHw0MCkvaWcsXG4gICAgICAgIG1hcDoge1xuICAgICAgICAgICclMjEnOiAnIScsXG4gICAgICAgICAgJyUyNCc6ICckJyxcbiAgICAgICAgICAnJTI3JzogJ1xcJycsXG4gICAgICAgICAgJyUyOCc6ICcoJyxcbiAgICAgICAgICAnJTI5JzogJyknLFxuICAgICAgICAgICclMkEnOiAnKicsXG4gICAgICAgICAgJyUyQic6ICcrJyxcbiAgICAgICAgICAnJTJDJzogJywnLFxuICAgICAgICAgICclM0InOiAnOycsXG4gICAgICAgICAgJyUzRCc6ICc9JyxcbiAgICAgICAgICAnJTQwJzogJ0AnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBUaGVzZSBjaGFyYWN0ZXJzIGFyZSB0aGUgY2hhcmFjdGVycyBjYWxsZWQgb3V0IGJ5IFJGQzIxNDEgYXMgXCJyZXNlcnZlZFwiIGNoYXJhY3RlcnMgdGhhdFxuICAgICAgLy8gc2hvdWxkIG5ldmVyIGFwcGVhciBpbiBhIFVSTiwgcGx1cyB0aGUgY29sb24gY2hhcmFjdGVyIChzZWUgbm90ZSBhYm92ZSkuXG4gICAgICBkZWNvZGU6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogL1tcXC9cXD8jOl0vZyxcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgJy8nOiAnJTJGJyxcbiAgICAgICAgICAnPyc6ICclM0YnLFxuICAgICAgICAgICcjJzogJyUyMycsXG4gICAgICAgICAgJzonOiAnJTNBJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBVUkkuZW5jb2RlUXVlcnkgPSBmdW5jdGlvbihzdHJpbmcsIGVzY2FwZVF1ZXJ5U3BhY2UpIHtcbiAgICB2YXIgZXNjYXBlZCA9IFVSSS5lbmNvZGUoc3RyaW5nICsgJycpO1xuICAgIGlmIChlc2NhcGVRdWVyeVNwYWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVzY2FwZVF1ZXJ5U3BhY2UgPSBVUkkuZXNjYXBlUXVlcnlTcGFjZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXNjYXBlUXVlcnlTcGFjZSA/IGVzY2FwZWQucmVwbGFjZSgvJTIwL2csICcrJykgOiBlc2NhcGVkO1xuICB9O1xuICBVUkkuZGVjb2RlUXVlcnkgPSBmdW5jdGlvbihzdHJpbmcsIGVzY2FwZVF1ZXJ5U3BhY2UpIHtcbiAgICBzdHJpbmcgKz0gJyc7XG4gICAgaWYgKGVzY2FwZVF1ZXJ5U3BhY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXNjYXBlUXVlcnlTcGFjZSA9IFVSSS5lc2NhcGVRdWVyeVNwYWNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gVVJJLmRlY29kZShlc2NhcGVRdWVyeVNwYWNlID8gc3RyaW5nLnJlcGxhY2UoL1xcKy9nLCAnJTIwJykgOiBzdHJpbmcpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgLy8gd2UncmUgbm90IGdvaW5nIHRvIG1lc3Mgd2l0aCB3ZWlyZCBlbmNvZGluZ3MsXG4gICAgICAvLyBnaXZlIHVwIGFuZCByZXR1cm4gdGhlIHVuZGVjb2RlZCBvcmlnaW5hbCBzdHJpbmdcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL1VSSS5qcy9pc3N1ZXMvODdcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL1VSSS5qcy9pc3N1ZXMvOTJcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICB9O1xuICAvLyBnZW5lcmF0ZSBlbmNvZGUvZGVjb2RlIHBhdGggZnVuY3Rpb25zXG4gIHZhciBfcGFydHMgPSB7J2VuY29kZSc6J2VuY29kZScsICdkZWNvZGUnOidkZWNvZGUnfTtcbiAgdmFyIF9wYXJ0O1xuICB2YXIgZ2VuZXJhdGVBY2Nlc3NvciA9IGZ1bmN0aW9uKF9ncm91cCwgX3BhcnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gVVJJW19wYXJ0XShzdHJpbmcgKyAnJykucmVwbGFjZShVUkkuY2hhcmFjdGVyc1tfZ3JvdXBdW19wYXJ0XS5leHByZXNzaW9uLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuIFVSSS5jaGFyYWN0ZXJzW19ncm91cF1bX3BhcnRdLm1hcFtjXTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHdlJ3JlIG5vdCBnb2luZyB0byBtZXNzIHdpdGggd2VpcmQgZW5jb2RpbmdzLFxuICAgICAgICAvLyBnaXZlIHVwIGFuZCByZXR1cm4gdGhlIHVuZGVjb2RlZCBvcmlnaW5hbCBzdHJpbmdcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvVVJJLmpzL2lzc3Vlcy84N1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9VUkkuanMvaXNzdWVzLzkyXG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBmb3IgKF9wYXJ0IGluIF9wYXJ0cykge1xuICAgIFVSSVtfcGFydCArICdQYXRoU2VnbWVudCddID0gZ2VuZXJhdGVBY2Nlc3NvcigncGF0aG5hbWUnLCBfcGFydHNbX3BhcnRdKTtcbiAgICBVUklbX3BhcnQgKyAnVXJuUGF0aFNlZ21lbnQnXSA9IGdlbmVyYXRlQWNjZXNzb3IoJ3VybnBhdGgnLCBfcGFydHNbX3BhcnRdKTtcbiAgfVxuXG4gIHZhciBnZW5lcmF0ZVNlZ21lbnRlZFBhdGhGdW5jdGlvbiA9IGZ1bmN0aW9uKF9zZXAsIF9jb2RpbmdGdW5jTmFtZSwgX2lubmVyQ29kaW5nRnVuY05hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAvLyBXaHkgcGFzcyBpbiBuYW1lcyBvZiBmdW5jdGlvbnMsIHJhdGhlciB0aGFuIHRoZSBmdW5jdGlvbiBvYmplY3RzIHRoZW1zZWx2ZXM/IFRoZVxuICAgICAgLy8gZGVmaW5pdGlvbnMgb2Ygc29tZSBmdW5jdGlvbnMgKGJ1dCBpbiBwYXJ0aWN1bGFyLCBVUkkuZGVjb2RlKSB3aWxsIG9jY2FzaW9uYWxseSBjaGFuZ2UgZHVlXG4gICAgICAvLyB0byBVUkkuanMgaGF2aW5nIElTTzg4NTkgYW5kIFVuaWNvZGUgbW9kZXMuIFBhc3NpbmcgaW4gdGhlIG5hbWUgYW5kIGdldHRpbmcgaXQgd2lsbCBlbnN1cmVcbiAgICAgIC8vIHRoYXQgdGhlIGZ1bmN0aW9ucyB3ZSB1c2UgaGVyZSBhcmUgXCJmcmVzaFwiLlxuICAgICAgdmFyIGFjdHVhbENvZGluZ0Z1bmM7XG4gICAgICBpZiAoIV9pbm5lckNvZGluZ0Z1bmNOYW1lKSB7XG4gICAgICAgIGFjdHVhbENvZGluZ0Z1bmMgPSBVUklbX2NvZGluZ0Z1bmNOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbENvZGluZ0Z1bmMgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gVVJJW19jb2RpbmdGdW5jTmFtZV0oVVJJW19pbm5lckNvZGluZ0Z1bmNOYW1lXShzdHJpbmcpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ21lbnRzID0gKHN0cmluZyArICcnKS5zcGxpdChfc2VwKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlZ21lbnRzW2ldID0gYWN0dWFsQ29kaW5nRnVuYyhzZWdtZW50c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWdtZW50cy5qb2luKF9zZXApO1xuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyB0YWtlcyBwbGFjZSBvdXRzaWRlIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCwgZS5nLiwgZW5jb2RlVXJuUGF0aCBmdW5jdGlvbnMuXG4gIFVSSS5kZWNvZGVQYXRoID0gZ2VuZXJhdGVTZWdtZW50ZWRQYXRoRnVuY3Rpb24oJy8nLCAnZGVjb2RlUGF0aFNlZ21lbnQnKTtcbiAgVVJJLmRlY29kZVVyblBhdGggPSBnZW5lcmF0ZVNlZ21lbnRlZFBhdGhGdW5jdGlvbignOicsICdkZWNvZGVVcm5QYXRoU2VnbWVudCcpO1xuICBVUkkucmVjb2RlUGF0aCA9IGdlbmVyYXRlU2VnbWVudGVkUGF0aEZ1bmN0aW9uKCcvJywgJ2VuY29kZVBhdGhTZWdtZW50JywgJ2RlY29kZScpO1xuICBVUkkucmVjb2RlVXJuUGF0aCA9IGdlbmVyYXRlU2VnbWVudGVkUGF0aEZ1bmN0aW9uKCc6JywgJ2VuY29kZVVyblBhdGhTZWdtZW50JywgJ2RlY29kZScpO1xuXG4gIFVSSS5lbmNvZGVSZXNlcnZlZCA9IGdlbmVyYXRlQWNjZXNzb3IoJ3Jlc2VydmVkJywgJ2VuY29kZScpO1xuXG4gIFVSSS5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZywgcGFydHMpIHtcbiAgICB2YXIgcG9zO1xuICAgIGlmICghcGFydHMpIHtcbiAgICAgIHBhcnRzID0ge1xuICAgICAgICBwcmV2ZW50SW52YWxpZEhvc3RuYW1lOiBVUkkucHJldmVudEludmFsaWRIb3N0bmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShVUkkubGVhZGluZ193aGl0ZXNwYWNlX2V4cHJlc3Npb24sICcnKVxuICAgIC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS10YWItb3ItbmV3bGluZVxuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKFVSSS5hc2NpaV90YWJfd2hpdGVzcGFjZSwgJycpXG5cbiAgICAvLyBbcHJvdG9jb2xcIjovL1wiW3VzZXJuYW1lW1wiOlwicGFzc3dvcmRdXCJAXCJdaG9zdG5hbWVbXCI6XCJwb3J0XVwiL1wiP11bcGF0aF1bXCI/XCJxdWVyeXN0cmluZ11bXCIjXCJmcmFnbWVudF1cblxuICAgIC8vIGV4dHJhY3QgZnJhZ21lbnRcbiAgICBwb3MgPSBzdHJpbmcuaW5kZXhPZignIycpO1xuICAgIGlmIChwb3MgPiAtMSkge1xuICAgICAgLy8gZXNjYXBpbmc/XG4gICAgICBwYXJ0cy5mcmFnbWVudCA9IHN0cmluZy5zdWJzdHJpbmcocG9zICsgMSkgfHwgbnVsbDtcbiAgICAgIHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICB9XG5cbiAgICAvLyBleHRyYWN0IHF1ZXJ5XG4gICAgcG9zID0gc3RyaW5nLmluZGV4T2YoJz8nKTtcbiAgICBpZiAocG9zID4gLTEpIHtcbiAgICAgIC8vIGVzY2FwaW5nP1xuICAgICAgcGFydHMucXVlcnkgPSBzdHJpbmcuc3Vic3RyaW5nKHBvcyArIDEpIHx8IG51bGw7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgfVxuXG4gICAgLy8gc2xhc2hlcyBhbmQgYmFja3NsYXNoZXMgaGF2ZSBsb3N0IGFsbCBtZWFuaW5nIGZvciB0aGUgd2ViIHByb3RvY29scyAoaHR0cHMsIGh0dHAsIHdzcywgd3MpXG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL14oaHR0cHM/fGZ0cHx3c3M/KT86K1svXFxcXF0qL2ksICckMTovLycpO1xuICAgIC8vIHNsYXNoZXMgYW5kIGJhY2tzbGFzaGVzIGhhdmUgbG9zdCBhbGwgbWVhbmluZyBmb3Igc2NoZW1lIHJlbGF0aXZlIFVSTHNcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXlsvXFxcXF17Mix9L2ksICcvLycpO1xuXG4gICAgLy8gZXh0cmFjdCBwcm90b2NvbFxuICAgIGlmIChzdHJpbmcuc3Vic3RyaW5nKDAsIDIpID09PSAnLy8nKSB7XG4gICAgICAvLyByZWxhdGl2ZS1zY2hlbWVcbiAgICAgIHBhcnRzLnByb3RvY29sID0gbnVsbDtcbiAgICAgIHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcoMik7XG4gICAgICAvLyBleHRyYWN0IFwidXNlcjpwYXNzQGhvc3Q6cG9ydFwiXG4gICAgICBzdHJpbmcgPSBVUkkucGFyc2VBdXRob3JpdHkoc3RyaW5nLCBwYXJ0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IHN0cmluZy5pbmRleE9mKCc6Jyk7XG4gICAgICBpZiAocG9zID4gLTEpIHtcbiAgICAgICAgcGFydHMucHJvdG9jb2wgPSBzdHJpbmcuc3Vic3RyaW5nKDAsIHBvcykgfHwgbnVsbDtcbiAgICAgICAgaWYgKHBhcnRzLnByb3RvY29sICYmICFwYXJ0cy5wcm90b2NvbC5tYXRjaChVUkkucHJvdG9jb2xfZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAvLyA6IG1heSBiZSB3aXRoaW4gdGhlIHBhdGhcbiAgICAgICAgICBwYXJ0cy5wcm90b2NvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcuc3Vic3RyaW5nKHBvcyArIDEsIHBvcyArIDMpLnJlcGxhY2UoL1xcXFwvZywgJy8nKSA9PT0gJy8vJykge1xuICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcocG9zICsgMyk7XG5cbiAgICAgICAgICAvLyBleHRyYWN0IFwidXNlcjpwYXNzQGhvc3Q6cG9ydFwiXG4gICAgICAgICAgc3RyaW5nID0gVVJJLnBhcnNlQXV0aG9yaXR5KHN0cmluZywgcGFydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcocG9zICsgMSk7XG4gICAgICAgICAgcGFydHMudXJuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdoYXQncyBsZWZ0IG11c3QgYmUgdGhlIHBhdGhcbiAgICBwYXJ0cy5wYXRoID0gc3RyaW5nO1xuXG4gICAgLy8gYW5kIHdlJ3JlIGRvbmVcbiAgICByZXR1cm4gcGFydHM7XG4gIH07XG4gIFVSSS5wYXJzZUhvc3QgPSBmdW5jdGlvbihzdHJpbmcsIHBhcnRzKSB7XG4gICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9ICcnO1xuICAgIH1cblxuICAgIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAgIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2Jsb2IvMzg2ZmQyNGY0OWIwZTlkMWE4YTA3NjU5MmE0MDQxNjhmYWVlY2MzNC9saWIvdXJsLmpzI0wxMTUtTDEyNFxuICAgIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9VUkkuanMvcHVsbC8yMzNcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuXG4gICAgLy8gZXh0cmFjdCBob3N0OnBvcnRcbiAgICB2YXIgcG9zID0gc3RyaW5nLmluZGV4T2YoJy8nKTtcbiAgICB2YXIgYnJhY2tldFBvcztcbiAgICB2YXIgdDtcblxuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICBwb3MgPSBzdHJpbmcubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzdHJpbmcuY2hhckF0KDApID09PSAnWycpIHtcbiAgICAgIC8vIElQdjYgaG9zdCAtIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtNm1hbi10ZXh0LWFkZHItcmVwcmVzZW50YXRpb24tMDQjc2VjdGlvbi02XG4gICAgICAvLyBJIGNsYWltIG1vc3QgY2xpZW50IHNvZnR3YXJlIGJyZWFrcyBvbiBJUHY2IGFueXdheXMuIFRvIHNpbXBsaWZ5IHRoaW5ncywgVVJJIG9ubHkgYWNjZXB0c1xuICAgICAgLy8gSVB2Nitwb3J0IGluIHRoZSBmb3JtYXQgWzIwMDE6ZGI4OjoxXTo4MCAoZm9yIHRoZSB0aW1lIGJlaW5nKVxuICAgICAgYnJhY2tldFBvcyA9IHN0cmluZy5pbmRleE9mKCddJyk7XG4gICAgICBwYXJ0cy5ob3N0bmFtZSA9IHN0cmluZy5zdWJzdHJpbmcoMSwgYnJhY2tldFBvcykgfHwgbnVsbDtcbiAgICAgIHBhcnRzLnBvcnQgPSBzdHJpbmcuc3Vic3RyaW5nKGJyYWNrZXRQb3MgKyAyLCBwb3MpIHx8IG51bGw7XG4gICAgICBpZiAocGFydHMucG9ydCA9PT0gJy8nKSB7XG4gICAgICAgIHBhcnRzLnBvcnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3RDb2xvbiA9IHN0cmluZy5pbmRleE9mKCc6Jyk7XG4gICAgICB2YXIgZmlyc3RTbGFzaCA9IHN0cmluZy5pbmRleE9mKCcvJyk7XG4gICAgICB2YXIgbmV4dENvbG9uID0gc3RyaW5nLmluZGV4T2YoJzonLCBmaXJzdENvbG9uICsgMSk7XG4gICAgICBpZiAobmV4dENvbG9uICE9PSAtMSAmJiAoZmlyc3RTbGFzaCA9PT0gLTEgfHwgbmV4dENvbG9uIDwgZmlyc3RTbGFzaCkpIHtcbiAgICAgICAgLy8gSVB2NiBob3N0IGNvbnRhaW5zIG11bHRpcGxlIGNvbG9ucyAtIGJ1dCBubyBwb3J0XG4gICAgICAgIC8vIHRoaXMgbm90YXRpb24gaXMgYWN0dWFsbHkgbm90IGFsbG93ZWQgYnkgUkZDIDM5ODYsIGJ1dCB3ZSdyZSBhIGxpYmVyYWwgcGFyc2VyXG4gICAgICAgIHBhcnRzLmhvc3RuYW1lID0gc3RyaW5nLnN1YnN0cmluZygwLCBwb3MpIHx8IG51bGw7XG4gICAgICAgIHBhcnRzLnBvcnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHN0cmluZy5zdWJzdHJpbmcoMCwgcG9zKS5zcGxpdCgnOicpO1xuICAgICAgICBwYXJ0cy5ob3N0bmFtZSA9IHRbMF0gfHwgbnVsbDtcbiAgICAgICAgcGFydHMucG9ydCA9IHRbMV0gfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFydHMuaG9zdG5hbWUgJiYgc3RyaW5nLnN1YnN0cmluZyhwb3MpLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBwb3MrKztcbiAgICAgIHN0cmluZyA9ICcvJyArIHN0cmluZztcbiAgICB9XG5cbiAgICBpZiAocGFydHMucHJldmVudEludmFsaWRIb3N0bmFtZSkge1xuICAgICAgVVJJLmVuc3VyZVZhbGlkSG9zdG5hbWUocGFydHMuaG9zdG5hbWUsIHBhcnRzLnByb3RvY29sKTtcbiAgICB9XG5cbiAgICBpZiAocGFydHMucG9ydCkge1xuICAgICAgVVJJLmVuc3VyZVZhbGlkUG9ydChwYXJ0cy5wb3J0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZyhwb3MpIHx8ICcvJztcbiAgfTtcbiAgVVJJLnBhcnNlQXV0aG9yaXR5ID0gZnVuY3Rpb24oc3RyaW5nLCBwYXJ0cykge1xuICAgIHN0cmluZyA9IFVSSS5wYXJzZVVzZXJpbmZvKHN0cmluZywgcGFydHMpO1xuICAgIHJldHVybiBVUkkucGFyc2VIb3N0KHN0cmluZywgcGFydHMpO1xuICB9O1xuICBVUkkucGFyc2VVc2VyaW5mbyA9IGZ1bmN0aW9uKHN0cmluZywgcGFydHMpIHtcbiAgICAvLyBleHRyYWN0IHVzZXJuYW1lOnBhc3N3b3JkXG4gICAgdmFyIF9zdHJpbmcgPSBzdHJpbmdcbiAgICB2YXIgZmlyc3RCYWNrU2xhc2ggPSBzdHJpbmcuaW5kZXhPZignXFxcXCcpO1xuICAgIGlmIChmaXJzdEJhY2tTbGFzaCAhPT0gLTEpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgICB9XG4gICAgdmFyIGZpcnN0U2xhc2ggPSBzdHJpbmcuaW5kZXhPZignLycpO1xuICAgIHZhciBwb3MgPSBzdHJpbmcubGFzdEluZGV4T2YoJ0AnLCBmaXJzdFNsYXNoID4gLTEgPyBmaXJzdFNsYXNoIDogc3RyaW5nLmxlbmd0aCAtIDEpO1xuICAgIHZhciB0O1xuXG4gICAgLy8gYXV0aG9yaXR5QCBtdXN0IGNvbWUgYmVmb3JlIC9wYXRoIG9yIFxccGF0aFxuICAgIGlmIChwb3MgPiAtMSAmJiAoZmlyc3RTbGFzaCA9PT0gLTEgfHwgcG9zIDwgZmlyc3RTbGFzaCkpIHtcbiAgICAgIHQgPSBzdHJpbmcuc3Vic3RyaW5nKDAsIHBvcykuc3BsaXQoJzonKTtcbiAgICAgIHBhcnRzLnVzZXJuYW1lID0gdFswXSA/IFVSSS5kZWNvZGUodFswXSkgOiBudWxsO1xuICAgICAgdC5zaGlmdCgpO1xuICAgICAgcGFydHMucGFzc3dvcmQgPSB0WzBdID8gVVJJLmRlY29kZSh0LmpvaW4oJzonKSkgOiBudWxsO1xuICAgICAgc3RyaW5nID0gX3N0cmluZy5zdWJzdHJpbmcocG9zICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzLnVzZXJuYW1lID0gbnVsbDtcbiAgICAgIHBhcnRzLnBhc3N3b3JkID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xuICBVUkkucGFyc2VRdWVyeSA9IGZ1bmN0aW9uKHN0cmluZywgZXNjYXBlUXVlcnlTcGFjZSkge1xuICAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLy8gdGhyb3cgb3V0IHRoZSBmdW5reSBidXNpbmVzcyAtIFwiP1wiW25hbWVcIj1cInZhbHVlXCImXCJdK1xuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC8mKy9nLCAnJicpLnJlcGxhY2UoL15cXD8qJip8JiskL2csICcnKTtcblxuICAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgdmFyIGl0ZW1zID0ge307XG4gICAgdmFyIHNwbGl0cyA9IHN0cmluZy5zcGxpdCgnJicpO1xuICAgIHZhciBsZW5ndGggPSBzcGxpdHMubGVuZ3RoO1xuICAgIHZhciB2LCBuYW1lLCB2YWx1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHYgPSBzcGxpdHNbaV0uc3BsaXQoJz0nKTtcbiAgICAgIG5hbWUgPSBVUkkuZGVjb2RlUXVlcnkodi5zaGlmdCgpLCBlc2NhcGVRdWVyeVNwYWNlKTtcbiAgICAgIC8vIG5vIFwiPVwiIGlzIG51bGwgYWNjb3JkaW5nIHRvIGh0dHA6Ly9kdmNzLnczLm9yZy9oZy91cmwvcmF3LWZpbGUvdGlwL092ZXJ2aWV3Lmh0bWwjY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuICAgICAgdmFsdWUgPSB2Lmxlbmd0aCA/IFVSSS5kZWNvZGVRdWVyeSh2LmpvaW4oJz0nKSwgZXNjYXBlUXVlcnlTcGFjZSkgOiBudWxsO1xuXG4gICAgICBpZiAobmFtZSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgLy8gaWdub3JlIGF0dGVtcHQgYXQgZXhwbG9pdGluZyBKYXZhU2NyaXB0IGludGVybmFsc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duLmNhbGwoaXRlbXMsIG5hbWUpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbXNbbmFtZV0gPT09ICdzdHJpbmcnIHx8IGl0ZW1zW25hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgaXRlbXNbbmFtZV0gPSBbaXRlbXNbbmFtZV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXNbbmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICBVUkkuYnVpbGQgPSBmdW5jdGlvbihwYXJ0cykge1xuICAgIHZhciB0ID0gJyc7XG4gICAgdmFyIHJlcXVpcmVBYnNvbHV0ZVBhdGggPSBmYWxzZVxuXG4gICAgaWYgKHBhcnRzLnByb3RvY29sKSB7XG4gICAgICB0ICs9IHBhcnRzLnByb3RvY29sICsgJzonO1xuICAgIH1cblxuICAgIGlmICghcGFydHMudXJuICYmICh0IHx8IHBhcnRzLmhvc3RuYW1lKSkge1xuICAgICAgdCArPSAnLy8nO1xuICAgICAgcmVxdWlyZUFic29sdXRlUGF0aCA9IHRydWVcbiAgICB9XG5cbiAgICB0ICs9IChVUkkuYnVpbGRBdXRob3JpdHkocGFydHMpIHx8ICcnKTtcblxuICAgIGlmICh0eXBlb2YgcGFydHMucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChwYXJ0cy5wYXRoLmNoYXJBdCgwKSAhPT0gJy8nICYmIHJlcXVpcmVBYnNvbHV0ZVBhdGgpIHtcbiAgICAgICAgdCArPSAnLyc7XG4gICAgICB9XG5cbiAgICAgIHQgKz0gcGFydHMucGF0aDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBhcnRzLnF1ZXJ5ID09PSAnc3RyaW5nJyAmJiBwYXJ0cy5xdWVyeSkge1xuICAgICAgdCArPSAnPycgKyBwYXJ0cy5xdWVyeTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBhcnRzLmZyYWdtZW50ID09PSAnc3RyaW5nJyAmJiBwYXJ0cy5mcmFnbWVudCkge1xuICAgICAgdCArPSAnIycgKyBwYXJ0cy5mcmFnbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG4gIFVSSS5idWlsZEhvc3QgPSBmdW5jdGlvbihwYXJ0cykge1xuICAgIHZhciB0ID0gJyc7XG5cbiAgICBpZiAoIXBhcnRzLmhvc3RuYW1lKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmIChVUkkuaXA2X2V4cHJlc3Npb24udGVzdChwYXJ0cy5ob3N0bmFtZSkpIHtcbiAgICAgIHQgKz0gJ1snICsgcGFydHMuaG9zdG5hbWUgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQgKz0gcGFydHMuaG9zdG5hbWU7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRzLnBvcnQpIHtcbiAgICAgIHQgKz0gJzonICsgcGFydHMucG9ydDtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcbiAgVVJJLmJ1aWxkQXV0aG9yaXR5ID0gZnVuY3Rpb24ocGFydHMpIHtcbiAgICByZXR1cm4gVVJJLmJ1aWxkVXNlcmluZm8ocGFydHMpICsgVVJJLmJ1aWxkSG9zdChwYXJ0cyk7XG4gIH07XG4gIFVSSS5idWlsZFVzZXJpbmZvID0gZnVuY3Rpb24ocGFydHMpIHtcbiAgICB2YXIgdCA9ICcnO1xuXG4gICAgaWYgKHBhcnRzLnVzZXJuYW1lKSB7XG4gICAgICB0ICs9IFVSSS5lbmNvZGUocGFydHMudXNlcm5hbWUpO1xuICAgIH1cblxuICAgIGlmIChwYXJ0cy5wYXNzd29yZCkge1xuICAgICAgdCArPSAnOicgKyBVUkkuZW5jb2RlKHBhcnRzLnBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICBpZiAodCkge1xuICAgICAgdCArPSAnQCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG4gIFVSSS5idWlsZFF1ZXJ5ID0gZnVuY3Rpb24oZGF0YSwgZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzLCBlc2NhcGVRdWVyeVNwYWNlKSB7XG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYgb3IgaHR0cDovL2xhYnMuYXBhY2hlLm9yZy93ZWJhcmNoL3VyaS9yZmMvcmZjMzk4Ni5odG1sXG4gICAgLy8gYmVpbmcgwrstLl9+ISQmJygpKissOz06QC8/wqsgJUhFWCBhbmQgYWxudW0gYXJlIGFsbG93ZWRcbiAgICAvLyB0aGUgUkZDIGV4cGxpY2l0bHkgc3RhdGVzID8vZm9vIGJlaW5nIGEgdmFsaWQgdXNlIGNhc2UsIG5vIG1lbnRpb24gb2YgcGFyYW1ldGVyIHN5bnRheCFcbiAgICAvLyBVUkkuanMgdHJlYXRzIHRoZSBxdWVyeSBzdHJpbmcgYXMgYmVpbmcgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy1odG1sNDAvaW50ZXJhY3QvZm9ybXMuaHRtbCNmb3JtLWNvbnRlbnQtdHlwZVxuXG4gICAgdmFyIHQgPSAnJztcbiAgICB2YXIgdW5pcXVlLCBrZXksIGksIGxlbmd0aDtcbiAgICBmb3IgKGtleSBpbiBkYXRhKSB7XG4gICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgICAvLyBpZ25vcmUgYXR0ZW1wdCBhdCBleHBsb2l0aW5nIEphdmFTY3JpcHQgaW50ZXJuYWxzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChoYXNPd24uY2FsbChkYXRhLCBrZXkpKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGRhdGFba2V5XSkpIHtcbiAgICAgICAgICB1bmlxdWUgPSB7fTtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBkYXRhW2tleV0ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkYXRhW2tleV1baV0gIT09IHVuZGVmaW5lZCAmJiB1bmlxdWVbZGF0YVtrZXldW2ldICsgJyddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdCArPSAnJicgKyBVUkkuYnVpbGRRdWVyeVBhcmFtZXRlcihrZXksIGRhdGFba2V5XVtpXSwgZXNjYXBlUXVlcnlTcGFjZSk7XG4gICAgICAgICAgICAgIGlmIChkdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB1bmlxdWVbZGF0YVtrZXldW2ldICsgJyddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHQgKz0gJyYnICsgVVJJLmJ1aWxkUXVlcnlQYXJhbWV0ZXIoa2V5LCBkYXRhW2tleV0sIGVzY2FwZVF1ZXJ5U3BhY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHQuc3Vic3RyaW5nKDEpO1xuICB9O1xuICBVUkkuYnVpbGRRdWVyeVBhcmFtZXRlciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBlc2NhcGVRdWVyeVNwYWNlKSB7XG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLWh0bWw0MC9pbnRlcmFjdC9mb3Jtcy5odG1sI2Zvcm0tY29udGVudC10eXBlIC0tIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICAgIC8vIGRvbid0IGFwcGVuZCBcIj1cIiBmb3IgbnVsbCB2YWx1ZXMsIGFjY29yZGluZyB0byBodHRwOi8vZHZjcy53My5vcmcvaGcvdXJsL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sI3VybC1wYXJhbWV0ZXItc2VyaWFsaXphdGlvblxuICAgIHJldHVybiBVUkkuZW5jb2RlUXVlcnkobmFtZSwgZXNjYXBlUXVlcnlTcGFjZSkgKyAodmFsdWUgIT09IG51bGwgPyAnPScgKyBVUkkuZW5jb2RlUXVlcnkodmFsdWUsIGVzY2FwZVF1ZXJ5U3BhY2UpIDogJycpO1xuICB9O1xuXG4gIFVSSS5hZGRRdWVyeSA9IGZ1bmN0aW9uKGRhdGEsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgICAgaWYgKGhhc093bi5jYWxsKG5hbWUsIGtleSkpIHtcbiAgICAgICAgICBVUkkuYWRkUXVlcnkoZGF0YSwga2V5LCBuYW1lW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChkYXRhW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0YVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhW25hbWVdID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhW25hbWVdID0gW2RhdGFbbmFtZV1dO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgIH1cblxuICAgICAgZGF0YVtuYW1lXSA9IChkYXRhW25hbWVdIHx8IFtdKS5jb25jYXQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVUkkuYWRkUXVlcnkoKSBhY2NlcHRzIGFuIG9iamVjdCwgc3RyaW5nIGFzIHRoZSBuYW1lIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgfTtcblxuICBVUkkuc2V0UXVlcnkgPSBmdW5jdGlvbihkYXRhLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbChuYW1lLCBrZXkpKSB7XG4gICAgICAgICAgVVJJLnNldFF1ZXJ5KGRhdGEsIGtleSwgbmFtZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRhW25hbWVdID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVVJJLnNldFF1ZXJ5KCkgYWNjZXB0cyBhbiBvYmplY3QsIHN0cmluZyBhcyB0aGUgbmFtZSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gIH07XG5cbiAgVVJJLnJlbW92ZVF1ZXJ5ID0gZnVuY3Rpb24oZGF0YSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaSwgbGVuZ3RoLCBrZXk7XG5cbiAgICBpZiAoaXNBcnJheShuYW1lKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gbmFtZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW25hbWVbaV1dID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ2V0VHlwZShuYW1lKSA9PT0gJ1JlZ0V4cCcpIHtcbiAgICAgIGZvciAoa2V5IGluIGRhdGEpIHtcbiAgICAgICAgaWYgKG5hbWUudGVzdChrZXkpKSB7XG4gICAgICAgICAgZGF0YVtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAoa2V5IGluIG5hbWUpIHtcbiAgICAgICAgaWYgKGhhc093bi5jYWxsKG5hbWUsIGtleSkpIHtcbiAgICAgICAgICBVUkkucmVtb3ZlUXVlcnkoZGF0YSwga2V5LCBuYW1lW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChnZXRUeXBlKHZhbHVlKSA9PT0gJ1JlZ0V4cCcpIHtcbiAgICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YVtuYW1lXSkgJiYgdmFsdWUudGVzdChkYXRhW25hbWVdKSkge1xuICAgICAgICAgICAgZGF0YVtuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YVtuYW1lXSA9IGZpbHRlckFycmF5VmFsdWVzKGRhdGFbbmFtZV0sIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVtuYW1lXSA9PT0gU3RyaW5nKHZhbHVlKSAmJiAoIWlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgICAgICBkYXRhW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YVtuYW1lXSkpIHtcbiAgICAgICAgICBkYXRhW25hbWVdID0gZmlsdGVyQXJyYXlWYWx1ZXMoZGF0YVtuYW1lXSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVUkkucmVtb3ZlUXVlcnkoKSBhY2NlcHRzIGFuIG9iamVjdCwgc3RyaW5nLCBSZWdFeHAgYXMgdGhlIGZpcnN0IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgfTtcbiAgVVJJLmhhc1F1ZXJ5ID0gZnVuY3Rpb24oZGF0YSwgbmFtZSwgdmFsdWUsIHdpdGhpbkFycmF5KSB7XG4gICAgc3dpdGNoIChnZXRUeXBlKG5hbWUpKSB7XG4gICAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGhlcmVcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKGhhc093bi5jYWxsKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChuYW1lLnRlc3Qoa2V5KSAmJiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCBVUkkuaGFzUXVlcnkoZGF0YSwga2V5LCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgZm9yICh2YXIgX2tleSBpbiBuYW1lKSB7XG4gICAgICAgICAgaWYgKGhhc093bi5jYWxsKG5hbWUsIF9rZXkpKSB7XG4gICAgICAgICAgICBpZiAoIVVSSS5oYXNRdWVyeShkYXRhLCBfa2V5LCBuYW1lW19rZXldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VSSS5oYXNRdWVyeSgpIGFjY2VwdHMgYSBzdHJpbmcsIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBvYmplY3QgYXMgdGhlIG5hbWUgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChnZXRUeXBlKHZhbHVlKSkge1xuICAgICAgY2FzZSAnVW5kZWZpbmVkJzpcbiAgICAgICAgLy8gdHJ1ZSBpZiBleGlzdHMgKGJ1dCBtYXkgYmUgZW1wdHkpXG4gICAgICAgIHJldHVybiBuYW1lIGluIGRhdGE7IC8vIGRhdGFbbmFtZV0gIT09IHVuZGVmaW5lZDtcblxuICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgIC8vIHRydWUgaWYgZXhpc3RzIGFuZCBub24tZW1wdHlcbiAgICAgICAgdmFyIF9ib29seSA9IEJvb2xlYW4oaXNBcnJheShkYXRhW25hbWVdKSA/IGRhdGFbbmFtZV0ubGVuZ3RoIDogZGF0YVtuYW1lXSk7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gX2Jvb2x5O1xuXG4gICAgICBjYXNlICdGdW5jdGlvbic6XG4gICAgICAgIC8vIGFsbG93IGNvbXBsZXggY29tcGFyaXNvblxuICAgICAgICByZXR1cm4gISF2YWx1ZShkYXRhW25hbWVdLCBuYW1lLCBkYXRhKTtcblxuICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YVtuYW1lXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3AgPSB3aXRoaW5BcnJheSA/IGFycmF5Q29udGFpbnMgOiBhcnJheXNFcXVhbDtcbiAgICAgICAgcmV0dXJuIG9wKGRhdGFbbmFtZV0sIHZhbHVlKTtcblxuICAgICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgICAgaWYgKCFpc0FycmF5KGRhdGFbbmFtZV0pKSB7XG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZGF0YVtuYW1lXSAmJiBkYXRhW25hbWVdLm1hdGNoKHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXdpdGhpbkFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5Q29udGFpbnMoZGF0YVtuYW1lXSwgdmFsdWUpO1xuXG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICAgIGlmICghaXNBcnJheShkYXRhW25hbWVdKSkge1xuICAgICAgICAgIHJldHVybiBkYXRhW25hbWVdID09PSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghd2l0aGluQXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXlDb250YWlucyhkYXRhW25hbWVdLCB2YWx1ZSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VSSS5oYXNRdWVyeSgpIGFjY2VwdHMgdW5kZWZpbmVkLCBib29sZWFuLCBzdHJpbmcsIG51bWJlciwgUmVnRXhwLCBGdW5jdGlvbiBhcyB0aGUgdmFsdWUgcGFyYW1ldGVyJyk7XG4gICAgfVxuICB9O1xuXG5cbiAgVVJJLmpvaW5QYXRocyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbnB1dCA9IFtdO1xuICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgIHZhciBub25FbXB0eVNlZ21lbnRzID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdXJsID0gbmV3IFVSSShhcmd1bWVudHNbaV0pO1xuICAgICAgaW5wdXQucHVzaCh1cmwpO1xuICAgICAgdmFyIF9zZWdtZW50cyA9IHVybC5zZWdtZW50KCk7XG4gICAgICBmb3IgKHZhciBzID0gMDsgcyA8IF9zZWdtZW50cy5sZW5ndGg7IHMrKykge1xuICAgICAgICBpZiAodHlwZW9mIF9zZWdtZW50c1tzXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzZWdtZW50cy5wdXNoKF9zZWdtZW50c1tzXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3NlZ21lbnRzW3NdKSB7XG4gICAgICAgICAgbm9uRW1wdHlTZWdtZW50cysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGggfHwgIW5vbkVtcHR5U2VnbWVudHMpIHtcbiAgICAgIHJldHVybiBuZXcgVVJJKCcnKTtcbiAgICB9XG5cbiAgICB2YXIgdXJpID0gbmV3IFVSSSgnJykuc2VnbWVudChzZWdtZW50cyk7XG5cbiAgICBpZiAoaW5wdXRbMF0ucGF0aCgpID09PSAnJyB8fCBpbnB1dFswXS5wYXRoKCkuc2xpY2UoMCwgMSkgPT09ICcvJykge1xuICAgICAgdXJpLnBhdGgoJy8nICsgdXJpLnBhdGgoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVyaS5ub3JtYWxpemUoKTtcbiAgfTtcblxuICBVUkkuY29tbW9uUGF0aCA9IGZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKG9uZS5sZW5ndGgsIHR3by5sZW5ndGgpO1xuICAgIHZhciBwb3M7XG5cbiAgICAvLyBmaW5kIGZpcnN0IG5vbi1tYXRjaGluZyBjaGFyYWN0ZXJcbiAgICBmb3IgKHBvcyA9IDA7IHBvcyA8IGxlbmd0aDsgcG9zKyspIHtcbiAgICAgIGlmIChvbmUuY2hhckF0KHBvcykgIT09IHR3by5jaGFyQXQocG9zKSkge1xuICAgICAgICBwb3MtLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvcyA8IDEpIHtcbiAgICAgIHJldHVybiBvbmUuY2hhckF0KDApID09PSB0d28uY2hhckF0KDApICYmIG9uZS5jaGFyQXQoMCkgPT09ICcvJyA/ICcvJyA6ICcnO1xuICAgIH1cblxuICAgIC8vIHJldmVydCB0byBsYXN0IC9cbiAgICBpZiAob25lLmNoYXJBdChwb3MpICE9PSAnLycgfHwgdHdvLmNoYXJBdChwb3MpICE9PSAnLycpIHtcbiAgICAgIHBvcyA9IG9uZS5zdWJzdHJpbmcoMCwgcG9zKS5sYXN0SW5kZXhPZignLycpO1xuICAgIH1cblxuICAgIHJldHVybiBvbmUuc3Vic3RyaW5nKDAsIHBvcyArIDEpO1xuICB9O1xuXG4gIFVSSS53aXRoaW5TdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB2YXIgX3N0YXJ0ID0gb3B0aW9ucy5zdGFydCB8fCBVUkkuZmluZFVyaS5zdGFydDtcbiAgICB2YXIgX2VuZCA9IG9wdGlvbnMuZW5kIHx8IFVSSS5maW5kVXJpLmVuZDtcbiAgICB2YXIgX3RyaW0gPSBvcHRpb25zLnRyaW0gfHwgVVJJLmZpbmRVcmkudHJpbTtcbiAgICB2YXIgX3BhcmVucyA9IG9wdGlvbnMucGFyZW5zIHx8IFVSSS5maW5kVXJpLnBhcmVucztcbiAgICB2YXIgX2F0dHJpYnV0ZU9wZW4gPSAvW2EtejAtOS1dPVtcIiddPyQvaTtcblxuICAgIF9zdGFydC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBfc3RhcnQuZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0ID0gbWF0Y2guaW5kZXg7XG4gICAgICBpZiAob3B0aW9ucy5pZ25vcmVIdG1sKSB7XG4gICAgICAgIC8vIGF0dHJpYnV0KGU9W1wiJ10/JClcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU9wZW4gPSBzdHJpbmcuc2xpY2UoTWF0aC5tYXgoc3RhcnQgLSAzLCAwKSwgc3RhcnQpO1xuICAgICAgICBpZiAoYXR0cmlidXRlT3BlbiAmJiBfYXR0cmlidXRlT3Blbi50ZXN0KGF0dHJpYnV0ZU9wZW4pKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgc3RyaW5nLnNsaWNlKHN0YXJ0KS5zZWFyY2goX2VuZCk7XG4gICAgICB2YXIgc2xpY2UgPSBzdHJpbmcuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgaW5jbHVkZSB3ZWxsIGJhbGFuY2VkIHBhcmVuc1xuICAgICAgdmFyIHBhcmVuc0VuZCA9IC0xO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHBhcmVuc01hdGNoID0gX3BhcmVucy5leGVjKHNsaWNlKTtcbiAgICAgICAgaWYgKCFwYXJlbnNNYXRjaCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVuc01hdGNoRW5kID0gcGFyZW5zTWF0Y2guaW5kZXggKyBwYXJlbnNNYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHBhcmVuc0VuZCA9IE1hdGgubWF4KHBhcmVuc0VuZCwgcGFyZW5zTWF0Y2hFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW5zRW5kID4gLTEpIHtcbiAgICAgICAgc2xpY2UgPSBzbGljZS5zbGljZSgwLCBwYXJlbnNFbmQpICsgc2xpY2Uuc2xpY2UocGFyZW5zRW5kKS5yZXBsYWNlKF90cmltLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGljZSA9IHNsaWNlLnJlcGxhY2UoX3RyaW0sICcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNsaWNlLmxlbmd0aCA8PSBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgLy8gdGhlIGV4dHJhY3Qgb25seSBjb250YWlucyB0aGUgc3RhcnRpbmcgbWFya2VyIG9mIGEgVVJJLFxuICAgICAgICAvLyBlLmcuIFwid3d3XCIgb3IgXCJodHRwOi8vXCJcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmlnbm9yZSAmJiBvcHRpb25zLmlnbm9yZS50ZXN0KHNsaWNlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZW5kID0gc3RhcnQgKyBzbGljZS5sZW5ndGg7XG4gICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soc2xpY2UsIHN0YXJ0LCBlbmQsIHN0cmluZyk7XG4gICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3N0YXJ0Lmxhc3RJbmRleCA9IGVuZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IFN0cmluZyhyZXN1bHQpO1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIHN0YXJ0KSArIHJlc3VsdCArIHN0cmluZy5zbGljZShlbmQpO1xuICAgICAgX3N0YXJ0Lmxhc3RJbmRleCA9IHN0YXJ0ICsgcmVzdWx0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBfc3RhcnQubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xuXG4gIFVSSS5lbnN1cmVWYWxpZEhvc3RuYW1lID0gZnVuY3Rpb24odiwgcHJvdG9jb2wpIHtcbiAgICAvLyBUaGVvcmV0aWNhbGx5IFVSSXMgYWxsb3cgcGVyY2VudC1lbmNvZGluZyBpbiBIb3N0bmFtZXMgKGFjY29yZGluZyB0byBSRkMgMzk4NilcbiAgICAvLyB0aGV5IGFyZSBub3QgcGFydCBvZiBETlMgYW5kIHRoZXJlZm9yZSBpZ25vcmVkIGJ5IFVSSS5qc1xuXG4gICAgdmFyIGhhc0hvc3RuYW1lID0gISF2OyAvLyBub3QgbnVsbCBhbmQgbm90IGFuIGVtcHR5IHN0cmluZ1xuICAgIHZhciBoYXNQcm90b2NvbCA9ICEhcHJvdG9jb2w7XG4gICAgdmFyIHJlamVjdEVtcHR5SG9zdG5hbWUgPSBmYWxzZTtcblxuICAgIGlmIChoYXNQcm90b2NvbCkge1xuICAgICAgcmVqZWN0RW1wdHlIb3N0bmFtZSA9IGFycmF5Q29udGFpbnMoVVJJLmhvc3RQcm90b2NvbHMsIHByb3RvY29sKTtcbiAgICB9XG5cbiAgICBpZiAocmVqZWN0RW1wdHlIb3N0bmFtZSAmJiAhaGFzSG9zdG5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hvc3RuYW1lIGNhbm5vdCBiZSBlbXB0eSwgaWYgcHJvdG9jb2wgaXMgJyArIHByb3RvY29sKTtcbiAgICB9IGVsc2UgaWYgKHYgJiYgdi5tYXRjaChVUkkuaW52YWxpZF9ob3N0bmFtZV9jaGFyYWN0ZXJzKSkge1xuICAgICAgLy8gdGVzdCBwdW55Y29kZVxuICAgICAgaWYgKCFwdW55Y29kZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIb3N0bmFtZSBcIicgKyB2ICsgJ1wiIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBbQS1aMC05Li06X10gYW5kIFB1bnljb2RlLmpzIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChwdW55Y29kZS50b0FTQ0lJKHYpLm1hdGNoKFVSSS5pbnZhbGlkX2hvc3RuYW1lX2NoYXJhY3RlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hvc3RuYW1lIFwiJyArIHYgKyAnXCIgY29udGFpbnMgY2hhcmFjdGVycyBvdGhlciB0aGFuIFtBLVowLTkuLTpfXScpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBVUkkuZW5zdXJlVmFsaWRQb3J0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAoIXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9ydCA9IE51bWJlcih2KTtcbiAgICBpZiAoaXNJbnRlZ2VyKHBvcnQpICYmIChwb3J0ID4gMCkgJiYgKHBvcnQgPCA2NTUzNikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQb3J0IFwiJyArIHYgKyAnXCIgaXMgbm90IGEgdmFsaWQgcG9ydCcpO1xuICB9O1xuXG4gIC8vIG5vQ29uZmxpY3RcbiAgVVJJLm5vQ29uZmxpY3QgPSBmdW5jdGlvbihyZW1vdmVBbGwpIHtcbiAgICBpZiAocmVtb3ZlQWxsKSB7XG4gICAgICB2YXIgdW5jb25mbGljdGVkID0ge1xuICAgICAgICBVUkk6IHRoaXMubm9Db25mbGljdCgpXG4gICAgICB9O1xuXG4gICAgICBpZiAocm9vdC5VUklUZW1wbGF0ZSAmJiB0eXBlb2Ygcm9vdC5VUklUZW1wbGF0ZS5ub0NvbmZsaWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHVuY29uZmxpY3RlZC5VUklUZW1wbGF0ZSA9IHJvb3QuVVJJVGVtcGxhdGUubm9Db25mbGljdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocm9vdC5JUHY2ICYmIHR5cGVvZiByb290LklQdjYubm9Db25mbGljdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB1bmNvbmZsaWN0ZWQuSVB2NiA9IHJvb3QuSVB2Ni5ub0NvbmZsaWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyb290LlNlY29uZExldmVsRG9tYWlucyAmJiB0eXBlb2Ygcm9vdC5TZWNvbmRMZXZlbERvbWFpbnMubm9Db25mbGljdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB1bmNvbmZsaWN0ZWQuU2Vjb25kTGV2ZWxEb21haW5zID0gcm9vdC5TZWNvbmRMZXZlbERvbWFpbnMubm9Db25mbGljdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5jb25mbGljdGVkO1xuICAgIH0gZWxzZSBpZiAocm9vdC5VUkkgPT09IHRoaXMpIHtcbiAgICAgIHJvb3QuVVJJID0gX1VSSTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwLmJ1aWxkID0gZnVuY3Rpb24oZGVmZXJCdWlsZCkge1xuICAgIGlmIChkZWZlckJ1aWxkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9kZWZlcnJlZF9idWlsZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkZWZlckJ1aWxkID09PSB1bmRlZmluZWQgfHwgdGhpcy5fZGVmZXJyZWRfYnVpbGQpIHtcbiAgICAgIHRoaXMuX3N0cmluZyA9IFVSSS5idWlsZCh0aGlzLl9wYXJ0cyk7XG4gICAgICB0aGlzLl9kZWZlcnJlZF9idWlsZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFVSSSh0aGlzKTtcbiAgfTtcblxuICBwLnZhbHVlT2YgPSBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGQoZmFsc2UpLl9zdHJpbmc7XG4gIH07XG5cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVNpbXBsZUFjY2Vzc29yKF9wYXJ0KXtcbiAgICByZXR1cm4gZnVuY3Rpb24odiwgYnVpbGQpIHtcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRzW19wYXJ0XSB8fCAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcnRzW19wYXJ0XSA9IHYgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVQcmVmaXhBY2Nlc3NvcihfcGFydCwgX2tleSl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJ0c1tfcGFydF0gfHwgJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodiAhPT0gbnVsbCkge1xuICAgICAgICAgIHYgPSB2ICsgJyc7XG4gICAgICAgICAgaWYgKHYuY2hhckF0KDApID09PSBfa2V5KSB7XG4gICAgICAgICAgICB2ID0gdi5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGFydHNbX3BhcnRdID0gdjtcbiAgICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcC5wcm90b2NvbCA9IGdlbmVyYXRlU2ltcGxlQWNjZXNzb3IoJ3Byb3RvY29sJyk7XG4gIHAudXNlcm5hbWUgPSBnZW5lcmF0ZVNpbXBsZUFjY2Vzc29yKCd1c2VybmFtZScpO1xuICBwLnBhc3N3b3JkID0gZ2VuZXJhdGVTaW1wbGVBY2Nlc3NvcigncGFzc3dvcmQnKTtcbiAgcC5ob3N0bmFtZSA9IGdlbmVyYXRlU2ltcGxlQWNjZXNzb3IoJ2hvc3RuYW1lJyk7XG4gIHAucG9ydCA9IGdlbmVyYXRlU2ltcGxlQWNjZXNzb3IoJ3BvcnQnKTtcbiAgcC5xdWVyeSA9IGdlbmVyYXRlUHJlZml4QWNjZXNzb3IoJ3F1ZXJ5JywgJz8nKTtcbiAgcC5mcmFnbWVudCA9IGdlbmVyYXRlUHJlZml4QWNjZXNzb3IoJ2ZyYWdtZW50JywgJyMnKTtcblxuICBwLnNlYXJjaCA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgdmFyIHQgPSB0aGlzLnF1ZXJ5KHYsIGJ1aWxkKTtcbiAgICByZXR1cm4gdHlwZW9mIHQgPT09ICdzdHJpbmcnICYmIHQubGVuZ3RoID8gKCc/JyArIHQpIDogdDtcbiAgfTtcbiAgcC5oYXNoID0gZnVuY3Rpb24odiwgYnVpbGQpIHtcbiAgICB2YXIgdCA9IHRoaXMuZnJhZ21lbnQodiwgYnVpbGQpO1xuICAgIHJldHVybiB0eXBlb2YgdCA9PT0gJ3N0cmluZycgJiYgdC5sZW5ndGggPyAoJyMnICsgdCkgOiB0O1xuICB9O1xuXG4gIHAucGF0aG5hbWUgPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMuX3BhcnRzLnBhdGggfHwgKHRoaXMuX3BhcnRzLmhvc3RuYW1lID8gJy8nIDogJycpO1xuICAgICAgcmV0dXJuIHYgPyAodGhpcy5fcGFydHMudXJuID8gVVJJLmRlY29kZVVyblBhdGggOiBVUkkuZGVjb2RlUGF0aCkocmVzKSA6IHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgICB0aGlzLl9wYXJ0cy5wYXRoID0gdiA/IFVSSS5yZWNvZGVVcm5QYXRoKHYpIDogJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJ0cy5wYXRoID0gdiA/IFVSSS5yZWNvZGVQYXRoKHYpIDogJy8nO1xuICAgICAgfVxuICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBwLnBhdGggPSBwLnBhdGhuYW1lO1xuICBwLmhyZWYgPSBmdW5jdGlvbihocmVmLCBidWlsZCkge1xuICAgIHZhciBrZXk7XG5cbiAgICBpZiAoaHJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0cmluZyA9ICcnO1xuICAgIHRoaXMuX3BhcnRzID0gVVJJLl9wYXJ0cygpO1xuXG4gICAgdmFyIF9VUkkgPSBocmVmIGluc3RhbmNlb2YgVVJJO1xuICAgIHZhciBfb2JqZWN0ID0gdHlwZW9mIGhyZWYgPT09ICdvYmplY3QnICYmIChocmVmLmhvc3RuYW1lIHx8IGhyZWYucGF0aCB8fCBocmVmLnBhdGhuYW1lKTtcbiAgICBpZiAoaHJlZi5ub2RlTmFtZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZSA9IFVSSS5nZXREb21BdHRyaWJ1dGUoaHJlZik7XG4gICAgICBocmVmID0gaHJlZlthdHRyaWJ1dGVdIHx8ICcnO1xuICAgICAgX29iamVjdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHdpbmRvdy5sb2NhdGlvbiBpcyByZXBvcnRlZCB0byBiZSBhbiBvYmplY3QsIGJ1dCBpdCdzIG5vdCB0aGUgc29ydFxuICAgIC8vIG9mIG9iamVjdCB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAqIGxvY2F0aW9uLnByb3RvY29sIGVuZHMgd2l0aCBhIGNvbG9uXG4gICAgLy8gKiBsb2NhdGlvbi5xdWVyeSAhPSBvYmplY3Quc2VhcmNoXG4gICAgLy8gKiBsb2NhdGlvbi5oYXNoICE9IG9iamVjdC5mcmFnbWVudFxuICAgIC8vIHNpbXBseSBzZXJpYWxpemluZyB0aGUgdW5rbm93biBvYmplY3Qgc2hvdWxkIGRvIHRoZSB0cmlja1xuICAgIC8vIChmb3IgbG9jYXRpb24sIG5vdCBmb3IgZXZlcnl0aGluZy4uLilcbiAgICBpZiAoIV9VUkkgJiYgX29iamVjdCAmJiBocmVmLnBhdGhuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhyZWYgPSBocmVmLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyB8fCBocmVmIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICB0aGlzLl9wYXJ0cyA9IFVSSS5wYXJzZShTdHJpbmcoaHJlZiksIHRoaXMuX3BhcnRzKTtcbiAgICB9IGVsc2UgaWYgKF9VUkkgfHwgX29iamVjdCkge1xuICAgICAgdmFyIHNyYyA9IF9VUkkgPyBocmVmLl9wYXJ0cyA6IGhyZWY7XG4gICAgICBmb3IgKGtleSBpbiBzcmMpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ3F1ZXJ5JykgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoaGFzT3duLmNhbGwodGhpcy5fcGFydHMsIGtleSkpIHtcbiAgICAgICAgICB0aGlzLl9wYXJ0c1trZXldID0gc3JjW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzcmMucXVlcnkpIHtcbiAgICAgICAgdGhpcy5xdWVyeShzcmMucXVlcnksIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpbnB1dCcpO1xuICAgIH1cblxuICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBpZGVudGlmaWNhdGlvbiBhY2Nlc3NvcnNcbiAgcC5pcyA9IGZ1bmN0aW9uKHdoYXQpIHtcbiAgICB2YXIgaXAgPSBmYWxzZTtcbiAgICB2YXIgaXA0ID0gZmFsc2U7XG4gICAgdmFyIGlwNiA9IGZhbHNlO1xuICAgIHZhciBuYW1lID0gZmFsc2U7XG4gICAgdmFyIHNsZCA9IGZhbHNlO1xuICAgIHZhciBpZG4gPSBmYWxzZTtcbiAgICB2YXIgcHVueWNvZGUgPSBmYWxzZTtcbiAgICB2YXIgcmVsYXRpdmUgPSAhdGhpcy5fcGFydHMudXJuO1xuXG4gICAgaWYgKHRoaXMuX3BhcnRzLmhvc3RuYW1lKSB7XG4gICAgICByZWxhdGl2ZSA9IGZhbHNlO1xuICAgICAgaXA0ID0gVVJJLmlwNF9leHByZXNzaW9uLnRlc3QodGhpcy5fcGFydHMuaG9zdG5hbWUpO1xuICAgICAgaXA2ID0gVVJJLmlwNl9leHByZXNzaW9uLnRlc3QodGhpcy5fcGFydHMuaG9zdG5hbWUpO1xuICAgICAgaXAgPSBpcDQgfHwgaXA2O1xuICAgICAgbmFtZSA9ICFpcDtcbiAgICAgIHNsZCA9IG5hbWUgJiYgU0xEICYmIFNMRC5oYXModGhpcy5fcGFydHMuaG9zdG5hbWUpO1xuICAgICAgaWRuID0gbmFtZSAmJiBVUkkuaWRuX2V4cHJlc3Npb24udGVzdCh0aGlzLl9wYXJ0cy5ob3N0bmFtZSk7XG4gICAgICBwdW55Y29kZSA9IG5hbWUgJiYgVVJJLnB1bnljb2RlX2V4cHJlc3Npb24udGVzdCh0aGlzLl9wYXJ0cy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3aGF0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ3JlbGF0aXZlJzpcbiAgICAgICAgcmV0dXJuIHJlbGF0aXZlO1xuXG4gICAgICBjYXNlICdhYnNvbHV0ZSc6XG4gICAgICAgIHJldHVybiAhcmVsYXRpdmU7XG5cbiAgICAgIC8vIGhvc3RuYW1lIGlkZW50aWZpY2F0aW9uXG4gICAgICBjYXNlICdkb21haW4nOlxuICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgIHJldHVybiBuYW1lO1xuXG4gICAgICBjYXNlICdzbGQnOlxuICAgICAgICByZXR1cm4gc2xkO1xuXG4gICAgICBjYXNlICdpcCc6XG4gICAgICAgIHJldHVybiBpcDtcblxuICAgICAgY2FzZSAnaXA0JzpcbiAgICAgIGNhc2UgJ2lwdjQnOlxuICAgICAgY2FzZSAnaW5ldDQnOlxuICAgICAgICByZXR1cm4gaXA0O1xuXG4gICAgICBjYXNlICdpcDYnOlxuICAgICAgY2FzZSAnaXB2Nic6XG4gICAgICBjYXNlICdpbmV0Nic6XG4gICAgICAgIHJldHVybiBpcDY7XG5cbiAgICAgIGNhc2UgJ2lkbic6XG4gICAgICAgIHJldHVybiBpZG47XG5cbiAgICAgIGNhc2UgJ3VybCc6XG4gICAgICAgIHJldHVybiAhdGhpcy5fcGFydHMudXJuO1xuXG4gICAgICBjYXNlICd1cm4nOlxuICAgICAgICByZXR1cm4gISF0aGlzLl9wYXJ0cy51cm47XG5cbiAgICAgIGNhc2UgJ3B1bnljb2RlJzpcbiAgICAgICAgcmV0dXJuIHB1bnljb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8vIGNvbXBvbmVudCBzcGVjaWZpYyBpbnB1dCB2YWxpZGF0aW9uXG4gIHZhciBfcHJvdG9jb2wgPSBwLnByb3RvY29sO1xuICB2YXIgX3BvcnQgPSBwLnBvcnQ7XG4gIHZhciBfaG9zdG5hbWUgPSBwLmhvc3RuYW1lO1xuXG4gIHAucHJvdG9jb2wgPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh2KSB7XG4gICAgICAvLyBhY2NlcHQgdHJhaWxpbmcgOi8vXG4gICAgICB2ID0gdi5yZXBsYWNlKC86KFxcL1xcLyk/JC8sICcnKTtcblxuICAgICAgaWYgKCF2Lm1hdGNoKFVSSS5wcm90b2NvbF9leHByZXNzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm90b2NvbCBcIicgKyB2ICsgJ1wiIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBbQS1aMC05ListXSBvciBkb2VzblxcJ3Qgc3RhcnQgd2l0aCBbQS1aXScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfcHJvdG9jb2wuY2FsbCh0aGlzLCB2LCBidWlsZCk7XG4gIH07XG4gIHAuc2NoZW1lID0gcC5wcm90b2NvbDtcbiAgcC5wb3J0ID0gZnVuY3Rpb24odiwgYnVpbGQpIHtcbiAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7XG4gICAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkID8gJycgOiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh2ID09PSAwKSB7XG4gICAgICAgIHYgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodikge1xuICAgICAgICB2ICs9ICcnO1xuICAgICAgICBpZiAodi5jaGFyQXQoMCkgPT09ICc6Jykge1xuICAgICAgICAgIHYgPSB2LnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFVSSS5lbnN1cmVWYWxpZFBvcnQodik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcG9ydC5jYWxsKHRoaXMsIHYsIGJ1aWxkKTtcbiAgfTtcbiAgcC5ob3N0bmFtZSA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCA/ICcnIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgeCA9IHsgcHJldmVudEludmFsaWRIb3N0bmFtZTogdGhpcy5fcGFydHMucHJldmVudEludmFsaWRIb3N0bmFtZSB9O1xuICAgICAgdmFyIHJlcyA9IFVSSS5wYXJzZUhvc3QodiwgeCk7XG4gICAgICBpZiAocmVzICE9PSAnLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSG9zdG5hbWUgXCInICsgdiArICdcIiBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gW0EtWjAtOS4tXScpO1xuICAgICAgfVxuXG4gICAgICB2ID0geC5ob3N0bmFtZTtcbiAgICAgIGlmICh0aGlzLl9wYXJ0cy5wcmV2ZW50SW52YWxpZEhvc3RuYW1lKSB7XG4gICAgICAgIFVSSS5lbnN1cmVWYWxpZEhvc3RuYW1lKHYsIHRoaXMuX3BhcnRzLnByb3RvY29sKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2hvc3RuYW1lLmNhbGwodGhpcywgdiwgYnVpbGQpO1xuICB9O1xuXG4gIC8vIGNvbXBvdW5kIGFjY2Vzc29yc1xuICBwLm9yaWdpbiA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCA/ICcnIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sKCk7XG4gICAgICB2YXIgYXV0aG9yaXR5ID0gdGhpcy5hdXRob3JpdHkoKTtcbiAgICAgIGlmICghYXV0aG9yaXR5KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChwcm90b2NvbCA/IHByb3RvY29sICsgJzovLycgOiAnJykgKyB0aGlzLmF1dGhvcml0eSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3JpZ2luID0gVVJJKHYpO1xuICAgICAgdGhpc1xuICAgICAgICAucHJvdG9jb2wob3JpZ2luLnByb3RvY29sKCkpXG4gICAgICAgIC5hdXRob3JpdHkob3JpZ2luLmF1dGhvcml0eSgpKVxuICAgICAgICAuYnVpbGQoIWJ1aWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcC5ob3N0ID0gZnVuY3Rpb24odiwgYnVpbGQpIHtcbiAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7XG4gICAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkID8gJycgOiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJ0cy5ob3N0bmFtZSA/IFVSSS5idWlsZEhvc3QodGhpcy5fcGFydHMpIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSBVUkkucGFyc2VIb3N0KHYsIHRoaXMuX3BhcnRzKTtcbiAgICAgIGlmIChyZXMgIT09ICcvJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIb3N0bmFtZSBcIicgKyB2ICsgJ1wiIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBbQS1aMC05Li1dJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcC5hdXRob3JpdHkgPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgPyAnJyA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnRzLmhvc3RuYW1lID8gVVJJLmJ1aWxkQXV0aG9yaXR5KHRoaXMuX3BhcnRzKSA6ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzID0gVVJJLnBhcnNlQXV0aG9yaXR5KHYsIHRoaXMuX3BhcnRzKTtcbiAgICAgIGlmIChyZXMgIT09ICcvJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIb3N0bmFtZSBcIicgKyB2ICsgJ1wiIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBbQS1aMC05Li1dJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcC51c2VyaW5mbyA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCA/ICcnIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdCA9IFVSSS5idWlsZFVzZXJpbmZvKHRoaXMuX3BhcnRzKTtcbiAgICAgIHJldHVybiB0ID8gdC5zdWJzdHJpbmcoMCwgdC5sZW5ndGggLTEpIDogdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZbdi5sZW5ndGgtMV0gIT09ICdAJykge1xuICAgICAgICB2ICs9ICdAJztcbiAgICAgIH1cblxuICAgICAgVVJJLnBhcnNlVXNlcmluZm8odiwgdGhpcy5fcGFydHMpO1xuICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBwLnJlc291cmNlID0gZnVuY3Rpb24odiwgYnVpbGQpIHtcbiAgICB2YXIgcGFydHM7XG5cbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoKCkgKyB0aGlzLnNlYXJjaCgpICsgdGhpcy5oYXNoKCk7XG4gICAgfVxuXG4gICAgcGFydHMgPSBVUkkucGFyc2Uodik7XG4gICAgdGhpcy5fcGFydHMucGF0aCA9IHBhcnRzLnBhdGg7XG4gICAgdGhpcy5fcGFydHMucXVlcnkgPSBwYXJ0cy5xdWVyeTtcbiAgICB0aGlzLl9wYXJ0cy5mcmFnbWVudCA9IHBhcnRzLmZyYWdtZW50O1xuICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBmcmFjdGlvbiBhY2Nlc3NvcnNcbiAgcC5zdWJkb21haW4gPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgPyAnJyA6IHRoaXM7XG4gICAgfVxuXG4gICAgLy8gY29udmVuaWVuY2UsIHJldHVybiBcInd3d1wiIGZyb20gXCJ3d3cuZXhhbXBsZS5vcmdcIlxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghdGhpcy5fcGFydHMuaG9zdG5hbWUgfHwgdGhpcy5pcygnSVAnKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIGdyYWIgZG9tYWluIGFuZCBhZGQgYW5vdGhlciBzZWdtZW50XG4gICAgICB2YXIgZW5kID0gdGhpcy5fcGFydHMuaG9zdG5hbWUubGVuZ3RoIC0gdGhpcy5kb21haW4oKS5sZW5ndGggLSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnRzLmhvc3RuYW1lLnN1YnN0cmluZygwLCBlbmQpIHx8ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX3BhcnRzLmhvc3RuYW1lLmxlbmd0aCAtIHRoaXMuZG9tYWluKCkubGVuZ3RoO1xuICAgICAgdmFyIHN1YiA9IHRoaXMuX3BhcnRzLmhvc3RuYW1lLnN1YnN0cmluZygwLCBlKTtcbiAgICAgIHZhciByZXBsYWNlID0gbmV3IFJlZ0V4cCgnXicgKyBlc2NhcGVSZWdFeChzdWIpKTtcblxuICAgICAgaWYgKHYgJiYgdi5jaGFyQXQodi5sZW5ndGggLSAxKSAhPT0gJy4nKSB7XG4gICAgICAgIHYgKz0gJy4nO1xuICAgICAgfVxuXG4gICAgICBpZiAodi5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RvbWFpbnMgY2Fubm90IGNvbnRhaW4gY29sb25zJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2KSB7XG4gICAgICAgIFVSSS5lbnN1cmVWYWxpZEhvc3RuYW1lKHYsIHRoaXMuX3BhcnRzLnByb3RvY29sKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGFydHMuaG9zdG5hbWUgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5yZXBsYWNlKHJlcGxhY2UsIHYpO1xuICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBwLmRvbWFpbiA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCA/ICcnIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHYgPT09ICdib29sZWFuJykge1xuICAgICAgYnVpbGQgPSB2O1xuICAgICAgdiA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBjb252ZW5pZW5jZSwgcmV0dXJuIFwiZXhhbXBsZS5vcmdcIiBmcm9tIFwid3d3LmV4YW1wbGUub3JnXCJcbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhcnRzLmhvc3RuYW1lIHx8IHRoaXMuaXMoJ0lQJykpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBob3N0bmFtZSBjb25zaXN0cyBvZiAxIG9yIDIgc2VnbWVudHMsIGl0IG11c3QgYmUgdGhlIGRvbWFpblxuICAgICAgdmFyIHQgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5tYXRjaCgvXFwuL2cpO1xuICAgICAgaWYgKHQgJiYgdC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJ0cy5ob3N0bmFtZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ3JhYiB0bGQgYW5kIGFkZCBhbm90aGVyIHNlZ21lbnRcbiAgICAgIHZhciBlbmQgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5sZW5ndGggLSB0aGlzLnRsZChidWlsZCkubGVuZ3RoIC0gMTtcbiAgICAgIGVuZCA9IHRoaXMuX3BhcnRzLmhvc3RuYW1lLmxhc3RJbmRleE9mKCcuJywgZW5kIC0xKSArIDE7XG4gICAgICByZXR1cm4gdGhpcy5fcGFydHMuaG9zdG5hbWUuc3Vic3RyaW5nKGVuZCkgfHwgJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IGRvbWFpbiBlbXB0eScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodi5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RvbWFpbnMgY2Fubm90IGNvbnRhaW4gY29sb25zJyk7XG4gICAgICB9XG5cbiAgICAgIFVSSS5lbnN1cmVWYWxpZEhvc3RuYW1lKHYsIHRoaXMuX3BhcnRzLnByb3RvY29sKTtcblxuICAgICAgaWYgKCF0aGlzLl9wYXJ0cy5ob3N0bmFtZSB8fCB0aGlzLmlzKCdJUCcpKSB7XG4gICAgICAgIHRoaXMuX3BhcnRzLmhvc3RuYW1lID0gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeCh0aGlzLmRvbWFpbigpKSArICckJyk7XG4gICAgICAgIHRoaXMuX3BhcnRzLmhvc3RuYW1lID0gdGhpcy5fcGFydHMuaG9zdG5hbWUucmVwbGFjZShyZXBsYWNlLCB2KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBwLnRsZCA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCA/ICcnIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHYgPT09ICdib29sZWFuJykge1xuICAgICAgYnVpbGQgPSB2O1xuICAgICAgdiA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gXCJvcmdcIiBmcm9tIFwid3d3LmV4YW1wbGUub3JnXCJcbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhcnRzLmhvc3RuYW1lIHx8IHRoaXMuaXMoJ0lQJykpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zID0gdGhpcy5fcGFydHMuaG9zdG5hbWUubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIHZhciB0bGQgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5zdWJzdHJpbmcocG9zICsgMSk7XG5cbiAgICAgIGlmIChidWlsZCAhPT0gdHJ1ZSAmJiBTTEQgJiYgU0xELmxpc3RbdGxkLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIHJldHVybiBTTEQuZ2V0KHRoaXMuX3BhcnRzLmhvc3RuYW1lKSB8fCB0bGQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0bGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXBsYWNlO1xuXG4gICAgICBpZiAoIXYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBUTEQgZW1wdHknKTtcbiAgICAgIH0gZWxzZSBpZiAodi5tYXRjaCgvW15hLXpBLVowLTktXS8pKSB7XG4gICAgICAgIGlmIChTTEQgJiYgU0xELmlzKHYpKSB7XG4gICAgICAgICAgcmVwbGFjZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXgodGhpcy50bGQoKSkgKyAnJCcpO1xuICAgICAgICAgIHRoaXMuX3BhcnRzLmhvc3RuYW1lID0gdGhpcy5fcGFydHMuaG9zdG5hbWUucmVwbGFjZShyZXBsYWNlLCB2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUTEQgXCInICsgdiArICdcIiBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gW0EtWjAtOV0nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5fcGFydHMuaG9zdG5hbWUgfHwgdGhpcy5pcygnSVAnKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ2Nhbm5vdCBzZXQgVExEIG9uIG5vbi1kb21haW4gaG9zdCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbGFjZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXgodGhpcy50bGQoKSkgKyAnJCcpO1xuICAgICAgICB0aGlzLl9wYXJ0cy5ob3N0bmFtZSA9IHRoaXMuX3BhcnRzLmhvc3RuYW1lLnJlcGxhY2UocmVwbGFjZSwgdik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcC5kaXJlY3RvcnkgPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgPyAnJyA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSB0cnVlKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhcnRzLnBhdGggJiYgIXRoaXMuX3BhcnRzLmhvc3RuYW1lKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BhcnRzLnBhdGggPT09ICcvJykge1xuICAgICAgICByZXR1cm4gJy8nO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW5kID0gdGhpcy5fcGFydHMucGF0aC5sZW5ndGggLSB0aGlzLmZpbGVuYW1lKCkubGVuZ3RoIC0gMTtcbiAgICAgIHZhciByZXMgPSB0aGlzLl9wYXJ0cy5wYXRoLnN1YnN0cmluZygwLCBlbmQpIHx8ICh0aGlzLl9wYXJ0cy5ob3N0bmFtZSA/ICcvJyA6ICcnKTtcblxuICAgICAgcmV0dXJuIHYgPyBVUkkuZGVjb2RlUGF0aChyZXMpIDogcmVzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlID0gdGhpcy5fcGFydHMucGF0aC5sZW5ndGggLSB0aGlzLmZpbGVuYW1lKCkubGVuZ3RoO1xuICAgICAgdmFyIGRpcmVjdG9yeSA9IHRoaXMuX3BhcnRzLnBhdGguc3Vic3RyaW5nKDAsIGUpO1xuICAgICAgdmFyIHJlcGxhY2UgPSBuZXcgUmVnRXhwKCdeJyArIGVzY2FwZVJlZ0V4KGRpcmVjdG9yeSkpO1xuXG4gICAgICAvLyBmdWxseSBxdWFsaWZpZXIgZGlyZWN0b3JpZXMgYmVnaW4gd2l0aCBhIHNsYXNoXG4gICAgICBpZiAoIXRoaXMuaXMoJ3JlbGF0aXZlJykpIHtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgdiA9ICcvJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2LmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgICAgdiA9ICcvJyArIHY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0b3JpZXMgYWx3YXlzIGVuZCB3aXRoIGEgc2xhc2hcbiAgICAgIGlmICh2ICYmIHYuY2hhckF0KHYubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgICB2ICs9ICcvJztcbiAgICAgIH1cblxuICAgICAgdiA9IFVSSS5yZWNvZGVQYXRoKHYpO1xuICAgICAgdGhpcy5fcGFydHMucGF0aCA9IHRoaXMuX3BhcnRzLnBhdGgucmVwbGFjZShyZXBsYWNlLCB2KTtcbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcC5maWxlbmFtZSA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCA/ICcnIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHYgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhcnRzLnBhdGggfHwgdGhpcy5fcGFydHMucGF0aCA9PT0gJy8nKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHBvcyA9IHRoaXMuX3BhcnRzLnBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgIHZhciByZXMgPSB0aGlzLl9wYXJ0cy5wYXRoLnN1YnN0cmluZyhwb3MrMSk7XG5cbiAgICAgIHJldHVybiB2ID8gVVJJLmRlY29kZVBhdGhTZWdtZW50KHJlcykgOiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtdXRhdGVkRGlyZWN0b3J5ID0gZmFsc2U7XG5cbiAgICAgIGlmICh2LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgIHYgPSB2LnN1YnN0cmluZygxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHYubWF0Y2goL1xcLj9cXC8vKSkge1xuICAgICAgICBtdXRhdGVkRGlyZWN0b3J5ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcGxhY2UgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4KHRoaXMuZmlsZW5hbWUoKSkgKyAnJCcpO1xuICAgICAgdiA9IFVSSS5yZWNvZGVQYXRoKHYpO1xuICAgICAgdGhpcy5fcGFydHMucGF0aCA9IHRoaXMuX3BhcnRzLnBhdGgucmVwbGFjZShyZXBsYWNlLCB2KTtcblxuICAgICAgaWYgKG11dGF0ZWREaXJlY3RvcnkpIHtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVQYXRoKGJ1aWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBwLnN1ZmZpeCA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCA/ICcnIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IHRydWUpIHtcbiAgICAgIGlmICghdGhpcy5fcGFydHMucGF0aCB8fCB0aGlzLl9wYXJ0cy5wYXRoID09PSAnLycpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lKCk7XG4gICAgICB2YXIgcG9zID0gZmlsZW5hbWUubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIHZhciBzLCByZXM7XG5cbiAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgLy8gc3VmZml4IG1heSBvbmx5IGNvbnRhaW4gYWxudW0gY2hhcmFjdGVycyAoeXVwLCBJIG1hZGUgdGhpcyB1cC4pXG4gICAgICBzID0gZmlsZW5hbWUuc3Vic3RyaW5nKHBvcysxKTtcbiAgICAgIHJlcyA9ICgvXlthLXowLTklXSskL2kpLnRlc3QocykgPyBzIDogJyc7XG4gICAgICByZXR1cm4gdiA/IFVSSS5kZWNvZGVQYXRoU2VnbWVudChyZXMpIDogcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodi5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICB2ID0gdi5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWZmaXggPSB0aGlzLnN1ZmZpeCgpO1xuICAgICAgdmFyIHJlcGxhY2U7XG5cbiAgICAgIGlmICghc3VmZml4KSB7XG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGFydHMucGF0aCArPSAnLicgKyBVUkkucmVjb2RlUGF0aCh2KTtcbiAgICAgIH0gZWxzZSBpZiAoIXYpIHtcbiAgICAgICAgcmVwbGFjZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXgoJy4nICsgc3VmZml4KSArICckJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeChzdWZmaXgpICsgJyQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgdiA9IFVSSS5yZWNvZGVQYXRoKHYpO1xuICAgICAgICB0aGlzLl9wYXJ0cy5wYXRoID0gdGhpcy5fcGFydHMucGF0aC5yZXBsYWNlKHJlcGxhY2UsIHYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHAuc2VnbWVudCA9IGZ1bmN0aW9uKHNlZ21lbnQsIHYsIGJ1aWxkKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9IHRoaXMuX3BhcnRzLnVybiA/ICc6JyA6ICcvJztcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCgpO1xuICAgIHZhciBhYnNvbHV0ZSA9IHBhdGguc3Vic3RyaW5nKDAsIDEpID09PSAnLyc7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdChzZXBhcmF0b3IpO1xuXG4gICAgaWYgKHNlZ21lbnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc2VnbWVudCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGJ1aWxkID0gdjtcbiAgICAgIHYgPSBzZWdtZW50O1xuICAgICAgc2VnbWVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoc2VnbWVudCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzZWdtZW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgc2VnbWVudCBcIicgKyBzZWdtZW50ICsgJ1wiLCBtdXN0IGJlIDAtYmFzZWQgaW50ZWdlcicpO1xuICAgIH1cblxuICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgc2VnbWVudHMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICBpZiAoc2VnbWVudCA8IDApIHtcbiAgICAgIC8vIGFsbG93IG5lZ2F0aXZlIGluZGV4ZXMgdG8gYWRkcmVzcyBmcm9tIHRoZSBlbmRcbiAgICAgIHNlZ21lbnQgPSBNYXRoLm1heChzZWdtZW50cy5sZW5ndGggKyBzZWdtZW50LCAwKTtcbiAgICB9XG5cbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKmpzaGludCBsYXhicmVhazogdHJ1ZSAqL1xuICAgICAgcmV0dXJuIHNlZ21lbnQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHNlZ21lbnRzXG4gICAgICAgIDogc2VnbWVudHNbc2VnbWVudF07XG4gICAgICAvKmpzaGludCBsYXhicmVhazogZmFsc2UgKi9cbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgPT09IG51bGwgfHwgc2VnbWVudHNbc2VnbWVudF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGlzQXJyYXkodikpIHtcbiAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgLy8gY29sbGFwc2UgZW1wdHkgZWxlbWVudHMgd2l0aGluIGFycmF5XG4gICAgICAgIGZvciAodmFyIGk9MCwgbD12Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmICghdltpXS5sZW5ndGggJiYgKCFzZWdtZW50cy5sZW5ndGggfHwgIXNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtMV0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCAmJiAhc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0xXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlZ21lbnRzLnB1c2godHJpbVNsYXNoZXModltpXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHYgfHwgdHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHYgPSB0cmltU2xhc2hlcyh2KTtcbiAgICAgICAgaWYgKHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtMV0gPT09ICcnKSB7XG4gICAgICAgICAgLy8gZW1wdHkgdHJhaWxpbmcgZWxlbWVudHMgaGF2ZSB0byBiZSBvdmVyd3JpdHRlblxuICAgICAgICAgIC8vIHRvIHByZXZlbnQgcmVzdWx0cyBzdWNoIGFzIC9mb28vL2JhclxuICAgICAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtMV0gPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZ21lbnRzLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHYpIHtcbiAgICAgICAgc2VnbWVudHNbc2VnbWVudF0gPSB0cmltU2xhc2hlcyh2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZ21lbnRzLnNwbGljZShzZWdtZW50LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgIHNlZ21lbnRzLnVuc2hpZnQoJycpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhdGgoc2VnbWVudHMuam9pbihzZXBhcmF0b3IpLCBidWlsZCk7XG4gIH07XG4gIHAuc2VnbWVudENvZGVkID0gZnVuY3Rpb24oc2VnbWVudCwgdiwgYnVpbGQpIHtcbiAgICB2YXIgc2VnbWVudHMsIGksIGw7XG5cbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgIT09ICdudW1iZXInKSB7XG4gICAgICBidWlsZCA9IHY7XG4gICAgICB2ID0gc2VnbWVudDtcbiAgICAgIHNlZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnQoc2VnbWVudCwgdiwgYnVpbGQpO1xuICAgICAgaWYgKCFpc0FycmF5KHNlZ21lbnRzKSkge1xuICAgICAgICBzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBVUkkuZGVjb2RlKHNlZ21lbnRzKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBzZWdtZW50c1tpXSA9IFVSSS5kZWNvZGUoc2VnbWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWdtZW50cztcbiAgICB9XG5cbiAgICBpZiAoIWlzQXJyYXkodikpIHtcbiAgICAgIHYgPSAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHYgaW5zdGFuY2VvZiBTdHJpbmcpID8gVVJJLmVuY29kZSh2KSA6IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2W2ldID0gVVJJLmVuY29kZSh2W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZWdtZW50KHNlZ21lbnQsIHYsIGJ1aWxkKTtcbiAgfTtcblxuICAvLyBtdXRhdGluZyBxdWVyeSBzdHJpbmdcbiAgdmFyIHEgPSBwLnF1ZXJ5O1xuICBwLnF1ZXJ5ID0gZnVuY3Rpb24odiwgYnVpbGQpIHtcbiAgICBpZiAodiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIFVSSS5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZGF0YSA9IFVSSS5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTtcbiAgICAgIHZhciByZXN1bHQgPSB2LmNhbGwodGhpcywgZGF0YSk7XG4gICAgICB0aGlzLl9wYXJ0cy5xdWVyeSA9IFVSSS5idWlsZFF1ZXJ5KHJlc3VsdCB8fCBkYXRhLCB0aGlzLl9wYXJ0cy5kdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMsIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpO1xuICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICh2ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHYgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9wYXJ0cy5xdWVyeSA9IFVSSS5idWlsZFF1ZXJ5KHYsIHRoaXMuX3BhcnRzLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycywgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7XG4gICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHEuY2FsbCh0aGlzLCB2LCBidWlsZCk7XG4gICAgfVxuICB9O1xuICBwLnNldFF1ZXJ5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIGJ1aWxkKSB7XG4gICAgdmFyIGRhdGEgPSBVUkkucGFyc2VRdWVyeSh0aGlzLl9wYXJ0cy5xdWVyeSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7XG5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnIHx8IG5hbWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIGRhdGFbbmFtZV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgICBpZiAoaGFzT3duLmNhbGwobmFtZSwga2V5KSkge1xuICAgICAgICAgIGRhdGFba2V5XSA9IG5hbWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVUkkuYWRkUXVlcnkoKSBhY2NlcHRzIGFuIG9iamVjdCwgc3RyaW5nIGFzIHRoZSBuYW1lIHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhcnRzLnF1ZXJ5ID0gVVJJLmJ1aWxkUXVlcnkoZGF0YSwgdGhpcy5fcGFydHMuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzLCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBidWlsZCA9IHZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcC5hZGRRdWVyeSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBidWlsZCkge1xuICAgIHZhciBkYXRhID0gVVJJLnBhcnNlUXVlcnkodGhpcy5fcGFydHMucXVlcnksIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpO1xuICAgIFVSSS5hZGRRdWVyeShkYXRhLCBuYW1lLCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZhbHVlKTtcbiAgICB0aGlzLl9wYXJ0cy5xdWVyeSA9IFVSSS5idWlsZFF1ZXJ5KGRhdGEsIHRoaXMuX3BhcnRzLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycywgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgYnVpbGQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHAucmVtb3ZlUXVlcnkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgYnVpbGQpIHtcbiAgICB2YXIgZGF0YSA9IFVSSS5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTtcbiAgICBVUkkucmVtb3ZlUXVlcnkoZGF0YSwgbmFtZSwgdmFsdWUpO1xuICAgIHRoaXMuX3BhcnRzLnF1ZXJ5ID0gVVJJLmJ1aWxkUXVlcnkoZGF0YSwgdGhpcy5fcGFydHMuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzLCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBidWlsZCA9IHZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcC5oYXNRdWVyeSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCB3aXRoaW5BcnJheSkge1xuICAgIHZhciBkYXRhID0gVVJJLnBhcnNlUXVlcnkodGhpcy5fcGFydHMucXVlcnksIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpO1xuICAgIHJldHVybiBVUkkuaGFzUXVlcnkoZGF0YSwgbmFtZSwgdmFsdWUsIHdpdGhpbkFycmF5KTtcbiAgfTtcbiAgcC5zZXRTZWFyY2ggPSBwLnNldFF1ZXJ5O1xuICBwLmFkZFNlYXJjaCA9IHAuYWRkUXVlcnk7XG4gIHAucmVtb3ZlU2VhcmNoID0gcC5yZW1vdmVRdWVyeTtcbiAgcC5oYXNTZWFyY2ggPSBwLmhhc1F1ZXJ5O1xuXG4gIC8vIHNhbml0aXppbmcgVVJMc1xuICBwLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIC5ub3JtYWxpemVQcm90b2NvbChmYWxzZSlcbiAgICAgICAgLm5vcm1hbGl6ZVBhdGgoZmFsc2UpXG4gICAgICAgIC5ub3JtYWxpemVRdWVyeShmYWxzZSlcbiAgICAgICAgLm5vcm1hbGl6ZUZyYWdtZW50KGZhbHNlKVxuICAgICAgICAuYnVpbGQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICAgICAgLm5vcm1hbGl6ZVByb3RvY29sKGZhbHNlKVxuICAgICAgLm5vcm1hbGl6ZUhvc3RuYW1lKGZhbHNlKVxuICAgICAgLm5vcm1hbGl6ZVBvcnQoZmFsc2UpXG4gICAgICAubm9ybWFsaXplUGF0aChmYWxzZSlcbiAgICAgIC5ub3JtYWxpemVRdWVyeShmYWxzZSlcbiAgICAgIC5ub3JtYWxpemVGcmFnbWVudChmYWxzZSlcbiAgICAgIC5idWlsZCgpO1xuICB9O1xuICBwLm5vcm1hbGl6ZVByb3RvY29sID0gZnVuY3Rpb24oYnVpbGQpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3BhcnRzLnByb3RvY29sID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fcGFydHMucHJvdG9jb2wgPSB0aGlzLl9wYXJ0cy5wcm90b2NvbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBwLm5vcm1hbGl6ZUhvc3RuYW1lID0gZnVuY3Rpb24oYnVpbGQpIHtcbiAgICBpZiAodGhpcy5fcGFydHMuaG9zdG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLmlzKCdJRE4nKSAmJiBwdW55Y29kZSkge1xuICAgICAgICB0aGlzLl9wYXJ0cy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5fcGFydHMuaG9zdG5hbWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzKCdJUHY2JykgJiYgSVB2Nikge1xuICAgICAgICB0aGlzLl9wYXJ0cy5ob3N0bmFtZSA9IElQdjYuYmVzdCh0aGlzLl9wYXJ0cy5ob3N0bmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BhcnRzLmhvc3RuYW1lID0gdGhpcy5fcGFydHMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcC5ub3JtYWxpemVQb3J0ID0gZnVuY3Rpb24oYnVpbGQpIHtcbiAgICAvLyByZW1vdmUgcG9ydCBvZiBpdCdzIHRoZSBwcm90b2NvbCdzIGRlZmF1bHRcbiAgICBpZiAodHlwZW9mIHRoaXMuX3BhcnRzLnByb3RvY29sID09PSAnc3RyaW5nJyAmJiB0aGlzLl9wYXJ0cy5wb3J0ID09PSBVUkkuZGVmYXVsdFBvcnRzW3RoaXMuX3BhcnRzLnByb3RvY29sXSkge1xuICAgICAgdGhpcy5fcGFydHMucG9ydCA9IG51bGw7XG4gICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHAubm9ybWFsaXplUGF0aCA9IGZ1bmN0aW9uKGJ1aWxkKSB7XG4gICAgdmFyIF9wYXRoID0gdGhpcy5fcGFydHMucGF0aDtcbiAgICBpZiAoIV9wYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7XG4gICAgICB0aGlzLl9wYXJ0cy5wYXRoID0gVVJJLnJlY29kZVVyblBhdGgodGhpcy5fcGFydHMucGF0aCk7XG4gICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGFydHMucGF0aCA9PT0gJy8nKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfcGF0aCA9IFVSSS5yZWNvZGVQYXRoKF9wYXRoKTtcblxuICAgIHZhciBfd2FzX3JlbGF0aXZlO1xuICAgIHZhciBfbGVhZGluZ1BhcmVudHMgPSAnJztcbiAgICB2YXIgX3BhcmVudCwgX3BvcztcblxuICAgIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRoc1xuICAgIGlmIChfcGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgX3dhc19yZWxhdGl2ZSA9IHRydWU7XG4gICAgICBfcGF0aCA9ICcvJyArIF9wYXRoO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSByZWxhdGl2ZSBmaWxlcyAoYXMgb3Bwb3NlZCB0byBkaXJlY3RvcmllcylcbiAgICBpZiAoX3BhdGguc2xpY2UoLTMpID09PSAnLy4uJyB8fCBfcGF0aC5zbGljZSgtMikgPT09ICcvLicpIHtcbiAgICAgIF9wYXRoICs9ICcvJztcbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIHNpbXBsZXNcbiAgICBfcGF0aCA9IF9wYXRoXG4gICAgICAucmVwbGFjZSgvKFxcLyhcXC5cXC8pKyl8KFxcL1xcLiQpL2csICcvJylcbiAgICAgIC5yZXBsYWNlKC9cXC97Mix9L2csICcvJyk7XG5cbiAgICAvLyByZW1lbWJlciBsZWFkaW5nIHBhcmVudHNcbiAgICBpZiAoX3dhc19yZWxhdGl2ZSkge1xuICAgICAgX2xlYWRpbmdQYXJlbnRzID0gX3BhdGguc3Vic3RyaW5nKDEpLm1hdGNoKC9eKFxcLlxcLlxcLykrLykgfHwgJyc7XG4gICAgICBpZiAoX2xlYWRpbmdQYXJlbnRzKSB7XG4gICAgICAgIF9sZWFkaW5nUGFyZW50cyA9IF9sZWFkaW5nUGFyZW50c1swXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIHBhcmVudHNcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgX3BhcmVudCA9IF9wYXRoLnNlYXJjaCgvXFwvXFwuXFwuKFxcL3wkKS8pO1xuICAgICAgaWYgKF9wYXJlbnQgPT09IC0xKSB7XG4gICAgICAgIC8vIG5vIG1vcmUgLi4vIHRvIHJlc29sdmVcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKF9wYXJlbnQgPT09IDApIHtcbiAgICAgICAgLy8gdG9wIGxldmVsIGNhbm5vdCBiZSByZWxhdGl2ZSwgc2tpcCBpdFxuICAgICAgICBfcGF0aCA9IF9wYXRoLnN1YnN0cmluZygzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIF9wb3MgPSBfcGF0aC5zdWJzdHJpbmcoMCwgX3BhcmVudCkubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgIGlmIChfcG9zID09PSAtMSkge1xuICAgICAgICBfcG9zID0gX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIF9wYXRoID0gX3BhdGguc3Vic3RyaW5nKDAsIF9wb3MpICsgX3BhdGguc3Vic3RyaW5nKF9wYXJlbnQgKyAzKTtcbiAgICB9XG5cbiAgICAvLyByZXZlcnQgdG8gcmVsYXRpdmVcbiAgICBpZiAoX3dhc19yZWxhdGl2ZSAmJiB0aGlzLmlzKCdyZWxhdGl2ZScpKSB7XG4gICAgICBfcGF0aCA9IF9sZWFkaW5nUGFyZW50cyArIF9wYXRoLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJ0cy5wYXRoID0gX3BhdGg7XG4gICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBwLm5vcm1hbGl6ZVBhdGhuYW1lID0gcC5ub3JtYWxpemVQYXRoO1xuICBwLm5vcm1hbGl6ZVF1ZXJ5ID0gZnVuY3Rpb24oYnVpbGQpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3BhcnRzLnF1ZXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCF0aGlzLl9wYXJ0cy5xdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcGFydHMucXVlcnkgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdWVyeShVUkkucGFyc2VRdWVyeSh0aGlzLl9wYXJ0cy5xdWVyeSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHAubm9ybWFsaXplRnJhZ21lbnQgPSBmdW5jdGlvbihidWlsZCkge1xuICAgIGlmICghdGhpcy5fcGFydHMuZnJhZ21lbnQpIHtcbiAgICAgIHRoaXMuX3BhcnRzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcC5ub3JtYWxpemVTZWFyY2ggPSBwLm5vcm1hbGl6ZVF1ZXJ5O1xuICBwLm5vcm1hbGl6ZUhhc2ggPSBwLm5vcm1hbGl6ZUZyYWdtZW50O1xuXG4gIHAuaXNvODg1OSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGV4cGVjdCB1bmljb2RlIGlucHV0LCBpc284ODU5IG91dHB1dFxuICAgIHZhciBlID0gVVJJLmVuY29kZTtcbiAgICB2YXIgZCA9IFVSSS5kZWNvZGU7XG5cbiAgICBVUkkuZW5jb2RlID0gZXNjYXBlO1xuICAgIFVSSS5kZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubm9ybWFsaXplKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFVSSS5lbmNvZGUgPSBlO1xuICAgICAgVVJJLmRlY29kZSA9IGQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHAudW5pY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGV4cGVjdCBpc284ODU5IGlucHV0LCB1bmljb2RlIG91dHB1dFxuICAgIHZhciBlID0gVVJJLmVuY29kZTtcbiAgICB2YXIgZCA9IFVSSS5kZWNvZGU7XG5cbiAgICBVUkkuZW5jb2RlID0gc3RyaWN0RW5jb2RlVVJJQ29tcG9uZW50O1xuICAgIFVSSS5kZWNvZGUgPSB1bmVzY2FwZTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5ub3JtYWxpemUoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgVVJJLmVuY29kZSA9IGU7XG4gICAgICBVUkkuZGVjb2RlID0gZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcC5yZWFkYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB1cmkgPSB0aGlzLmNsb25lKCk7XG4gICAgLy8gcmVtb3ZpbmcgdXNlcm5hbWUsIHBhc3N3b3JkLCBiZWNhdXNlIHRoZXkgc2hvdWxkbid0IGJlIGRpc3BsYXllZCBhY2NvcmRpbmcgdG8gUkZDIDM5ODZcbiAgICB1cmkudXNlcm5hbWUoJycpLnBhc3N3b3JkKCcnKS5ub3JtYWxpemUoKTtcbiAgICB2YXIgdCA9ICcnO1xuICAgIGlmICh1cmkuX3BhcnRzLnByb3RvY29sKSB7XG4gICAgICB0ICs9IHVyaS5fcGFydHMucHJvdG9jb2wgKyAnOi8vJztcbiAgICB9XG5cbiAgICBpZiAodXJpLl9wYXJ0cy5ob3N0bmFtZSkge1xuICAgICAgaWYgKHVyaS5pcygncHVueWNvZGUnKSAmJiBwdW55Y29kZSkge1xuICAgICAgICB0ICs9IHB1bnljb2RlLnRvVW5pY29kZSh1cmkuX3BhcnRzLmhvc3RuYW1lKTtcbiAgICAgICAgaWYgKHVyaS5fcGFydHMucG9ydCkge1xuICAgICAgICAgIHQgKz0gJzonICsgdXJpLl9wYXJ0cy5wb3J0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ICs9IHVyaS5ob3N0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVyaS5fcGFydHMuaG9zdG5hbWUgJiYgdXJpLl9wYXJ0cy5wYXRoICYmIHVyaS5fcGFydHMucGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgdCArPSAnLyc7XG4gICAgfVxuXG4gICAgdCArPSB1cmkucGF0aCh0cnVlKTtcbiAgICBpZiAodXJpLl9wYXJ0cy5xdWVyeSkge1xuICAgICAgdmFyIHEgPSAnJztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBxcCA9IHVyaS5fcGFydHMucXVlcnkuc3BsaXQoJyYnKSwgbCA9IHFwLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga3YgPSAocXBbaV0gfHwgJycpLnNwbGl0KCc9Jyk7XG4gICAgICAgIHEgKz0gJyYnICsgVVJJLmRlY29kZVF1ZXJ5KGt2WzBdLCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKVxuICAgICAgICAgIC5yZXBsYWNlKC8mL2csICclMjYnKTtcblxuICAgICAgICBpZiAoa3ZbMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHEgKz0gJz0nICsgVVJJLmRlY29kZVF1ZXJ5KGt2WzFdLCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyUyNicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ICs9ICc/JyArIHEuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIHQgKz0gVVJJLmRlY29kZVF1ZXJ5KHVyaS5oYXNoKCksIHRydWUpO1xuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIHJlc29sdmluZyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgVVJMc1xuICBwLmFic29sdXRlVG8gPSBmdW5jdGlvbihiYXNlKSB7XG4gICAgdmFyIHJlc29sdmVkID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBwcm9wZXJ0aWVzID0gWydwcm90b2NvbCcsICd1c2VybmFtZScsICdwYXNzd29yZCcsICdob3N0bmFtZScsICdwb3J0J107XG4gICAgdmFyIGJhc2VkaXIsIGksIHA7XG5cbiAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTnMgZG8gbm90IGhhdmUgYW55IGdlbmVyYWxseSBkZWZpbmVkIGhpZXJhcmNoaWNhbCBjb21wb25lbnRzJyk7XG4gICAgfVxuXG4gICAgaWYgKCEoYmFzZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICAgIGJhc2UgPSBuZXcgVVJJKGJhc2UpO1xuICAgIH1cblxuICAgIGlmIChyZXNvbHZlZC5fcGFydHMucHJvdG9jb2wpIHtcbiAgICAgIC8vIERpcmVjdGx5IHJldHVybnMgZXZlbiBpZiB0aGlzLl9wYXJ0cy5ob3N0bmFtZSBpcyBlbXB0eS5cbiAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZWQuX3BhcnRzLnByb3RvY29sID0gYmFzZS5fcGFydHMucHJvdG9jb2w7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhcnRzLmhvc3RuYW1lKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgKHAgPSBwcm9wZXJ0aWVzW2ldKTsgaSsrKSB7XG4gICAgICByZXNvbHZlZC5fcGFydHNbcF0gPSBiYXNlLl9wYXJ0c1twXTtcbiAgICB9XG5cbiAgICBpZiAoIXJlc29sdmVkLl9wYXJ0cy5wYXRoKSB7XG4gICAgICByZXNvbHZlZC5fcGFydHMucGF0aCA9IGJhc2UuX3BhcnRzLnBhdGg7XG4gICAgICBpZiAoIXJlc29sdmVkLl9wYXJ0cy5xdWVyeSkge1xuICAgICAgICByZXNvbHZlZC5fcGFydHMucXVlcnkgPSBiYXNlLl9wYXJ0cy5xdWVyeTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlc29sdmVkLl9wYXJ0cy5wYXRoLnN1YnN0cmluZygtMikgPT09ICcuLicpIHtcbiAgICAgICAgcmVzb2x2ZWQuX3BhcnRzLnBhdGggKz0gJy8nO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzb2x2ZWQucGF0aCgpLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgIGJhc2VkaXIgPSBiYXNlLmRpcmVjdG9yeSgpO1xuICAgICAgICBiYXNlZGlyID0gYmFzZWRpciA/IGJhc2VkaXIgOiBiYXNlLnBhdGgoKS5pbmRleE9mKCcvJykgPT09IDAgPyAnLycgOiAnJztcbiAgICAgICAgcmVzb2x2ZWQuX3BhcnRzLnBhdGggPSAoYmFzZWRpciA/IChiYXNlZGlyICsgJy8nKSA6ICcnKSArIHJlc29sdmVkLl9wYXJ0cy5wYXRoO1xuICAgICAgICByZXNvbHZlZC5ub3JtYWxpemVQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzb2x2ZWQuYnVpbGQoKTtcbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gIH07XG4gIHAucmVsYXRpdmVUbyA9IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICB2YXIgcmVsYXRpdmUgPSB0aGlzLmNsb25lKCkubm9ybWFsaXplKCk7XG4gICAgdmFyIHJlbGF0aXZlUGFydHMsIGJhc2VQYXJ0cywgY29tbW9uLCByZWxhdGl2ZVBhdGgsIGJhc2VQYXRoO1xuXG4gICAgaWYgKHJlbGF0aXZlLl9wYXJ0cy51cm4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVVJOcyBkbyBub3QgaGF2ZSBhbnkgZ2VuZXJhbGx5IGRlZmluZWQgaGllcmFyY2hpY2FsIGNvbXBvbmVudHMnKTtcbiAgICB9XG5cbiAgICBiYXNlID0gbmV3IFVSSShiYXNlKS5ub3JtYWxpemUoKTtcbiAgICByZWxhdGl2ZVBhcnRzID0gcmVsYXRpdmUuX3BhcnRzO1xuICAgIGJhc2VQYXJ0cyA9IGJhc2UuX3BhcnRzO1xuICAgIHJlbGF0aXZlUGF0aCA9IHJlbGF0aXZlLnBhdGgoKTtcbiAgICBiYXNlUGF0aCA9IGJhc2UucGF0aCgpO1xuXG4gICAgaWYgKHJlbGF0aXZlUGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVUkkgaXMgYWxyZWFkeSByZWxhdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChiYXNlUGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIGEgVVJJIHJlbGF0aXZlIHRvIGFub3RoZXIgcmVsYXRpdmUgVVJJJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlbGF0aXZlUGFydHMucHJvdG9jb2wgPT09IGJhc2VQYXJ0cy5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmVQYXJ0cy5wcm90b2NvbCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHJlbGF0aXZlUGFydHMudXNlcm5hbWUgIT09IGJhc2VQYXJ0cy51c2VybmFtZSB8fCByZWxhdGl2ZVBhcnRzLnBhc3N3b3JkICE9PSBiYXNlUGFydHMucGFzc3dvcmQpIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZS5idWlsZCgpO1xuICAgIH1cblxuICAgIGlmIChyZWxhdGl2ZVBhcnRzLnByb3RvY29sICE9PSBudWxsIHx8IHJlbGF0aXZlUGFydHMudXNlcm5hbWUgIT09IG51bGwgfHwgcmVsYXRpdmVQYXJ0cy5wYXNzd29yZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlbGF0aXZlLmJ1aWxkKCk7XG4gICAgfVxuXG4gICAgaWYgKHJlbGF0aXZlUGFydHMuaG9zdG5hbWUgPT09IGJhc2VQYXJ0cy5ob3N0bmFtZSAmJiByZWxhdGl2ZVBhcnRzLnBvcnQgPT09IGJhc2VQYXJ0cy5wb3J0KSB7XG4gICAgICByZWxhdGl2ZVBhcnRzLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlUGFydHMucG9ydCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZS5idWlsZCgpO1xuICAgIH1cblxuICAgIGlmIChyZWxhdGl2ZVBhdGggPT09IGJhc2VQYXRoKSB7XG4gICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSAnJztcbiAgICAgIHJldHVybiByZWxhdGl2ZS5idWlsZCgpO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBjb21tb24gc3ViIHBhdGhcbiAgICBjb21tb24gPSBVUkkuY29tbW9uUGF0aChyZWxhdGl2ZVBhdGgsIGJhc2VQYXRoKTtcblxuICAgIC8vIElmIHRoZSBwYXRocyBoYXZlIG5vdGhpbmcgaW4gY29tbW9uLCByZXR1cm4gYSByZWxhdGl2ZSBVUkwgd2l0aCB0aGUgYWJzb2x1dGUgcGF0aC5cbiAgICBpZiAoIWNvbW1vbikge1xuICAgICAgcmV0dXJuIHJlbGF0aXZlLmJ1aWxkKCk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudHMgPSBiYXNlUGFydHMucGF0aFxuICAgICAgLnN1YnN0cmluZyhjb21tb24ubGVuZ3RoKVxuICAgICAgLnJlcGxhY2UoL1teXFwvXSokLywgJycpXG4gICAgICAucmVwbGFjZSgvLio/XFwvL2csICcuLi8nKTtcblxuICAgIHJlbGF0aXZlUGFydHMucGF0aCA9IChwYXJlbnRzICsgcmVsYXRpdmVQYXJ0cy5wYXRoLnN1YnN0cmluZyhjb21tb24ubGVuZ3RoKSkgfHwgJy4vJztcblxuICAgIHJldHVybiByZWxhdGl2ZS5idWlsZCgpO1xuICB9O1xuXG4gIC8vIGNvbXBhcmluZyBVUklzXG4gIHAuZXF1YWxzID0gZnVuY3Rpb24odXJpKSB7XG4gICAgdmFyIG9uZSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgdHdvID0gbmV3IFVSSSh1cmkpO1xuICAgIHZhciBvbmVfbWFwID0ge307XG4gICAgdmFyIHR3b19tYXAgPSB7fTtcbiAgICB2YXIgY2hlY2tlZCA9IHt9O1xuICAgIHZhciBvbmVfcXVlcnksIHR3b19xdWVyeSwga2V5O1xuXG4gICAgb25lLm5vcm1hbGl6ZSgpO1xuICAgIHR3by5ub3JtYWxpemUoKTtcblxuICAgIC8vIGV4YWN0IG1hdGNoXG4gICAgaWYgKG9uZS50b1N0cmluZygpID09PSB0d28udG9TdHJpbmcoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZXh0cmFjdCBxdWVyeSBzdHJpbmdcbiAgICBvbmVfcXVlcnkgPSBvbmUucXVlcnkoKTtcbiAgICB0d29fcXVlcnkgPSB0d28ucXVlcnkoKTtcbiAgICBvbmUucXVlcnkoJycpO1xuICAgIHR3by5xdWVyeSgnJyk7XG5cbiAgICAvLyBkZWZpbml0ZWx5IG5vdCBlcXVhbCBpZiBub3QgZXZlbiBub24tcXVlcnkgcGFydHMgbWF0Y2hcbiAgICBpZiAob25lLnRvU3RyaW5nKCkgIT09IHR3by50b1N0cmluZygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcXVlcnkgcGFyYW1ldGVycyBoYXZlIHRoZSBzYW1lIGxlbmd0aCwgZXZlbiBpZiB0aGV5J3JlIHBlcm11dGVkXG4gICAgaWYgKG9uZV9xdWVyeS5sZW5ndGggIT09IHR3b19xdWVyeS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBvbmVfbWFwID0gVVJJLnBhcnNlUXVlcnkob25lX3F1ZXJ5LCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTtcbiAgICB0d29fbWFwID0gVVJJLnBhcnNlUXVlcnkodHdvX3F1ZXJ5LCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTtcblxuICAgIGZvciAoa2V5IGluIG9uZV9tYXApIHtcbiAgICAgIGlmIChoYXNPd24uY2FsbChvbmVfbWFwLCBrZXkpKSB7XG4gICAgICAgIGlmICghaXNBcnJheShvbmVfbWFwW2tleV0pKSB7XG4gICAgICAgICAgaWYgKG9uZV9tYXBba2V5XSAhPT0gdHdvX21hcFtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFhcnJheXNFcXVhbChvbmVfbWFwW2tleV0sIHR3b19tYXBba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjaGVja2VkW2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoa2V5IGluIHR3b19tYXApIHtcbiAgICAgIGlmIChoYXNPd24uY2FsbCh0d29fbWFwLCBrZXkpKSB7XG4gICAgICAgIGlmICghY2hlY2tlZFtrZXldKSB7XG4gICAgICAgICAgLy8gdHdvIGNvbnRhaW5zIGEgcGFyYW1ldGVyIG5vdCBwcmVzZW50IGluIG9uZVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIHN0YXRlXG4gIHAucHJldmVudEludmFsaWRIb3N0bmFtZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICB0aGlzLl9wYXJ0cy5wcmV2ZW50SW52YWxpZEhvc3RuYW1lID0gISF2O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHAuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzID0gZnVuY3Rpb24odikge1xuICAgIHRoaXMuX3BhcnRzLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycyA9ICEhdjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwLmVzY2FwZVF1ZXJ5U3BhY2UgPSBmdW5jdGlvbih2KSB7XG4gICAgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSA9ICEhdjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gVVJJO1xufSkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/urijs/src/URI.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/urijs/src/URITemplate.js":
/*!***********************************************!*\
  !*** ./node_modules/urijs/src/URITemplate.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * URI.js - Mutating URLs\n * URI Template Support - http://tools.ietf.org/html/rfc6570\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if ( true && module.exports) {\n    // Node\n    module.exports = factory(__webpack_require__(/*! ./URI */ \"(ssr)/./node_modules/urijs/src/URI.js\"));\n  } else if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./URI */ \"(ssr)/./node_modules/urijs/src/URI.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function (URI, root) {\n  'use strict';\n  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n  /*jshint camelcase: false */\n\n  // save current URITemplate variable, if any\n  var _URITemplate = root && root.URITemplate;\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  function URITemplate(expression) {\n    // serve from cache where possible\n    if (URITemplate._cache[expression]) {\n      return URITemplate._cache[expression];\n    }\n\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof URITemplate)) {\n      return new URITemplate(expression);\n    }\n\n    this.expression = expression;\n    URITemplate._cache[expression] = this;\n    return this;\n  }\n\n  function Data(data) {\n    this.data = data;\n    this.cache = {};\n  }\n\n  var p = URITemplate.prototype;\n  // list of operators and their defined options\n  var operators = {\n    // Simple string expansion\n    '' : {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Reserved character strings\n    '+' : {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encodeReserved'\n    },\n    // Fragment identifiers prefixed by '#'\n    '#' : {\n      prefix: '#',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encodeReserved'\n    },\n    // Name labels or extensions prefixed by '.'\n    '.' : {\n      prefix: '.',\n      separator: '.',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Path segments prefixed by '/'\n    '/' : {\n      prefix: '/',\n      separator: '/',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Path parameter name or name=value pairs prefixed by ';'\n    ';' : {\n      prefix: ';',\n      separator: ';',\n      named: true,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Query component beginning with '?' and consisting\n    // of name=value pairs separated by '&'; an\n    '?' : {\n      prefix: '?',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode : 'encode'\n    },\n    // Continuation of query-style &name=value pairs\n    // within a literal query component.\n    '&' : {\n      prefix: '&',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode : 'encode'\n    }\n\n    // The operator characters equals (\"=\"), comma (\",\"), exclamation (\"!\"),\n    // at sign (\"@\"), and pipe (\"|\") are reserved for future extensions.\n  };\n\n  // storage for already parsed templates\n  URITemplate._cache = {};\n  // pattern to identify expressions [operator, variable-list] in template\n  URITemplate.EXPRESSION_PATTERN = /\\{([^a-zA-Z0-9%_]?)([^\\}]+)(\\}|$)/g;\n  // pattern to identify variables [name, explode, maxlength] in variable-list\n  URITemplate.VARIABLE_PATTERN = /^([^*:.](?:\\.?[^*:.])*)((\\*)|:(\\d+))?$/;\n  // pattern to verify variable name integrity\n  URITemplate.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/;\n  // pattern to verify literal integrity\n  URITemplate.LITERAL_PATTERN = /[<>{}\"`^| \\\\]/;\n\n  // expand parsed expression (expression, not template!)\n  URITemplate.expand = function(expression, data, opts) {\n    // container for defined options for the given operator\n    var options = operators[expression.operator];\n    // expansion type (include keys or not)\n    var type = options.named ? 'Named' : 'Unnamed';\n    // list of variables within the expression\n    var variables = expression.variables;\n    // result buffer for evaluating the expression\n    var buffer = [];\n    var d, variable, i;\n\n    for (i = 0; (variable = variables[i]); i++) {\n      // fetch simplified data source\n      d = data.get(variable.name);\n      if (d.type === 0 && opts && opts.strict) {\n          throw new Error('Missing expansion value for variable \"' + variable.name + '\"');\n      }\n      if (!d.val.length) {\n        if (d.type) {\n          // empty variables (empty string)\n          // still lead to a separator being appended!\n          buffer.push('');\n        }\n        // no data, no action\n        continue;\n      }\n\n      if (d.type > 1 && variable.maxlength) {\n        // composite variable cannot specify maxlength\n        throw new Error('Invalid expression: Prefix modifier not applicable to variable \"' + variable.name + '\"');\n      }\n\n      // expand the given variable\n      buffer.push(URITemplate['expand' + type](\n        d,\n        options,\n        variable.explode,\n        variable.explode && options.separator || ',',\n        variable.maxlength,\n        variable.name\n      ));\n    }\n\n    if (buffer.length) {\n      return options.prefix + buffer.join(options.separator);\n    } else {\n      // prefix is not prepended for empty expressions\n      return '';\n    }\n  };\n  // expand a named variable\n  URITemplate.expandNamed = function(d, options, explode, separator, length, name) {\n    // variable result buffer\n    var result = '';\n    // peformance crap\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator;\n    // flag noting if values are already encoded\n    var _encode = !d[encode].length;\n    // key for named expansion\n    var _name = d.type === 2 ? '': URI[encode](name);\n    var _value, i, l;\n\n    // for each found value\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n        if (d.type === 2) {\n          // apply maxlength to keys of objects as well\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        }\n      } else if (_encode) {\n        // encode value\n        _value = URI[encode](d.val[i][1]);\n        if (d.type === 2) {\n          // encode name and cache encoded value\n          _name = URI[encode](d.val[i][0]);\n          d[encode].push([_name, _value]);\n        } else {\n          // cache encoded value\n          d[encode].push([undefined, _value]);\n        }\n      } else {\n        // values are already encoded and can be pulled from cache\n        _value = d[encode][i][1];\n        if (d.type === 2) {\n          _name = d[encode][i][0];\n        }\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (!explode) {\n        if (!i) {\n          // first element, so prepend variable name\n          result += URI[encode](name) + (empty_name_separator || _value ? '=' : '');\n        }\n\n        if (d.type === 2) {\n          // without explode-modifier, keys of objects are returned comma-separated\n          result += _name + ',';\n        }\n\n        result += _value;\n      } else {\n        // only add the = if it is either default (?&) or there actually is a value (;)\n        result += _name + (empty_name_separator || _value ? '=' : '') + _value;\n      }\n    }\n\n    return result;\n  };\n  // expand an unnamed variable\n  URITemplate.expandUnnamed = function(d, options, explode, separator, length) {\n    // variable result buffer\n    var result = '';\n    // performance crap\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator;\n    // flag noting if values are already encoded\n    var _encode = !d[encode].length;\n    var _name, _value, i, l;\n\n    // for each found value\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n      } else if (_encode) {\n        // encode and cache value\n        _value = URI[encode](d.val[i][1]);\n        d[encode].push([\n          d.type === 2 ? URI[encode](d.val[i][0]) : undefined,\n          _value\n        ]);\n      } else {\n        // value already encoded, pull from cache\n        _value = d[encode][i][1];\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (d.type === 2) {\n        if (length) {\n          // maxlength also applies to keys of objects\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        } else {\n          // at this point the name must already be encoded\n          _name = d[encode][i][0];\n        }\n\n        result += _name;\n        if (explode) {\n          // explode-modifier separates name and value by \"=\"\n          result += (empty_name_separator || _value ? '=' : '');\n        } else {\n          // no explode-modifier separates name and value by \",\"\n          result += ',';\n        }\n      }\n\n      result += _value;\n    }\n\n    return result;\n  };\n\n  URITemplate.noConflict = function() {\n    if (root.URITemplate === URITemplate) {\n      root.URITemplate = _URITemplate;\n    }\n\n    return URITemplate;\n  };\n\n  // expand template through given data map\n  p.expand = function(data, opts) {\n    var result = '';\n\n    if (!this.parts || !this.parts.length) {\n      // lazilyy parse the template\n      this.parse();\n    }\n\n    if (!(data instanceof Data)) {\n      // make given data available through the\n      // optimized data handling thingie\n      data = new Data(data);\n    }\n\n    for (var i = 0, l = this.parts.length; i < l; i++) {\n      /*jshint laxbreak: true */\n      result += typeof this.parts[i] === 'string'\n        // literal string\n        ? this.parts[i]\n        // expression\n        : URITemplate.expand(this.parts[i], data, opts);\n      /*jshint laxbreak: false */\n    }\n\n    return result;\n  };\n  // parse template into action tokens\n  p.parse = function() {\n    // performance crap\n    var expression = this.expression;\n    var ePattern = URITemplate.EXPRESSION_PATTERN;\n    var vPattern = URITemplate.VARIABLE_PATTERN;\n    var nPattern = URITemplate.VARIABLE_NAME_PATTERN;\n    var lPattern = URITemplate.LITERAL_PATTERN;\n    // token result buffer\n    var parts = [];\n      // position within source template\n    var pos = 0;\n    var variables, eMatch, vMatch;\n\n    var checkLiteral = function(literal) {\n      if (literal.match(lPattern)) {\n        throw new Error('Invalid Literal \"' + literal + '\"');\n      }\n      return literal;\n    };\n\n    // RegExp is shared accross all templates,\n    // which requires a manual reset\n    ePattern.lastIndex = 0;\n    // I don't like while(foo = bar()) loops,\n    // to make things simpler I go while(true) and break when required\n    while (true) {\n      eMatch = ePattern.exec(expression);\n      if (eMatch === null) {\n        // push trailing literal\n        parts.push(checkLiteral(expression.substring(pos)));\n        break;\n      } else {\n        // push leading literal\n        parts.push(checkLiteral(expression.substring(pos, eMatch.index)));\n        pos = eMatch.index + eMatch[0].length;\n      }\n\n      if (!operators[eMatch[1]]) {\n        throw new Error('Unknown Operator \"' + eMatch[1]  + '\" in \"' + eMatch[0] + '\"');\n      } else if (!eMatch[3]) {\n        throw new Error('Unclosed Expression \"' + eMatch[0]  + '\"');\n      }\n\n      // parse variable-list\n      variables = eMatch[2].split(',');\n      for (var i = 0, l = variables.length; i < l; i++) {\n        vMatch = variables[i].match(vPattern);\n        if (vMatch === null) {\n          throw new Error('Invalid Variable \"' + variables[i] + '\" in \"' + eMatch[0] + '\"');\n        } else if (vMatch[1].match(nPattern)) {\n          throw new Error('Invalid Variable Name \"' + vMatch[1] + '\" in \"' + eMatch[0] + '\"');\n        }\n\n        variables[i] = {\n          name: vMatch[1],\n          explode: !!vMatch[3],\n          maxlength: vMatch[4] && parseInt(vMatch[4], 10)\n        };\n      }\n\n      if (!variables.length) {\n        throw new Error('Expression Missing Variable(s) \"' + eMatch[0] + '\"');\n      }\n\n      parts.push({\n        expression: eMatch[0],\n        operator: eMatch[1],\n        variables: variables\n      });\n    }\n\n    if (!parts.length) {\n      // template doesn't contain any expressions\n      // so it is a simple literal string\n      // this probably should fire a warning or something?\n      parts.push(checkLiteral(expression));\n    }\n\n    this.parts = parts;\n    return this;\n  };\n\n  // simplify data structures\n  Data.prototype.get = function(key) {\n    // performance crap\n    var data = this.data;\n    // cache for processed data-point\n    var d = {\n      // type of data 0: undefined/null, 1: string, 2: object, 3: array\n      type: 0,\n      // original values (except undefined/null)\n      val: [],\n      // cache for encoded values (only for non-maxlength expansion)\n      encode: [],\n      encodeReserved: []\n    };\n    var i, l, value;\n\n    if (this.cache[key] !== undefined) {\n      // we've already processed this key\n      return this.cache[key];\n    }\n\n    this.cache[key] = d;\n\n    if (String(Object.prototype.toString.call(data)) === '[object Function]') {\n      // data itself is a callback (global callback)\n      value = data(key);\n    } else if (String(Object.prototype.toString.call(data[key])) === '[object Function]') {\n      // data is a map of callbacks (local callback)\n      value = data[key](key);\n    } else {\n      // data is a map of data\n      value = data[key];\n    }\n\n    // generalize input into [ [name1, value1], [name2, value2], … ]\n    // so expansion has to deal with a single data structure only\n    if (value === undefined || value === null) {\n      // undefined and null values are to be ignored completely\n      return d;\n    } else if (String(Object.prototype.toString.call(value)) === '[object Array]') {\n      for (i = 0, l = value.length; i < l; i++) {\n        if (value[i] !== undefined && value[i] !== null) {\n          // arrays don't have names\n          d.val.push([undefined, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty arrays as arrays\n        d.type = 3; // array\n      }\n    } else if (String(Object.prototype.toString.call(value)) === '[object Object]') {\n      for (i in value) {\n        if (hasOwn.call(value, i) && value[i] !== undefined && value[i] !== null) {\n          // objects have keys, remember them for named expansion\n          d.val.push([i, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty objects as objects\n        d.type = 2; // object\n      }\n    } else {\n      d.type = 1; // primitive string (could've been string, number, boolean and objects with a toString())\n      // arrays don't have names\n      d.val.push([undefined, String(value)]);\n    }\n\n    return d;\n  };\n\n  // hook into URI for fluid access\n  URI.expand = function(expression, data) {\n    var template = new URITemplate(expression);\n    var expansion = template.expand(data);\n\n    return new URI(expansion);\n  };\n\n  return URITemplate;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXJpanMvc3JjL1VSSVRlbXBsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUEwQjtBQUNoQztBQUNBLDZCQUE2QixtQkFBTyxDQUFDLG9EQUFPO0FBQzVDLElBQUksU0FBUyxJQUEwQztBQUN2RDtBQUNBLElBQUksaUNBQU8sQ0FBQyx5RUFBTyxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDOUIsSUFBSSxLQUFLLEVBR047QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZEQUE2RDtBQUM3RCxNQUFNO0FBQ04sZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQixNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxNQUFNO0FBQ04sa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVTVUFSSU9cXERvY3VtZW50c1xcR2l0aHViXFxHYWxheHlLSi13YWxsZXQtLS1IYWNrXFx3ZWJcXG5vZGVfbW9kdWxlc1xcdXJpanNcXHNyY1xcVVJJVGVtcGxhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBVUkkuanMgLSBNdXRhdGluZyBVUkxzXG4gKiBVUkkgVGVtcGxhdGUgU3VwcG9ydCAtIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAqXG4gKiBWZXJzaW9uOiAxLjE5LjExXG4gKlxuICogQXV0aG9yOiBSb2RuZXkgUmVobVxuICogV2ViOiBodHRwOi8vbWVkaWFsaXplLmdpdGh1Yi5pby9VUkkuanMvXG4gKlxuICogTGljZW5zZWQgdW5kZXJcbiAqICAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuICpcbiAqL1xuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIE5vZGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnLi9VUkknKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJy4vVVJJJ10sIGZhY3RvcnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgcm9vdC5VUklUZW1wbGF0ZSA9IGZhY3Rvcnkocm9vdC5VUkksIHJvb3QpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uIChVUkksIHJvb3QpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBGSVhNRTogdjIuMC4wIHJlbmFtY2Ugbm9uLWNhbWVsQ2FzZSBwcm9wZXJ0aWVzIHRvIHVwcGVyY2FzZVxuICAvKmpzaGludCBjYW1lbGNhc2U6IGZhbHNlICovXG5cbiAgLy8gc2F2ZSBjdXJyZW50IFVSSVRlbXBsYXRlIHZhcmlhYmxlLCBpZiBhbnlcbiAgdmFyIF9VUklUZW1wbGF0ZSA9IHJvb3QgJiYgcm9vdC5VUklUZW1wbGF0ZTtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgZnVuY3Rpb24gVVJJVGVtcGxhdGUoZXhwcmVzc2lvbikge1xuICAgIC8vIHNlcnZlIGZyb20gY2FjaGUgd2hlcmUgcG9zc2libGVcbiAgICBpZiAoVVJJVGVtcGxhdGUuX2NhY2hlW2V4cHJlc3Npb25dKSB7XG4gICAgICByZXR1cm4gVVJJVGVtcGxhdGUuX2NhY2hlW2V4cHJlc3Npb25dO1xuICAgIH1cblxuICAgIC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVUklUZW1wbGF0ZSkpIHtcbiAgICAgIHJldHVybiBuZXcgVVJJVGVtcGxhdGUoZXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICBVUklUZW1wbGF0ZS5fY2FjaGVbZXhwcmVzc2lvbl0gPSB0aGlzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gRGF0YShkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmNhY2hlID0ge307XG4gIH1cblxuICB2YXIgcCA9IFVSSVRlbXBsYXRlLnByb3RvdHlwZTtcbiAgLy8gbGlzdCBvZiBvcGVyYXRvcnMgYW5kIHRoZWlyIGRlZmluZWQgb3B0aW9uc1xuICB2YXIgb3BlcmF0b3JzID0ge1xuICAgIC8vIFNpbXBsZSBzdHJpbmcgZXhwYW5zaW9uXG4gICAgJycgOiB7XG4gICAgICBwcmVmaXg6ICcnLFxuICAgICAgc2VwYXJhdG9yOiAnLCcsXG4gICAgICBuYW1lZDogZmFsc2UsXG4gICAgICBlbXB0eV9uYW1lX3NlcGFyYXRvcjogZmFsc2UsXG4gICAgICBlbmNvZGUgOiAnZW5jb2RlJ1xuICAgIH0sXG4gICAgLy8gUmVzZXJ2ZWQgY2hhcmFjdGVyIHN0cmluZ3NcbiAgICAnKycgOiB7XG4gICAgICBwcmVmaXg6ICcnLFxuICAgICAgc2VwYXJhdG9yOiAnLCcsXG4gICAgICBuYW1lZDogZmFsc2UsXG4gICAgICBlbXB0eV9uYW1lX3NlcGFyYXRvcjogZmFsc2UsXG4gICAgICBlbmNvZGUgOiAnZW5jb2RlUmVzZXJ2ZWQnXG4gICAgfSxcbiAgICAvLyBGcmFnbWVudCBpZGVudGlmaWVycyBwcmVmaXhlZCBieSAnIydcbiAgICAnIycgOiB7XG4gICAgICBwcmVmaXg6ICcjJyxcbiAgICAgIHNlcGFyYXRvcjogJywnLFxuICAgICAgbmFtZWQ6IGZhbHNlLFxuICAgICAgZW1wdHlfbmFtZV9zZXBhcmF0b3I6IGZhbHNlLFxuICAgICAgZW5jb2RlIDogJ2VuY29kZVJlc2VydmVkJ1xuICAgIH0sXG4gICAgLy8gTmFtZSBsYWJlbHMgb3IgZXh0ZW5zaW9ucyBwcmVmaXhlZCBieSAnLidcbiAgICAnLicgOiB7XG4gICAgICBwcmVmaXg6ICcuJyxcbiAgICAgIHNlcGFyYXRvcjogJy4nLFxuICAgICAgbmFtZWQ6IGZhbHNlLFxuICAgICAgZW1wdHlfbmFtZV9zZXBhcmF0b3I6IGZhbHNlLFxuICAgICAgZW5jb2RlIDogJ2VuY29kZSdcbiAgICB9LFxuICAgIC8vIFBhdGggc2VnbWVudHMgcHJlZml4ZWQgYnkgJy8nXG4gICAgJy8nIDoge1xuICAgICAgcHJlZml4OiAnLycsXG4gICAgICBzZXBhcmF0b3I6ICcvJyxcbiAgICAgIG5hbWVkOiBmYWxzZSxcbiAgICAgIGVtcHR5X25hbWVfc2VwYXJhdG9yOiBmYWxzZSxcbiAgICAgIGVuY29kZSA6ICdlbmNvZGUnXG4gICAgfSxcbiAgICAvLyBQYXRoIHBhcmFtZXRlciBuYW1lIG9yIG5hbWU9dmFsdWUgcGFpcnMgcHJlZml4ZWQgYnkgJzsnXG4gICAgJzsnIDoge1xuICAgICAgcHJlZml4OiAnOycsXG4gICAgICBzZXBhcmF0b3I6ICc7JyxcbiAgICAgIG5hbWVkOiB0cnVlLFxuICAgICAgZW1wdHlfbmFtZV9zZXBhcmF0b3I6IGZhbHNlLFxuICAgICAgZW5jb2RlIDogJ2VuY29kZSdcbiAgICB9LFxuICAgIC8vIFF1ZXJ5IGNvbXBvbmVudCBiZWdpbm5pbmcgd2l0aCAnPycgYW5kIGNvbnNpc3RpbmdcbiAgICAvLyBvZiBuYW1lPXZhbHVlIHBhaXJzIHNlcGFyYXRlZCBieSAnJic7IGFuXG4gICAgJz8nIDoge1xuICAgICAgcHJlZml4OiAnPycsXG4gICAgICBzZXBhcmF0b3I6ICcmJyxcbiAgICAgIG5hbWVkOiB0cnVlLFxuICAgICAgZW1wdHlfbmFtZV9zZXBhcmF0b3I6IHRydWUsXG4gICAgICBlbmNvZGUgOiAnZW5jb2RlJ1xuICAgIH0sXG4gICAgLy8gQ29udGludWF0aW9uIG9mIHF1ZXJ5LXN0eWxlICZuYW1lPXZhbHVlIHBhaXJzXG4gICAgLy8gd2l0aGluIGEgbGl0ZXJhbCBxdWVyeSBjb21wb25lbnQuXG4gICAgJyYnIDoge1xuICAgICAgcHJlZml4OiAnJicsXG4gICAgICBzZXBhcmF0b3I6ICcmJyxcbiAgICAgIG5hbWVkOiB0cnVlLFxuICAgICAgZW1wdHlfbmFtZV9zZXBhcmF0b3I6IHRydWUsXG4gICAgICBlbmNvZGUgOiAnZW5jb2RlJ1xuICAgIH1cblxuICAgIC8vIFRoZSBvcGVyYXRvciBjaGFyYWN0ZXJzIGVxdWFscyAoXCI9XCIpLCBjb21tYSAoXCIsXCIpLCBleGNsYW1hdGlvbiAoXCIhXCIpLFxuICAgIC8vIGF0IHNpZ24gKFwiQFwiKSwgYW5kIHBpcGUgKFwifFwiKSBhcmUgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSBleHRlbnNpb25zLlxuICB9O1xuXG4gIC8vIHN0b3JhZ2UgZm9yIGFscmVhZHkgcGFyc2VkIHRlbXBsYXRlc1xuICBVUklUZW1wbGF0ZS5fY2FjaGUgPSB7fTtcbiAgLy8gcGF0dGVybiB0byBpZGVudGlmeSBleHByZXNzaW9ucyBbb3BlcmF0b3IsIHZhcmlhYmxlLWxpc3RdIGluIHRlbXBsYXRlXG4gIFVSSVRlbXBsYXRlLkVYUFJFU1NJT05fUEFUVEVSTiA9IC9cXHsoW15hLXpBLVowLTklX10/KShbXlxcfV0rKShcXH18JCkvZztcbiAgLy8gcGF0dGVybiB0byBpZGVudGlmeSB2YXJpYWJsZXMgW25hbWUsIGV4cGxvZGUsIG1heGxlbmd0aF0gaW4gdmFyaWFibGUtbGlzdFxuICBVUklUZW1wbGF0ZS5WQVJJQUJMRV9QQVRURVJOID0gL14oW14qOi5dKD86XFwuP1teKjouXSkqKSgoXFwqKXw6KFxcZCspKT8kLztcbiAgLy8gcGF0dGVybiB0byB2ZXJpZnkgdmFyaWFibGUgbmFtZSBpbnRlZ3JpdHlcbiAgVVJJVGVtcGxhdGUuVkFSSUFCTEVfTkFNRV9QQVRURVJOID0gL1teYS16QS1aMC05JV8uXS87XG4gIC8vIHBhdHRlcm4gdG8gdmVyaWZ5IGxpdGVyYWwgaW50ZWdyaXR5XG4gIFVSSVRlbXBsYXRlLkxJVEVSQUxfUEFUVEVSTiA9IC9bPD57fVwiYF58IFxcXFxdLztcblxuICAvLyBleHBhbmQgcGFyc2VkIGV4cHJlc3Npb24gKGV4cHJlc3Npb24sIG5vdCB0ZW1wbGF0ZSEpXG4gIFVSSVRlbXBsYXRlLmV4cGFuZCA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIGRhdGEsIG9wdHMpIHtcbiAgICAvLyBjb250YWluZXIgZm9yIGRlZmluZWQgb3B0aW9ucyBmb3IgdGhlIGdpdmVuIG9wZXJhdG9yXG4gICAgdmFyIG9wdGlvbnMgPSBvcGVyYXRvcnNbZXhwcmVzc2lvbi5vcGVyYXRvcl07XG4gICAgLy8gZXhwYW5zaW9uIHR5cGUgKGluY2x1ZGUga2V5cyBvciBub3QpXG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLm5hbWVkID8gJ05hbWVkJyA6ICdVbm5hbWVkJztcbiAgICAvLyBsaXN0IG9mIHZhcmlhYmxlcyB3aXRoaW4gdGhlIGV4cHJlc3Npb25cbiAgICB2YXIgdmFyaWFibGVzID0gZXhwcmVzc2lvbi52YXJpYWJsZXM7XG4gICAgLy8gcmVzdWx0IGJ1ZmZlciBmb3IgZXZhbHVhdGluZyB0aGUgZXhwcmVzc2lvblxuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgZCwgdmFyaWFibGUsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyAodmFyaWFibGUgPSB2YXJpYWJsZXNbaV0pOyBpKyspIHtcbiAgICAgIC8vIGZldGNoIHNpbXBsaWZpZWQgZGF0YSBzb3VyY2VcbiAgICAgIGQgPSBkYXRhLmdldCh2YXJpYWJsZS5uYW1lKTtcbiAgICAgIGlmIChkLnR5cGUgPT09IDAgJiYgb3B0cyAmJiBvcHRzLnN0cmljdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBleHBhbnNpb24gdmFsdWUgZm9yIHZhcmlhYmxlIFwiJyArIHZhcmlhYmxlLm5hbWUgKyAnXCInKTtcbiAgICAgIH1cbiAgICAgIGlmICghZC52YWwubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkLnR5cGUpIHtcbiAgICAgICAgICAvLyBlbXB0eSB2YXJpYWJsZXMgKGVtcHR5IHN0cmluZylcbiAgICAgICAgICAvLyBzdGlsbCBsZWFkIHRvIGEgc2VwYXJhdG9yIGJlaW5nIGFwcGVuZGVkIVxuICAgICAgICAgIGJ1ZmZlci5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBubyBkYXRhLCBubyBhY3Rpb25cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkLnR5cGUgPiAxICYmIHZhcmlhYmxlLm1heGxlbmd0aCkge1xuICAgICAgICAvLyBjb21wb3NpdGUgdmFyaWFibGUgY2Fubm90IHNwZWNpZnkgbWF4bGVuZ3RoXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBleHByZXNzaW9uOiBQcmVmaXggbW9kaWZpZXIgbm90IGFwcGxpY2FibGUgdG8gdmFyaWFibGUgXCInICsgdmFyaWFibGUubmFtZSArICdcIicpO1xuICAgICAgfVxuXG4gICAgICAvLyBleHBhbmQgdGhlIGdpdmVuIHZhcmlhYmxlXG4gICAgICBidWZmZXIucHVzaChVUklUZW1wbGF0ZVsnZXhwYW5kJyArIHR5cGVdKFxuICAgICAgICBkLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICB2YXJpYWJsZS5leHBsb2RlLFxuICAgICAgICB2YXJpYWJsZS5leHBsb2RlICYmIG9wdGlvbnMuc2VwYXJhdG9yIHx8ICcsJyxcbiAgICAgICAgdmFyaWFibGUubWF4bGVuZ3RoLFxuICAgICAgICB2YXJpYWJsZS5uYW1lXG4gICAgICApKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMucHJlZml4ICsgYnVmZmVyLmpvaW4ob3B0aW9ucy5zZXBhcmF0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwcmVmaXggaXMgbm90IHByZXBlbmRlZCBmb3IgZW1wdHkgZXhwcmVzc2lvbnNcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH07XG4gIC8vIGV4cGFuZCBhIG5hbWVkIHZhcmlhYmxlXG4gIFVSSVRlbXBsYXRlLmV4cGFuZE5hbWVkID0gZnVuY3Rpb24oZCwgb3B0aW9ucywgZXhwbG9kZSwgc2VwYXJhdG9yLCBsZW5ndGgsIG5hbWUpIHtcbiAgICAvLyB2YXJpYWJsZSByZXN1bHQgYnVmZmVyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIC8vIHBlZm9ybWFuY2UgY3JhcFxuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLmVuY29kZTtcbiAgICB2YXIgZW1wdHlfbmFtZV9zZXBhcmF0b3IgPSBvcHRpb25zLmVtcHR5X25hbWVfc2VwYXJhdG9yO1xuICAgIC8vIGZsYWcgbm90aW5nIGlmIHZhbHVlcyBhcmUgYWxyZWFkeSBlbmNvZGVkXG4gICAgdmFyIF9lbmNvZGUgPSAhZFtlbmNvZGVdLmxlbmd0aDtcbiAgICAvLyBrZXkgZm9yIG5hbWVkIGV4cGFuc2lvblxuICAgIHZhciBfbmFtZSA9IGQudHlwZSA9PT0gMiA/ICcnOiBVUklbZW5jb2RlXShuYW1lKTtcbiAgICB2YXIgX3ZhbHVlLCBpLCBsO1xuXG4gICAgLy8gZm9yIGVhY2ggZm91bmQgdmFsdWVcbiAgICBmb3IgKGkgPSAwLCBsID0gZC52YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIC8vIG1heGxlbmd0aCBtdXN0IGJlIGRldGVybWluZWQgYmVmb3JlIGVuY29kaW5nIGNhbiBoYXBwZW5cbiAgICAgICAgX3ZhbHVlID0gVVJJW2VuY29kZV0oZC52YWxbaV1bMV0uc3Vic3RyaW5nKDAsIGxlbmd0aCkpO1xuICAgICAgICBpZiAoZC50eXBlID09PSAyKSB7XG4gICAgICAgICAgLy8gYXBwbHkgbWF4bGVuZ3RoIHRvIGtleXMgb2Ygb2JqZWN0cyBhcyB3ZWxsXG4gICAgICAgICAgX25hbWUgPSBVUklbZW5jb2RlXShkLnZhbFtpXVswXS5zdWJzdHJpbmcoMCwgbGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX2VuY29kZSkge1xuICAgICAgICAvLyBlbmNvZGUgdmFsdWVcbiAgICAgICAgX3ZhbHVlID0gVVJJW2VuY29kZV0oZC52YWxbaV1bMV0pO1xuICAgICAgICBpZiAoZC50eXBlID09PSAyKSB7XG4gICAgICAgICAgLy8gZW5jb2RlIG5hbWUgYW5kIGNhY2hlIGVuY29kZWQgdmFsdWVcbiAgICAgICAgICBfbmFtZSA9IFVSSVtlbmNvZGVdKGQudmFsW2ldWzBdKTtcbiAgICAgICAgICBkW2VuY29kZV0ucHVzaChbX25hbWUsIF92YWx1ZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhY2hlIGVuY29kZWQgdmFsdWVcbiAgICAgICAgICBkW2VuY29kZV0ucHVzaChbdW5kZWZpbmVkLCBfdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdmFsdWVzIGFyZSBhbHJlYWR5IGVuY29kZWQgYW5kIGNhbiBiZSBwdWxsZWQgZnJvbSBjYWNoZVxuICAgICAgICBfdmFsdWUgPSBkW2VuY29kZV1baV1bMV07XG4gICAgICAgIGlmIChkLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICBfbmFtZSA9IGRbZW5jb2RlXVtpXVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSB0aGUgZmlyc3QgdmFsdWUsIHByZXBlbmQgdGhlIHNlcGFyYXRvclxuICAgICAgICByZXN1bHQgKz0gc2VwYXJhdG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWV4cGxvZGUpIHtcbiAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgLy8gZmlyc3QgZWxlbWVudCwgc28gcHJlcGVuZCB2YXJpYWJsZSBuYW1lXG4gICAgICAgICAgcmVzdWx0ICs9IFVSSVtlbmNvZGVdKG5hbWUpICsgKGVtcHR5X25hbWVfc2VwYXJhdG9yIHx8IF92YWx1ZSA/ICc9JyA6ICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAvLyB3aXRob3V0IGV4cGxvZGUtbW9kaWZpZXIsIGtleXMgb2Ygb2JqZWN0cyBhcmUgcmV0dXJuZWQgY29tbWEtc2VwYXJhdGVkXG4gICAgICAgICAgcmVzdWx0ICs9IF9uYW1lICsgJywnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IF92YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9ubHkgYWRkIHRoZSA9IGlmIGl0IGlzIGVpdGhlciBkZWZhdWx0ICg/Jikgb3IgdGhlcmUgYWN0dWFsbHkgaXMgYSB2YWx1ZSAoOylcbiAgICAgICAgcmVzdWx0ICs9IF9uYW1lICsgKGVtcHR5X25hbWVfc2VwYXJhdG9yIHx8IF92YWx1ZSA/ICc9JyA6ICcnKSArIF92YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICAvLyBleHBhbmQgYW4gdW5uYW1lZCB2YXJpYWJsZVxuICBVUklUZW1wbGF0ZS5leHBhbmRVbm5hbWVkID0gZnVuY3Rpb24oZCwgb3B0aW9ucywgZXhwbG9kZSwgc2VwYXJhdG9yLCBsZW5ndGgpIHtcbiAgICAvLyB2YXJpYWJsZSByZXN1bHQgYnVmZmVyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIC8vIHBlcmZvcm1hbmNlIGNyYXBcbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5lbmNvZGU7XG4gICAgdmFyIGVtcHR5X25hbWVfc2VwYXJhdG9yID0gb3B0aW9ucy5lbXB0eV9uYW1lX3NlcGFyYXRvcjtcbiAgICAvLyBmbGFnIG5vdGluZyBpZiB2YWx1ZXMgYXJlIGFscmVhZHkgZW5jb2RlZFxuICAgIHZhciBfZW5jb2RlID0gIWRbZW5jb2RlXS5sZW5ndGg7XG4gICAgdmFyIF9uYW1lLCBfdmFsdWUsIGksIGw7XG5cbiAgICAvLyBmb3IgZWFjaCBmb3VuZCB2YWx1ZVxuICAgIGZvciAoaSA9IDAsIGwgPSBkLnZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgLy8gbWF4bGVuZ3RoIG11c3QgYmUgZGV0ZXJtaW5lZCBiZWZvcmUgZW5jb2RpbmcgY2FuIGhhcHBlblxuICAgICAgICBfdmFsdWUgPSBVUklbZW5jb2RlXShkLnZhbFtpXVsxXS5zdWJzdHJpbmcoMCwgbGVuZ3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKF9lbmNvZGUpIHtcbiAgICAgICAgLy8gZW5jb2RlIGFuZCBjYWNoZSB2YWx1ZVxuICAgICAgICBfdmFsdWUgPSBVUklbZW5jb2RlXShkLnZhbFtpXVsxXSk7XG4gICAgICAgIGRbZW5jb2RlXS5wdXNoKFtcbiAgICAgICAgICBkLnR5cGUgPT09IDIgPyBVUklbZW5jb2RlXShkLnZhbFtpXVswXSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgX3ZhbHVlXG4gICAgICAgIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdmFsdWUgYWxyZWFkeSBlbmNvZGVkLCBwdWxsIGZyb20gY2FjaGVcbiAgICAgICAgX3ZhbHVlID0gZFtlbmNvZGVdW2ldWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSB0aGUgZmlyc3QgdmFsdWUsIHByZXBlbmQgdGhlIHNlcGFyYXRvclxuICAgICAgICByZXN1bHQgKz0gc2VwYXJhdG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoZC50eXBlID09PSAyKSB7XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAvLyBtYXhsZW5ndGggYWxzbyBhcHBsaWVzIHRvIGtleXMgb2Ygb2JqZWN0c1xuICAgICAgICAgIF9uYW1lID0gVVJJW2VuY29kZV0oZC52YWxbaV1bMF0uc3Vic3RyaW5nKDAsIGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIG5hbWUgbXVzdCBhbHJlYWR5IGJlIGVuY29kZWRcbiAgICAgICAgICBfbmFtZSA9IGRbZW5jb2RlXVtpXVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBfbmFtZTtcbiAgICAgICAgaWYgKGV4cGxvZGUpIHtcbiAgICAgICAgICAvLyBleHBsb2RlLW1vZGlmaWVyIHNlcGFyYXRlcyBuYW1lIGFuZCB2YWx1ZSBieSBcIj1cIlxuICAgICAgICAgIHJlc3VsdCArPSAoZW1wdHlfbmFtZV9zZXBhcmF0b3IgfHwgX3ZhbHVlID8gJz0nIDogJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIGV4cGxvZGUtbW9kaWZpZXIgc2VwYXJhdGVzIG5hbWUgYW5kIHZhbHVlIGJ5IFwiLFwiXG4gICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gX3ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgVVJJVGVtcGxhdGUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChyb290LlVSSVRlbXBsYXRlID09PSBVUklUZW1wbGF0ZSkge1xuICAgICAgcm9vdC5VUklUZW1wbGF0ZSA9IF9VUklUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gVVJJVGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gZXhwYW5kIHRlbXBsYXRlIHRocm91Z2ggZ2l2ZW4gZGF0YSBtYXBcbiAgcC5leHBhbmQgPSBmdW5jdGlvbihkYXRhLCBvcHRzKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgaWYgKCF0aGlzLnBhcnRzIHx8ICF0aGlzLnBhcnRzLmxlbmd0aCkge1xuICAgICAgLy8gbGF6aWx5eSBwYXJzZSB0aGUgdGVtcGxhdGVcbiAgICAgIHRoaXMucGFyc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgRGF0YSkpIHtcbiAgICAgIC8vIG1ha2UgZ2l2ZW4gZGF0YSBhdmFpbGFibGUgdGhyb3VnaCB0aGVcbiAgICAgIC8vIG9wdGltaXplZCBkYXRhIGhhbmRsaW5nIHRoaW5naWVcbiAgICAgIGRhdGEgPSBuZXcgRGF0YShkYXRhKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMucGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAvKmpzaGludCBsYXhicmVhazogdHJ1ZSAqL1xuICAgICAgcmVzdWx0ICs9IHR5cGVvZiB0aGlzLnBhcnRzW2ldID09PSAnc3RyaW5nJ1xuICAgICAgICAvLyBsaXRlcmFsIHN0cmluZ1xuICAgICAgICA/IHRoaXMucGFydHNbaV1cbiAgICAgICAgLy8gZXhwcmVzc2lvblxuICAgICAgICA6IFVSSVRlbXBsYXRlLmV4cGFuZCh0aGlzLnBhcnRzW2ldLCBkYXRhLCBvcHRzKTtcbiAgICAgIC8qanNoaW50IGxheGJyZWFrOiBmYWxzZSAqL1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8vIHBhcnNlIHRlbXBsYXRlIGludG8gYWN0aW9uIHRva2Vuc1xuICBwLnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gcGVyZm9ybWFuY2UgY3JhcFxuICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uO1xuICAgIHZhciBlUGF0dGVybiA9IFVSSVRlbXBsYXRlLkVYUFJFU1NJT05fUEFUVEVSTjtcbiAgICB2YXIgdlBhdHRlcm4gPSBVUklUZW1wbGF0ZS5WQVJJQUJMRV9QQVRURVJOO1xuICAgIHZhciBuUGF0dGVybiA9IFVSSVRlbXBsYXRlLlZBUklBQkxFX05BTUVfUEFUVEVSTjtcbiAgICB2YXIgbFBhdHRlcm4gPSBVUklUZW1wbGF0ZS5MSVRFUkFMX1BBVFRFUk47XG4gICAgLy8gdG9rZW4gcmVzdWx0IGJ1ZmZlclxuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgLy8gcG9zaXRpb24gd2l0aGluIHNvdXJjZSB0ZW1wbGF0ZVxuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciB2YXJpYWJsZXMsIGVNYXRjaCwgdk1hdGNoO1xuXG4gICAgdmFyIGNoZWNrTGl0ZXJhbCA9IGZ1bmN0aW9uKGxpdGVyYWwpIHtcbiAgICAgIGlmIChsaXRlcmFsLm1hdGNoKGxQYXR0ZXJuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGl0ZXJhbCBcIicgKyBsaXRlcmFsICsgJ1wiJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGl0ZXJhbDtcbiAgICB9O1xuXG4gICAgLy8gUmVnRXhwIGlzIHNoYXJlZCBhY2Nyb3NzIGFsbCB0ZW1wbGF0ZXMsXG4gICAgLy8gd2hpY2ggcmVxdWlyZXMgYSBtYW51YWwgcmVzZXRcbiAgICBlUGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgIC8vIEkgZG9uJ3QgbGlrZSB3aGlsZShmb28gPSBiYXIoKSkgbG9vcHMsXG4gICAgLy8gdG8gbWFrZSB0aGluZ3Mgc2ltcGxlciBJIGdvIHdoaWxlKHRydWUpIGFuZCBicmVhayB3aGVuIHJlcXVpcmVkXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGVNYXRjaCA9IGVQYXR0ZXJuLmV4ZWMoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoZU1hdGNoID09PSBudWxsKSB7XG4gICAgICAgIC8vIHB1c2ggdHJhaWxpbmcgbGl0ZXJhbFxuICAgICAgICBwYXJ0cy5wdXNoKGNoZWNrTGl0ZXJhbChleHByZXNzaW9uLnN1YnN0cmluZyhwb3MpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHVzaCBsZWFkaW5nIGxpdGVyYWxcbiAgICAgICAgcGFydHMucHVzaChjaGVja0xpdGVyYWwoZXhwcmVzc2lvbi5zdWJzdHJpbmcocG9zLCBlTWF0Y2guaW5kZXgpKSk7XG4gICAgICAgIHBvcyA9IGVNYXRjaC5pbmRleCArIGVNYXRjaFswXS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3BlcmF0b3JzW2VNYXRjaFsxXV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIE9wZXJhdG9yIFwiJyArIGVNYXRjaFsxXSAgKyAnXCIgaW4gXCInICsgZU1hdGNoWzBdICsgJ1wiJyk7XG4gICAgICB9IGVsc2UgaWYgKCFlTWF0Y2hbM10pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBFeHByZXNzaW9uIFwiJyArIGVNYXRjaFswXSAgKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgdmFyaWFibGUtbGlzdFxuICAgICAgdmFyaWFibGVzID0gZU1hdGNoWzJdLnNwbGl0KCcsJyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhcmlhYmxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdk1hdGNoID0gdmFyaWFibGVzW2ldLm1hdGNoKHZQYXR0ZXJuKTtcbiAgICAgICAgaWYgKHZNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBWYXJpYWJsZSBcIicgKyB2YXJpYWJsZXNbaV0gKyAnXCIgaW4gXCInICsgZU1hdGNoWzBdICsgJ1wiJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodk1hdGNoWzFdLm1hdGNoKG5QYXR0ZXJuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBWYXJpYWJsZSBOYW1lIFwiJyArIHZNYXRjaFsxXSArICdcIiBpbiBcIicgKyBlTWF0Y2hbMF0gKyAnXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhcmlhYmxlc1tpXSA9IHtcbiAgICAgICAgICBuYW1lOiB2TWF0Y2hbMV0sXG4gICAgICAgICAgZXhwbG9kZTogISF2TWF0Y2hbM10sXG4gICAgICAgICAgbWF4bGVuZ3RoOiB2TWF0Y2hbNF0gJiYgcGFyc2VJbnQodk1hdGNoWzRdLCAxMClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF2YXJpYWJsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwcmVzc2lvbiBNaXNzaW5nIFZhcmlhYmxlKHMpIFwiJyArIGVNYXRjaFswXSArICdcIicpO1xuICAgICAgfVxuXG4gICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgZXhwcmVzc2lvbjogZU1hdGNoWzBdLFxuICAgICAgICBvcGVyYXRvcjogZU1hdGNoWzFdLFxuICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJ0cy5sZW5ndGgpIHtcbiAgICAgIC8vIHRlbXBsYXRlIGRvZXNuJ3QgY29udGFpbiBhbnkgZXhwcmVzc2lvbnNcbiAgICAgIC8vIHNvIGl0IGlzIGEgc2ltcGxlIGxpdGVyYWwgc3RyaW5nXG4gICAgICAvLyB0aGlzIHByb2JhYmx5IHNob3VsZCBmaXJlIGEgd2FybmluZyBvciBzb21ldGhpbmc/XG4gICAgICBwYXJ0cy5wdXNoKGNoZWNrTGl0ZXJhbChleHByZXNzaW9uKSk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIHNpbXBsaWZ5IGRhdGEgc3RydWN0dXJlc1xuICBEYXRhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAvLyBwZXJmb3JtYW5jZSBjcmFwXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgLy8gY2FjaGUgZm9yIHByb2Nlc3NlZCBkYXRhLXBvaW50XG4gICAgdmFyIGQgPSB7XG4gICAgICAvLyB0eXBlIG9mIGRhdGEgMDogdW5kZWZpbmVkL251bGwsIDE6IHN0cmluZywgMjogb2JqZWN0LCAzOiBhcnJheVxuICAgICAgdHlwZTogMCxcbiAgICAgIC8vIG9yaWdpbmFsIHZhbHVlcyAoZXhjZXB0IHVuZGVmaW5lZC9udWxsKVxuICAgICAgdmFsOiBbXSxcbiAgICAgIC8vIGNhY2hlIGZvciBlbmNvZGVkIHZhbHVlcyAob25seSBmb3Igbm9uLW1heGxlbmd0aCBleHBhbnNpb24pXG4gICAgICBlbmNvZGU6IFtdLFxuICAgICAgZW5jb2RlUmVzZXJ2ZWQ6IFtdXG4gICAgfTtcbiAgICB2YXIgaSwgbCwgdmFsdWU7XG5cbiAgICBpZiAodGhpcy5jYWNoZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIHRoaXMga2V5XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVtrZXldO1xuICAgIH1cblxuICAgIHRoaXMuY2FjaGVba2V5XSA9IGQ7XG5cbiAgICBpZiAoU3RyaW5nKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgIC8vIGRhdGEgaXRzZWxmIGlzIGEgY2FsbGJhY2sgKGdsb2JhbCBjYWxsYmFjaylcbiAgICAgIHZhbHVlID0gZGF0YShrZXkpO1xuICAgIH0gZWxzZSBpZiAoU3RyaW5nKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhW2tleV0pKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgLy8gZGF0YSBpcyBhIG1hcCBvZiBjYWxsYmFja3MgKGxvY2FsIGNhbGxiYWNrKVxuICAgICAgdmFsdWUgPSBkYXRhW2tleV0oa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGF0YSBpcyBhIG1hcCBvZiBkYXRhXG4gICAgICB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICB9XG5cbiAgICAvLyBnZW5lcmFsaXplIGlucHV0IGludG8gWyBbbmFtZTEsIHZhbHVlMV0sIFtuYW1lMiwgdmFsdWUyXSwg4oCmIF1cbiAgICAvLyBzbyBleHBhbnNpb24gaGFzIHRvIGRlYWwgd2l0aCBhIHNpbmdsZSBkYXRhIHN0cnVjdHVyZSBvbmx5XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIC8vIHVuZGVmaW5lZCBhbmQgbnVsbCB2YWx1ZXMgYXJlIHRvIGJlIGlnbm9yZWQgY29tcGxldGVseVxuICAgICAgcmV0dXJuIGQ7XG4gICAgfSBlbHNlIGlmIChTdHJpbmcoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHZhbHVlW2ldICE9PSB1bmRlZmluZWQgJiYgdmFsdWVbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBhcnJheXMgZG9uJ3QgaGF2ZSBuYW1lc1xuICAgICAgICAgIGQudmFsLnB1c2goW3VuZGVmaW5lZCwgU3RyaW5nKHZhbHVlW2ldKV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkLnZhbC5sZW5ndGgpIHtcbiAgICAgICAgLy8gb25seSB0cmVhdCBub24tZW1wdHkgYXJyYXlzIGFzIGFycmF5c1xuICAgICAgICBkLnR5cGUgPSAzOyAvLyBhcnJheVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoU3RyaW5nKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgZm9yIChpIGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbCh2YWx1ZSwgaSkgJiYgdmFsdWVbaV0gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZVtpXSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIG9iamVjdHMgaGF2ZSBrZXlzLCByZW1lbWJlciB0aGVtIGZvciBuYW1lZCBleHBhbnNpb25cbiAgICAgICAgICBkLnZhbC5wdXNoKFtpLCBTdHJpbmcodmFsdWVbaV0pXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGQudmFsLmxlbmd0aCkge1xuICAgICAgICAvLyBvbmx5IHRyZWF0IG5vbi1lbXB0eSBvYmplY3RzIGFzIG9iamVjdHNcbiAgICAgICAgZC50eXBlID0gMjsgLy8gb2JqZWN0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGQudHlwZSA9IDE7IC8vIHByaW1pdGl2ZSBzdHJpbmcgKGNvdWxkJ3ZlIGJlZW4gc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4gYW5kIG9iamVjdHMgd2l0aCBhIHRvU3RyaW5nKCkpXG4gICAgICAvLyBhcnJheXMgZG9uJ3QgaGF2ZSBuYW1lc1xuICAgICAgZC52YWwucHVzaChbdW5kZWZpbmVkLCBTdHJpbmcodmFsdWUpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG4gIH07XG5cbiAgLy8gaG9vayBpbnRvIFVSSSBmb3IgZmx1aWQgYWNjZXNzXG4gIFVSSS5leHBhbmQgPSBmdW5jdGlvbihleHByZXNzaW9uLCBkYXRhKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gbmV3IFVSSVRlbXBsYXRlKGV4cHJlc3Npb24pO1xuICAgIHZhciBleHBhbnNpb24gPSB0ZW1wbGF0ZS5leHBhbmQoZGF0YSk7XG5cbiAgICByZXR1cm4gbmV3IFVSSShleHBhbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBVUklUZW1wbGF0ZTtcbn0pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/urijs/src/URITemplate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/urijs/src/punycode.js":
/*!********************************************!*\
  !*** ./node_modules/urijs/src/punycode.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.0 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXJpanMvc3JjL3B1bnljb2RlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxtQkFBbUIsS0FBMEI7QUFDN0M7QUFDQSxrQkFBa0IsS0FBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksVUFBVTtBQUN0QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLE1BQU07QUFDTiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCLDBDQUEwQyxxQkFBcUI7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9COztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsaUJBQWlCO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUVVO0FBQ1o7QUFDQSxFQUFFLG1DQUFtQjtBQUNyQjtBQUNBLEdBQUc7QUFBQSxrR0FBQztBQUNKLEdBQUcsS0FBSyxFQWFOOztBQUVGLENBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVVNVQVJJT1xcRG9jdW1lbnRzXFxHaXRodWJcXEdhbGF4eUtKLXdhbGxldC0tLUhhY2tcXHdlYlxcbm9kZV9tb2R1bGVzXFx1cmlqc1xcc3JjXFxwdW55Y29kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/urijs/src/punycode.js\n");

/***/ })

};
;